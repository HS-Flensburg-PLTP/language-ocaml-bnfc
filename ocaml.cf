{-
/* Tokens */

/* The alias that follows each token is used by Menhir when it needs to
   produce a sentence (that is, a sequence of tokens) in concrete syntax. */

/* Some tokens represent multiple concrete strings. In most cases, an
   arbitrary concrete string can be chosen. In a few cases, one must
   be careful: e.g., in PREFIXOP and INFIXOP2, one must choose a concrete
   string that will not trigger a syntax error; see how [not_expecting]
   is used in the definition of [type_variance]. */

let lowercase = ['a'-'z' '_']
let symbolchar =
  ['!' '$' '%' '&' '*' '+' '-' '.' '/' ':' '<' '=' '>' '?' '@' '^' '|' '~']
let dotsymbolchar =
  ['!' '$' '%' '&' '*' '+' '-' '/' ':' '=' '>' '?' '@' '^' '|']
let kwdopchar =
  ['$' '&' '*' '+' '-' '/' '<' '=' '>' '@' '^' '|']

%token AMPERAMPER             "&&"
%token AMPERSAND              "&"
%token AND                    "and"
%token AS                     "as"
%token ASSERT                 "assert"
%token BACKQUOTE              "`"
%token BANG                   "!"
%token BAR                    "|"
%token BARBAR                 "||"
%token BARRBRACKET            "|]"
%token BEGIN                  "begin"
%token <char> CHAR            "'a'" (* just an example *)
-}

token CHAR '\'' ( (char - ["'\\"])
                | ('\\' ( ["\\\"'nrtb "]
                        | digit digit digit
                        | 'x' (letter | digit) (letter | digit)
                        | 'o' ["0123"] ["01234567"] ["01234567"]
                ))) '\'' ;

{-
%token CLASS                  "class"
%token COLON                  ":"
%token COLONCOLON             "::"
%token COLONEQUAL             ":="
%token COLONGREATER           ":>"
%token COMMA                  ","
%token CONSTRAINT             "constraint"
%token DO                     "do"
%token DONE                   "done"
%token DOT                    "."
%token DOTDOT                 ".."
%token DOWNTO                 "downto"
%token ELSE                   "else"
%token END                    "end"
%token EOF                    ""
%token EQUAL                  "="
%token EXCEPTION              "exception"
%token EXTERNAL               "external"
%token FALSE                  "false"
%token <string * char option> FLOAT "42.0" (* just an example *)

  | float_literal | hex_float_literal as lit
      { FLOAT (lit, None) }
  | (float_literal | hex_float_literal as lit) (literal_modifier as modif)
      { FLOAT (lit, Some modif) }

let float_literal =
  ['0'-'9'] ['0'-'9' '_']*
  ('.' ['0'-'9' '_']* )?
  (['e' 'E'] ['+' '-']? ['0'-'9'] ['0'-'9' '_']* )?
let hex_float_literal =
  '0' ['x' 'X']
  ['0'-'9' 'A'-'F' 'a'-'f'] ['0'-'9' 'A'-'F' 'a'-'f' '_']*
  ('.' ['0'-'9' 'A'-'F' 'a'-'f' '_']* )?
  (['p' 'P'] ['+' '-']? ['0'-'9'] ['0'-'9' '_']* )?
-}

token FLOAT (digit (digit | '_')* ('.' (digit | '_')*)? (["eE"] ["+-"]? digit (digit | '_')* )? )
          | ('0' ["xX"] (digit | letter) (digit | letter | '_')* ('.' (digit | letter | '_')* )? (["pP"] ["+-"] digit (digit | '_')* )?) ;

{-
%token FOR                    "for"
%token FUN                    "fun"
%token FUNCTION               "function"
%token FUNCTOR                "functor"
%token GREATER                ">"
%token GREATERRBRACE          ">}"
%token GREATERRBRACKET        ">]"
%gIF                     "if"
%token IN                     "in"
%token INCLUDE                "include"
%token <string> INFIXOP0      "!="   (* just an example *)

  | ['=' '<' '>' '|' '&' '$'] symbolchar * as op
            { INFIXOP0 op }
-}

token RELOP ["=<>|&$"] ["!$%&*+-./:<=>?@^|~"]* ;

{-
%token <string> INFIXOP1      "@"    (* just an example *)

  | ['@' '^'] symbolchar * as op
            { INFIXOP1 op }
-}

token CONCATOP ["@^"] ["!$%&*+-./:<=>?@^|~"]* ;

{-
%token <string> INFIXOP2      "+!"   (* chosen with care; see above *)

  | ['+' '-'] symbolchar * as op
            { INFIXOP2 op }
-}

token PLUSMINUSOP ["+-"] ["!$%&*+-./:<=>?@^|~"]* ;

{-
%token <string> INFIXOP3      "land" (* just an example *)

  | ['*' '/' '%'] symbolchar * as op
            { INFIXOP3 op }
-}

token MULTDIVOP ["*/%"] ["!$%&*+-./:<=>?@^|~"]* ;

{-
%token <string> INFIXOP4      "**"   (* just an example *)

  | "**" symbolchar * as op
            { INFIXOP4 op }
-}

token POWOP {"**"} ["!$%&*+-./:<=>?@^|~"]* ;

{-
%token <string> DOTOP         ".+"

  | "." (dotsymbolchar symbolchar* as op) { DOTOP op }
-}

token DOTOP '.' ["!$%&*+-/:=>?@^|"] ["!$%&*+-./:<=>?@^|~"]* ;

{-
%token <string> LETOP         "let*" (* just an example *)

  | "let" kwdopchar dotsymbolchar * as op
            { LETOP op }
-}

token LETOP {"let"} ["$&*+-/<=>@^|"] ["$&*+-/<=>@^|"]* ;

{-
%token <string> ANDOP         "and*" (* just an example *)

  | "and" kwdopchar dotsymbolchar * as op
            { ANDOP op }
-}

token ANDOP {"and"} ["$&*+-/<=>@^|"] ["$&*+-/<=>@^|"]*  ;

{-
%token INHERIT                "inherit"
%token INITIALIZER            "initializer"
%token <string * char option> INT "42"  (* just an example *)

  | int_literal as lit { INT (lit, None) }
  | (int_literal as lit) (literal_modifier as modif)
      { INT (lit, Some modif) }

let decimal_literal =
  ['0'-'9'] ['0'-'9' '_']*
let hex_literal =
  '0' ['x' 'X'] ['0'-'9' 'A'-'F' 'a'-'f']['0'-'9' 'A'-'F' 'a'-'f' '_']*
let oct_literal =
  '0' ['o' 'O'] ['0'-'7'] ['0'-'7' '_']*
let bin_literal =
  '0' ['b' 'B'] ['0'-'1'] ['0'-'1' '_']*
let int_literal =
  decimal_literal | hex_literal | oct_literal | bin_literal
let literal_modifier = ['G'-'Z' 'g'-'z']
-}

token DecimalLiteral digit (digit | '_')* ;

token DecimalLiteralModifier digit (digit | '_')* ["GHIJKLMNOPQRSTUVWXYZghijklmnopqrstuvwxyz"] ;

token HexLiteral '0' ["xX"] (digit | letter) (digit | letter | '_')* ;

token HexLiteralModifier '0' ["xX"] (digit | letter) (digit | letter | '_')* ["GHIJKLMNOPQRSTUVWXYZghijklmnopqrstuvwxyz"] ;

token OctLiteral '0' ["oO"] ["01234567"] ["01234567_"]* ;

token OctLiteralModifier '0' ["oO"] ["01234567"] ["01234567_"]* ["GHIJKLMNOPQRSTUVWXYZghijklmnopqrstuvwxyz"] ;

token BinLiteral '0' ["bB"] ["01"] ["01_"]* ;

token BinLiteralModifier '0' ["bB"] ["01"] ["01_"]* ["GHIJKLMNOPQRSTUVWXYZghijklmnopqrstuvwxyz"] ;

ModifiedDecimal. INT ::= DecimalLiteralModifier ;
Decimal.         INT ::= DecimalLiteral ;
ModifiedHex.     INT ::= HexLiteralModifier ;
Hex.             INT ::= HexLiteral ;
ModifiedOct.     INT ::= OctLiteralModifier ;
Oct.             INT ::= OctLiteral ;
ModifiedBin.     INT ::= BinLiteralModifier ;
Bin.             INT ::= BinLiteral ;

{-
%token <string> LABEL         "~label:" (* just an example *)

  | "~" raw_ident_escape (lowercase identchar * as name) ':'
      { LABEL name }
  | "~" (lowercase identchar * as name) ':'
      { check_label_name lexbuf name;
        LABEL name }
  | "~" (lowercase_latin1 identchar_latin1 * as name) ':'
      { warn_latin1 lexbuf;
        LABEL name }
-}

-- token LABEL '~' {"\\#"} (lower | '_') (letter | digit | '_' | '\'')* ':' ;

-- token LABEL '~' (lower | '_') (letter | digit | '_' | '\'')* ;

-- token LABEL '~' (letter | digit | '_' )

-- TODO: Implement LABEL correctly

token LABEL '~' (letter | digit | '_' ) (letter | digit | '_' )* ':' ;

{-
%token LAZY                   "lazy"
%token LBRACE                 "{"
%token LBRACELESS             "{<"
%token LBRACKET               "["
%token LBRACKETBAR            "[|"
%token LBRACKETLESS           "[<"
%token LBRACKETGREATER        "[>"
%token LBRACKETPERCENT        "[%"
%token LBRACKETPERCENTPERCENT "[%%"
%token LESS                   "<"
%token LESSMINUS              "<-"
%token LET                    "let"
%token <string> LIDENT        "lident" (* just an example *)

  | lowercase identchar * as name
      { try Hashtbl.find keyword_table name
        with Not_found -> LIDENT name }
  | lowercase_latin1 identchar_latin1 * as name
      { warn_latin1 lexbuf; LIDENT name }
-}

position token LIDENT (lower | '_') (letter | digit | '_' | '\'')* ;

{-
%token LPAREN                 "("
%token LBRACKETAT             "[@"
%token LBRACKETATAT           "[@@"
%token LBRACKETATATAT         "[@@@"
%token MATCH                  "match"
%token METHOD                 "method"
%token MINUS                  "-"
%token MINUSDOT               "-."
%token MINUSGREATER           "->"
%token MODULE                 "module"
%token MUTABLE                "mutable"
%token NEW                    "new"
%token NONREC                 "nonrec"
%token OBJECT                 "object"
%token OF                     "of"
%token OPEN                   "open"
%token <string> OPTLABEL      "?label:" (* just an example *)

  | "?" raw_ident_escape (lowercase identchar * as name) ':'
      { OPTLABEL name }
  | "?" (lowercase identchar * as name) ':'
      { check_label_name lexbuf name;
        OPTLABEL name }
  | "?" (lowercase_latin1 identchar_latin1 * as name) ':'
      { warn_latin1 lexbuf;
        OPTLABEL name }

let raw_ident_escape = "\\#"
let uppercase = ['A'-'Z']
let identchar = ['A'-'Z' 'a'-'z' '_' '\'' '0'-'9']
let identchar_latin1 =
  ['A'-'Z' 'a'-'z' '_' '\192'-'\214' '\216'-'\246' '\248'-'\255' '\'' '0'-'9']
-}

-- token OPTLABEL '?' {"\\#"} (lower | '_') (letter | digit | '_' | '\'')* ':' ;

-- token OPTLABEL '?' (lower | '_') (letter | digit | '_' | '\'')* ;

-- token OPTLABEL '?' (letter | digit | '_' )

-- TODO: Implement OPTLABEL correctly

token OPTLABEL '?' (letter | digit | '_' ) (letter | digit | '_' )* ':' ;

{-
%token OR                     "or"
/* %token PARSER              "parser" */
%token PERCENT                "%"
%token PLUS                   "+"
%token PLUSDOT                "+."
%token PLUSEQ                 "+="
%token <string> PREFIXOP      "!+" (* chosen with care; see above *)

  | "!" symbolchar_or_hash + as op
            { PREFIXOP op }
  | ['~' '?'] symbolchar_or_hash + as op
            { PREFIXOP op }
-}

token PREFIXOP '!' ["~!?%<:.$&*+-/=>@^|"] | ('?' | '~') ["~!?%<:.$&*+-/=>@^|"]+ ;

{-
%token PRIVATE                "private"
%token QUESTION               "?"
%token QUOTE                  "'"
%token RBRACE                 "}"
%token RBRACKET               "]"
%token REC                    "rec"
%token RPAREN                 ")"
%token SEMI                   ";"
%token SEMISEMI               ";;"
%token HASH                   "#"
%token <string> HASHOP        "##" (* just an example *)

  | '#' symbolchar_or_hash + as op
            { HASHOP op }
-}

token HASHOP '#' ["~!?%<:.$&*+-/=>@^|"]+ ;

{-
%token SIG                    "sig"
%token STAR                   "*"
%token <string * Location.t * string option>
       STRING                 "\"hello\"" (* just an example *)
-}

token STRING '"' ((char - ["\"\\"])
                 | ('\\' ( ["\\\"'nrtb "]
                         | digit digit digit
                         | 'x' (letter | digit) (letter | digit)
                         | 'o' ["0123"] ["01234567"] ["01234567"]
                   ))
                 | '\n'
                 | '\\' '\n' (' ' | '\t')* )* '"' ;

{-
%token <string * Location.t * string * Location.t * string option>
       QUOTED_STRING_EXPR     "{%hello|world|}"  (* just an example *)

  | "{%" (extattrident as id) "|"
      { let orig_loc = Location.curr lexbuf in
        let s, loc = wrap_string_lexer (quoted_string "") lexbuf in
        let idloc = compute_quoted_string_idloc orig_loc 2 id in
        QUOTED_STRING_EXPR (id, idloc, s, loc, Some "") }
  | "{%" (extattrident as id) blank+ (lowercase* as delim) "|"
      { let orig_loc = Location.curr lexbuf in
        let s, loc = wrap_string_lexer (quoted_string delim) lexbuf in
        let idloc = compute_quoted_string_idloc orig_loc 2 id in
        QUOTED_STRING_EXPR (id, idloc, s, loc, Some delim) }

and quoted_string delim = parse
  | newline as nl
      { update_loc lexbuf None 1 false 0;
        store_normalized_newline nl;
        quoted_string delim lexbuf
      }
  | eof
      { is_in_string := false;
        error_loc !string_start_loc Unterminated_string }
  | "|" (lowercase* as edelim) "}"
      {
        if delim = edelim then lexbuf.lex_start_p
        else (store_lexeme lexbuf; quoted_string delim lexbuf)
      }
  | (_ as c)
      { store_string_char c;
        quoted_string delim lexbuf }

let ident = (lowercase | uppercase) identchar*
let extattrident = ident ('.' ident)*
-}

token QUOTED_STRING_EXPR {"{%"} letter (letter | digit | '_')* ('.' letter (letter | digit | '_')*)* '|' ;

{-
%token <string * Location.t * string * Location.t * string option>
       QUOTED_STRING_ITEM     "{%%hello|world|}" (* just an example *)

  | "{%%" (extattrident as id) "|"
      { let orig_loc = Location.curr lexbuf in
        let s, loc = wrap_string_lexer (quoted_string "") lexbuf in
        let idloc = compute_quoted_string_idloc orig_loc 3 id in
        QUOTED_STRING_ITEM (id, idloc, s, loc, Some "") }
  | "{%%" (extattrident as id) blank+ (lowercase* as delim) "|"
      { let orig_loc = Location.curr lexbuf in
        let s, loc = wrap_string_lexer (quoted_string delim) lexbuf in
        let idloc = compute_quoted_string_idloc orig_loc 3 id in
        QUOTED_STRING_ITEM (id, idloc, s, loc, Some delim) }
-}

-- TODO: Improve definition

token QUOTED_STRING_ITEM {"{%%"} letter (letter | digit | '_')* ('.' letter (letter | digit | '_')*)* '|' ;

{-
%token STRUCT                 "struct"
%token THEN                   "then"
%token TILDE                  "~"
%token TO                     "to"
%token TRUE                   "true"
%token TRY                    "try"
%token TYPE                   "type"
%token <string> UIDENT        "UIdent" (* just an example *)

  | uppercase identchar * as name
      { UIDENT name } (* No capitalized keywords *)
  | uppercase_latin1 identchar_latin1 * as name
      { warn_latin1 lexbuf; UIDENT name }
-}

token UIDENT upper (letter | digit | '_' | '\'')* ;

{-
%token UNDERSCORE             "_"
%token VAL                    "val"
%token VIRTUAL                "virtual"
%token WHEN                   "when"
%token WHILE                  "while"
%token WITH                   "with"
%token <string * Location.t> COMMENT    "(* comment *)"
-}

{-
%token <Docstrings.docstring> DOCSTRING "(** documentation *)"

%token EOL                    "\\n"      (* not great, but EOL is unused *)
-}

{-
/* Precedences and associativities.

Tokens and rules have precedences.  A reduce/reduce conflict is resolved
in favor of the first rule (in source file order).  A shift/reduce conflict
is resolved by comparing the precedence and associativity of the token to
be shifted with those of the rule to be reduced.

By default, a rule has the precedence of its rightmost terminal (if any).

When there is a shift/reduce conflict between a rule and a token that
have the same precedence, it is resolved using the associativity:
if the token is left-associative, the parser will reduce; if
right-associative, the parser will shift; if non-associative,
the parser will declare a syntax error.

We will only use associativities with operators of the kind  x * x -> x
for example, in the rules of the form    expr: expr BINOP expr
in all other cases, we define two precedences if needed to resolve
conflicts.

The precedences must be listed from low to high.
*/

%nonassoc IN
%nonassoc below_SEMI
%nonassoc SEMI                          /* below EQUAL ({lbl=...; lbl=...}) */
%nonassoc LET                           /* above SEMI ( ...; let ... in ...) */
%nonassoc below_WITH
%nonassoc FUNCTION WITH                 /* below BAR  (match ... with ...) */
%nonassoc AND             /* above WITH (module rec A: SIG with ... and ...) */
%nonassoc THEN                          /* below ELSE (if ... then ...) */
%nonassoc ELSE                          /* (if ... then ... else ...) */
%nonassoc LESSMINUS                     /* below COLONEQUAL (lbl <- x := e) */
%right    COLONEQUAL                    /* expr (e := e := e) */
%nonassoc AS
%left     BAR                           /* pattern (p|p|p) */
%nonassoc below_COMMA
%left     COMMA                         /* expr/expr_comma_list (e,e,e) */
%right    MINUSGREATER                  /* function_type (t -> t -> t) */
%right    OR BARBAR                     /* expr (e || e || e) */
%right    AMPERSAND AMPERAMPER          /* expr (e && e && e) */
%nonassoc below_EQUAL
%left     INFIXOP0 EQUAL LESS GREATER   /* expr (e OP e OP e) */
%right    INFIXOP1                      /* expr (e OP e OP e) */
%nonassoc below_LBRACKETAT
%nonassoc LBRACKETAT
%right    COLONCOLON                    /* expr (e :: e :: e) */
%left     INFIXOP2 PLUS PLUSDOT MINUS MINUSDOT PLUSEQ /* expr (e OP e OP e) */
%left     PERCENT INFIXOP3 STAR                 /* expr (e OP e OP e) */
%right    INFIXOP4                      /* expr (e OP e OP e) */
%nonassoc prec_unary_minus prec_unary_plus /* unary - */
%nonassoc prec_constant_constructor     /* cf. simple_expr (C versus C x) */
%nonassoc prec_constr_appl              /* above AS BAR COLONCOLON COMMA */
%nonassoc below_HASH
%nonassoc HASH                         /* simple_expr/toplevel_directive */
%left     HASHOP
%nonassoc below_DOT
%nonassoc DOT DOTOP
/* Finally, the first tokens of simple_expr are above everything else. */
%nonassoc BACKQUOTE BANG BEGIN CHAR FALSE FLOAT INT OBJECT
          LBRACE LBRACELESS LBRACKET LBRACKETBAR LIDENT LPAREN
          NEW PREFIXOP STRING TRUE UIDENT
          LBRACKETPERCENT QUOTED_STRING_EXPR


/* Entry points */
-}

entrypoints Implementation, UseFile;

{-
/* Several start symbols are marked with AVOID so that they are not used by
   [make generate-parse-errors]. The three start symbols that we keep are
   [implementation], [use_file], and [toplevel_phrase]. The latter two are
   of marginal importance; only [implementation] really matters, since most
   states in the automaton are reachable from it. */

%start implementation                   /* for implementation files */
%type <Parsetree.structure> implementation
/* BEGIN AVOID */
%start interface                        /* for interface files */
%type <Parsetree.signature> interface
/* END AVOID */
%start toplevel_phrase                  /* for interactive use */
%type <Parsetree.toplevel_phrase> toplevel_phrase
%start use_file                         /* for the #use directive */
%type <Parsetree.toplevel_phrase list> use_file
/* BEGIN AVOID */
%start parse_module_type
%type <Parsetree.module_type> parse_module_type
%start parse_module_expr
%type <Parsetree.module_expr> parse_module_expr
%start parse_core_type
%type <Parsetree.core_type> parse_core_type
%start parse_expression
%type <Parsetree.expression> parse_expression
%start parse_pattern
%type <Parsetree.pattern> parse_pattern
%start parse_constr_longident
%type <Longident.t> parse_constr_longident
%start parse_val_longident
%type <Longident.t> parse_val_longident
%start parse_mty_longident
%type <Longident.t> parse_mty_longident
%start parse_mod_ext_longident
%type <Longident.t> parse_mod_ext_longident
%start parse_mod_longident
%type <Longident.t> parse_mod_longident
%start parse_any_longident
%type <Longident.t> parse_any_longident
/* END AVOID */

%%

/* macros */
%inline extra_str(symb): symb { extra_str $startpos $endpos $1 };
%inline extra_sig(symb): symb { extra_sig $startpos $endpos $1 };
%inline extra_cstr(symb): symb { extra_cstr $startpos $endpos $1 };
%inline extra_csig(symb): symb { extra_csig $startpos $endpos $1 };
%inline extra_def(symb): symb { extra_def $startpos $endpos $1 };
%inline extra_text(symb): symb { extra_text $startpos $endpos $1 };
%inline extra_rhs(symb): symb { extra_rhs_core_type $1 ~pos:$endpos($1) };
%inline mkrhs(symb): symb
    { mkrhs $1 $sloc }
;

%inline text_str(symb): symb
  { text_str $startpos @ [$1] }
%inline text_str_SEMISEMI: SEMISEMI
  { text_str $startpos }
%inline text_sig(symb): symb
  { text_sig $startpos @ [$1] }
%inline text_sig_SEMISEMI: SEMISEMI
  { text_sig $startpos }
%inline text_def(symb): symb
  { text_def $startpos @ [$1] }
%inline top_def(symb): symb
  { Ptop_def [$1] }
%inline text_cstr(symb): symb
  { text_cstr $startpos @ [$1] }
%inline text_csig(symb): symb
  { text_csig $startpos @ [$1] }

(* Using this %inline definition means that we do not control precisely
   when [mark_rhs_docs] is called, but I don't think this matters. *)
%inline mark_rhs_docs(symb): symb
  { mark_rhs_docs $startpos $endpos;
    $1 }

%inline op(symb): symb
   { mkoperator ~loc:$sloc $1 }

%inline mkloc(symb): symb
    { mkloc $1 (make_loc $sloc) }

%inline mkexp(symb): symb
    { mkexp ~loc:$sloc $1 }
%inline mkpat(symb): symb
    { mkpat ~loc:$sloc $1 }
%inline mktyp(symb): symb
    { mktyp ~loc:$sloc $1 }
%inline mkstr(symb): symb
    { mkstr ~loc:$sloc $1 }
%inline mksig(symb): symb
    { mksig ~loc:$sloc $1 }
%inline mkmod(symb): symb
    { mkmod ~loc:$sloc $1 }
%inline mkmty(symb): symb
    { mkmty ~loc:$sloc $1 }
%inline mkcty(symb): symb
    { mkcty ~loc:$sloc $1 }
%inline mkctf(symb): symb
    { mkctf ~loc:$sloc $1 }
%inline mkcf(symb): symb
    { mkcf ~loc:$sloc $1 }
%inline mkclass(symb): symb
    { mkclass ~loc:$sloc $1 }

%inline wrap_mkstr_ext(symb): symb
    { wrap_mkstr_ext ~loc:$sloc $1 }
%inline wrap_mksig_ext(symb): symb
    { wrap_mksig_ext ~loc:$sloc $1 }

%inline mk_directive_arg(symb): symb
    { mk_directive_arg ~loc:$sloc $1 }

/* Generic definitions */

(* [iloption(X)] recognizes either nothing or [X]. Assuming [X] produces
   an OCaml list, it produces an OCaml list, too. *)

%inline iloption(X):
  /* nothing */
    { [] }
| x = X
    { x }

(* [llist(X)] recognizes a possibly empty list of [X]s. It is left-recursive. *)

reversed_llist(X):
  /* empty */
    { [] }
| xs = reversed_llist(X) x = X
    { x :: xs }

%inline llist(X):
  xs = rev(reversed_llist(X))
    { xs }

(* [reversed_nonempty_llist(X)] recognizes a nonempty list of [X]s, and produces
   an OCaml list in reverse order -- that is, the last element in the input text
   appears first in this list. Its definition is left-recursive. *)

reversed_nonempty_llist(X):
  x = X
    { [ x ] }
| xs = reversed_nonempty_llist(X) x = X
    { x :: xs }

(* [nonempty_llist(X)] recognizes a nonempty list of [X]s, and produces an OCaml
   list in direct order -- that is, the first element in the input text appears
   first in this list. *)

%inline nonempty_llist(X):
  xs = rev(reversed_nonempty_llist(X))
    { xs }

(* [reversed_nonempty_concat(X)] recognizes a nonempty sequence of [X]s (each of
   which is a list), and produces an OCaml list of their concatenation in
   reverse order -- that is, the last element of the last list in the input text
   appears first in the list.
*)
reversed_nonempty_concat(X):
  x = X
    { List.rev x }
| xs = reversed_nonempty_concat(X) x = X
    { List.rev_append x xs }

(* [nonempty_concat(X)] recognizes a nonempty sequence of [X]s
   (each of which is a list), and produces an OCaml list of their concatenation
   in direct order -- that is, the first element of the first list in the input
   text appears first in the list.
*)

%inline nonempty_concat(X):
  xs = rev(reversed_nonempty_concat(X))
    { xs }

(* [reversed_separated_nonempty_llist(separator, X)] recognizes a nonempty list
   of [X]s, separated with [separator]s, and produces an OCaml list in reverse
   order -- that is, the last element in the input text appears first in this
   list. Its definition is left-recursive. *)

(* [inline_reversed_separated_nonempty_llist(separator, X)] is semantically
   equivalent to [reversed_separated_nonempty_llist(separator, X)], but is
   marked %inline, which means that the case of a list of length one and
   the case of a list of length more than one will be distinguished at the
   use site, and will give rise there to two productions. This can be used
   to avoid certain conflicts. *)

%inline inline_reversed_separated_nonempty_llist(separator, X):
  x = X
    { [ x ] }
| xs = reversed_separated_nonempty_llist(separator, X)
  separator
  x = X
    { x :: xs }

reversed_separated_nonempty_llist(separator, X):
  xs = inline_reversed_separated_nonempty_llist(separator, X)
    { xs }

(* [separated_nonempty_llist(separator, X)] recognizes a nonempty list of [X]s,
   separated with [separator]s, and produces an OCaml list in direct order --
   that is, the first element in the input text appears first in this list. *)

%inline separated_nonempty_llist(separator, X):
  xs = rev(reversed_separated_nonempty_llist(separator, X))
    { xs }

%inline inline_separated_nonempty_llist(separator, X):
  xs = rev(inline_reversed_separated_nonempty_llist(separator, X))
    { xs }

(* [reversed_separated_nontrivial_llist(separator, X)] recognizes a list of at
   least two [X]s, separated with [separator]s, and produces an OCaml list in
   reverse order -- that is, the last element in the input text appears first
   in this list. Its definition is left-recursive. *)

reversed_separated_nontrivial_llist(separator, X):
  xs = reversed_separated_nontrivial_llist(separator, X)
  separator
  x = X
    { x :: xs }
| x1 = X
  separator
  x2 = X
    { [ x2; x1 ] }

(* [separated_nontrivial_llist(separator, X)] recognizes a list of at least
   two [X]s, separated with [separator]s, and produces an OCaml list in direct
   order -- that is, the first element in the input text appears first in this
   list. *)

%inline separated_nontrivial_llist(separator, X):
  xs = rev(reversed_separated_nontrivial_llist(separator, X))
    { xs }

(* [separated_or_terminated_nonempty_list(delimiter, X)] recognizes a nonempty
   list of [X]s, separated with [delimiter]s, and optionally terminated with a
   final [delimiter]. Its definition is right-recursive. *)

separated_or_terminated_nonempty_list(delimiter, X):
  x = X ioption(delimiter)
    { [x] }
| x = X
  delimiter
  xs = separated_or_terminated_nonempty_list(delimiter, X)
    { x :: xs }

(* [reversed_preceded_or_separated_nonempty_llist(delimiter, X)] recognizes a
   nonempty list of [X]s, separated with [delimiter]s, and optionally preceded
   with a leading [delimiter]. It produces an OCaml list in reverse order. Its
   definition is left-recursive. *)

reversed_preceded_or_separated_nonempty_llist(delimiter, X):
  ioption(delimiter) x = X
    { [x] }
| xs = reversed_preceded_or_separated_nonempty_llist(delimiter, X)
  delimiter
  x = X
    { x :: xs }

(* [preceded_or_separated_nonempty_llist(delimiter, X)] recognizes a nonempty
   list of [X]s, separated with [delimiter]s, and optionally preceded with a
   leading [delimiter]. It produces an OCaml list in direct order. *)

%inline preceded_or_separated_nonempty_llist(delimiter, X):
  xs = rev(reversed_preceded_or_separated_nonempty_llist(delimiter, X))
    { xs }

(* [bar_llist(X)] recognizes a nonempty list of [X]'s, separated with BARs,
   with an optional leading BAR. We assume that [X] is itself parameterized
   with an opening symbol, which can be [epsilon] or [BAR]. *)

(* This construction may seem needlessly complicated: one might think that
   using [preceded_or_separated_nonempty_llist(BAR, X)], where [X] is *not*
   itself parameterized, would be sufficient. Indeed, this simpler approach
   would recognize the same language. However, the two approaches differ in
   the footprint of [X]. We want the start location of [X] to include [BAR]
   when present. In the future, we might consider switching to the simpler
   definition, at the cost of producing slightly different locations. TODO *)

reversed_bar_llist(X):
    (* An [X] without a leading BAR. *)
    x = X(epsilon)
      { [x] }
  | (* An [X] with a leading BAR. *)
    x = X(BAR)
      { [x] }
  | (* An initial list, followed with a BAR and an [X]. *)
    xs = reversed_bar_llist(X)
    x = X(BAR)
      { x :: xs }

%inline bar_llist(X):
  xs = reversed_bar_llist(X)
    { List.rev xs }

(* [xlist(A, B)] recognizes [AB*]. We assume that the semantic value for [A]
   is a pair [x, b], while the semantic value for [B*] is a list [bs].
   We return the pair [x, b :: bs]. *)

%inline xlist(A, B):
  A B*

(* [listx(delimiter, X, Y)] recognizes a nonempty list of [X]s, optionally
   followed with a [Y], separated-or-terminated with [delimiter]s. The
   semantic value is a pair of a list of [X]s and an optional [Y]. *)

listx(delimiter, X, Y):
| x = X ioption(delimiter)
    { [x], None }
| x = X delimiter y = Y delimiter?
    { [x], Some y }
| x = X
  delimiter
  tail = listx(delimiter, X, Y)
    { let xs, y = tail in
      x :: xs, y }

(* -------------------------------------------------------------------------- *)

(* Entry points. *)

(* An .ml file. *)
implementation:
  structure EOF
;
-}

Implementation. Implementation ::= Structure ;

{-
/* BEGIN AVOID */
(* An .mli file. *)
interface:
  signature EOF
;
/* END AVOID */
-}

Interface. Interface ::= Signature ;

{-
(* A toplevel phrase. *)
toplevel_phrase:
  (* An expression with attributes, ended by a double semicolon. *)
  extra_str(text_str(str_exp)) SEMISEMI
| (* A list of structure items, ended by a double semicolon. *)
  extra_str(flatten(text_str(structure_item)*)) SEMISEMI
| (* A directive, ended by a double semicolon. *)
  toplevel_directive SEMISEMI
| (* End of input. *)
  EOF
;
-}

separator StructureItem "" ;

StrExpr.           ToplevelPhrase ::= SeqExpr [PostItemAttribute] ";;" ;
StructureItems.    ToplevelPhrase ::= [StructureItem] ";;" ;
ToplevelDirective. ToplevelPhrase ::= ToplevelDirective ";;" ;

{-
(* An .ml file that is read by #use. *)
use_file:
  (* An optional standalone expression,
     followed with a series of elements,
     followed with EOF. *)
    optional_use_file_standalone_expression use_file_element*
    EOF
;
-}

UseFile.           UseFile ::= [UseFileElement] ;
UseFileWithStrExp. UseFile ::= SeqExpr [PostItemAttribute] [UseFileElement] ;

separator UseFileElement "" ;

{-
(* An optional standalone expression is just an expression with attributes
   (str_exp), with extra wrapping. *)
%inline optional_use_file_standalone_expression:
  iloption(str_exp)
;
-}

-- This definition is inlined manually

{-
(* An element in a #used file is one of the following:
   - a double semicolon followed with an optional standalone expression;
   - a structure item;
   - a toplevel directive.
 *)
%inline use_file_element:
  preceded(SEMISEMI, optional_use_file_standalone_expression)
| structure_item
| toplevel_directive
;
-}

NoUseFileElement.         UseFileElement ::= ";;" ;
UseFileStrExp.            UseFileElement ::= ";;" SeqExpr [PostItemAttribute] ;
UseFileStructureItem.     UseFileElement ::= StructureItem ;
UseFileToplevelDirective. UseFileElement ::= ToplevelDirective ;

{-
(* -------------------------------------------------------------------------- *)

(* Functor arguments appear in module expressions and module types. *)

%inline functor_args:
  reversed_nonempty_llist(functor_arg)
;
-}

separator nonempty FunctorArg "" ;

{-
functor_arg:
    (* An anonymous and untyped argument. *)
    LPAREN RPAREN
  | (* An argument accompanied with an explicit type. *)
    LPAREN module_name COLON module_type RPAREN
;
-}

NoFunctorArg. FunctorArg ::= "(" ")" ;
FunctorArg.   FunctorArg ::= "(" ModuleName ":" ModuleType ")" ;

{-
module_name:
    (* A named argument. *)
    UIDENT
  | (* An anonymous argument. *)
    UNDERSCORE
;
-}

ModuleNameIdent.      ModuleName ::= UIDENT ;
ModuleNameUnderscore. ModuleName ::= "_" ;

{-
(* -------------------------------------------------------------------------- *)

(* Module expressions. *)

(* The syntax of module expressions is not properly stratified. The cases of
   functors, functor applications, and attributes interact and cause conflicts,
   which are resolved by precedence declarations. This is concise but fragile.
   Perhaps in the future an explicit stratification could be used. *)

module_expr:
  | STRUCT attributes structure END
  | FUNCTOR attributes functor_args MINUSGREATER module_expr
  | paren_module_expr
  | module_expr attribute
  | (* A module identifier. *)
    mod_longident
  | (* In a functor application, the actual argument must be parenthesized. *)
    module_expr paren_module_expr
  | (* Functor applied to unit. *)
    module_expr LPAREN RPAREN
  | (* An extension. *)
    extension
;
-}

ModuleExprStruct.     ModuleExpr ::= "struct" [Attribute] Structure "end" ;
ModuleExprFunctor.    ModuleExpr ::= "functor" [Attribute] [FunctorArg] "->" ModuleExpr ;
ModuleExprParen.      ModuleExpr ::= ParenModuleExpr ;
ModuleExpr.           ModuleExpr ::= ModuleExpr Attribute ;
ModuleExprIdent.      ModuleExpr ::= ModLongident ;
ModuleExprFunctorApp. ModuleExpr ::= ModuleExpr ParenModuleExpr ;
FunctorAppUnit.       ModuleExpr ::= ModuleExpr "(" ")" ;
ModuleExprExtension.  ModuleExpr ::= Extension ;

{-
(* A parenthesized module expression is a module expression that begins
   and ends with parentheses. *)

paren_module_expr:
    (* A module expression annotated with a module type. *)
    LPAREN module_expr COLON module_type RPAREN
  | (* A module expression within parentheses. *)
    LPAREN module_expr RPAREN
  | (* A core language expression that produces a first-class module.
       This expression can be annotated in various ways. *)
    LPAREN VAL attributes expr_colon_package_type RPAREN
;
-}

TypedParenModuleExpr. ParenModuleExpr ::= "(" ModuleExpr ":" ModuleType ")" ;
ParenModuleExpr.      ParenModuleExpr ::= "(" ModuleExpr ")" ;
ValParenModuleExpr.   ParenModuleExpr ::= "(" "val" [Attribute] ExprColonPackageType ")" ;

{-
(* The various ways of annotating a core language expression that
   produces a first-class module that we wish to unpack. *)
%inline expr_colon_package_type:
    expr
  | expr COLON package_type
  | expr COLON package_type COLONGREATER package_type
  | expr COLONGREATER package_type
;
-}

Expr.              ExprColonPackageType ::= Expr ;
TypedExpr.         ExprColonPackageType ::= Expr ":" ModuleType ;
TypedCoercionExpr. ExprColonPackageType ::= Expr ":" ModuleType ":>" ModuleType ;
CoercionExpr.      ExprColonPackageType ::= Expr ":>" ModuleType ;

{-
(* A structure, which appears between STRUCT and END (among other places),
   begins with an optional standalone expression, and continues with a list
   of structure elements. *)
structure:
  optional_structure_standalone_expression
  structure_element*
;
-}

separator nonempty StructureElement "" ;

NoStructure.                              Structure ::= ;
StandaloneExpression.                     Structure ::= SeqExpr [PostItemAttribute] ;
StandaloneExpressionAndStructureElements. Structure ::= SeqExpr [PostItemAttribute] [StructureElement] ;
StructureElements.                        Structure ::= [StructureElement] ;

{-
(* An optional standalone expression is just an expression with attributes
   (str_exp), with extra wrapping. *)

%inline optional_structure_standalone_expression:
  iloption(str_exp)
;
-}

-- This definition is inlined manually

{-
(* An expression with attributes, wrapped as a structure item. *)
%inline str_exp:
  seq_expr post_item_attributes
;
-}

-- This definition is inlined manually

{-
(* A structure element is one of the following:
   - a double semicolon followed with an optional standalone expression;
   - a structure item. *)
%inline structure_element:
    SEMISEMI optional_structure_standalone_expression)
  | structure_item
;
-}

StructureSemiSemi. StructureElement ::= ";;" ;
StructureStrExpr.  StructureElement ::= ";;" SeqExpr [PostItemAttribute] ;
StructureItem.     StructureElement ::= StructureItem ;

{-
(* A structure item. *)
structure_item:
    let_bindings(ext)
  | item_extension post_item_attributes
  | floating_attribute
  | primitive_declaration
  | value_description
  | type_declarations
  | str_type_extension
  | str_exception_declaration
  | module_binding
  | rec_module_bindings
  | module_type_declaration
  | open_declaration
  | class_declarations
  | class_type_declarations
  | include_statement(module_expr)
;
-}

StructureLetBindings.           StructureItem ::= LetBindingsExt ;
StructureItemExtension.         StructureItem ::= ItemExtension [PostItemAttribute] ;
StructureFloatingAttribute.     StructureItem ::= FloatingAttribute ;
StructurePrimitiveDeclaration.  StructureItem ::= PrimitiveDeclaration ;
StructureValueDescription.      StructureItem ::= ValueDescription ;
StructureTypeDeclarations.      StructureItem ::= TypeDeclaration [AndTypeDeclaration] ;
StructureStrTypeExtension.      StructureItem ::= StrTypeExtension ;
StrExceptionDeclaration.        StructureItem ::= StrExceptionDeclaration ;
StructureModuleBinding.         StructureItem ::= "module" Ext [Attribute] ModuleName ModuleBindingBody [PostItemAttribute] ;
StructureRecModuleBindings.     StructureItem ::= "module" Ext [Attribute] "rec" ModuleName ModuleBindingBody [PostItemAttribute] [AndModuleBinding] ;
StructureModuleTypeDeclaration. StructureItem ::= ModuleTypeDeclaration ;
StructureOpenDeclaration.       StructureItem ::= OpenDeclaration ;
StructureClassDeclarations.     StructureItem ::= "class" Ext [Attribute] VirtualFlag FormalClassParameters LIDENT ClassFunBinding [PostItemAttribute] [AndClassDeclaration] ;
StructureClassTypeDeclarations. StructureItem ::= ClassTypeDeclarations ;
StructureIncludeStatement.      StructureItem ::= "include" Ext [Attribute] ModuleExpr [PostItemAttribute] ;

{-
%inline include_statement(thing):
  INCLUDE ext attributes thing post_item_attributes
;
-}

-- This definition is inlined manually

{-
(* A floating attribute is an attribute that appears at the top level of
   a structure. *)

(* A single module binding. *)
%inline module_binding:
  MODULE ext attributes module_name module_binding_body post_item_attributes
;
-}

-- This definition is inlined manually

{-
(* The body (right-hand side) of a module binding. *)
module_binding_body:
    EQUAL module_expr
  | COLON module_type EQUAL module_expr
  | functor_arg module_binding_body
;
-}

ModuleBinding.      ModuleBindingBody ::= "=" ModuleExpr ;
TypedModuleBinding. ModuleBindingBody ::= ":" ModuleType "=" ModuleExpr ;
FunctorBinding.     ModuleBindingBody ::= FunctorArg ModuleBindingBody ;

{-
(* A group of recursive module bindings. *)
%inline rec_module_bindings:
  xlist(rec_module_binding, and_module_binding)
;
-}

-- This definition is inlined manually

[].  [AndModuleBinding] ::= ;
(:). [AndModuleBinding] ::= "and" AndModuleBinding [AndModuleBinding] ;

{-
(* The first binding in a group of recursive module bindings. *)
%inline rec_module_binding:
  MODULE ext attributes REC module_name module_binding_body post_item_attributes
;
-}

-- This definition is inlined manually

{-
(* The following bindings in a group of recursive module bindings. *)
%inline and_module_binding:
  AND attributes module_name module_binding_body post_item_attributes
;
-}

AndModuleBinding. AndModuleBinding ::= [Attribute] ModuleName ModuleBindingBody [PostItemAttribute] ;

{-
(* A module type declaration. *)
module_type_declaration:
  MODULE TYPE ext attributes mkrhs(ident) preceded(EQUAL, module_type)? post_item_attributes
;
-}

NoModuleType. OptionalModuleType ::= ;
AModuleType.  OptionalModuleType ::= "=" ModuleType ;

ModuleTypeDeclaration. ModuleTypeDeclaration ::= "module" "type" [Attribute] OCamlIdent OptionalModuleType [PostItemAttribute] ;

{-
(* -------------------------------------------------------------------------- *)

(* Opens. *)

open_declaration:
  OPEN override_flag ext attributes module_expr post_item_attributes
;
-}

OpenDeclaration. OpenDeclaration ::= "open" OverrideFlag Ext [Attribute] ModuleExpr [PostItemAttribute] ;

{-
open_description:
  OPEN override_flag ext attributes mod_ext_longident post_item_attributes
;
-}

OpenDescription. OpenDescription ::= "open" OverrideFlag Ext [Attribute] ModExtLongident [PostItemAttribute] ;

{-
%inline open_dot_declaration: mod_longident
;
-}

-- This definition is inlined manually

{-
(* -------------------------------------------------------------------------- *)

/* Module types */

module_type:
  | SIG attributes signature END
  | FUNCTOR attributes functor_args
    MINUSGREATER module_type
    %prec below_WITH
  | MODULE TYPE OF attributes module_expr
    %prec below_LBRACKETAT
  | LPAREN module_type RPAREN
  | module_type attribute
  | mty_longident
  | LPAREN RPAREN MINUSGREATER module_type
  | module_type MINUSGREATER module_type
        %prec below_WITH
  | module_type WITH separated_nonempty_llist(AND, with_constraint)
  | extension
;
-}

separator nonempty WithConstraint "and" ;

ModuleTypeSignature.       ModuleType ::= "sig" [Attribute] Signature "end" ;
ModuleTypeFunctor.         ModuleType ::= "functor" [Attribute] [FunctorArg] "->" ModuleType ;
ModuleTypeOf.              ModuleType ::= "module" "type" "of" [Attribute] ModuleExpr ;
ParenModuleType.           ModuleType ::= "(" ModuleType ")" ;
ModuleTypeWithAttribute.   ModuleType ::= ModuleType Attribute ;
ModuleTypeModuleIdent.     ModuleType ::= ModLongident ;
ModuleTypeNoArgFunctorApp. ModuleType ::= "(" ")" "->" ModuleType ;
ModuleTypeFunctorApp.      ModuleType ::= ModuleType "->" ModuleType ;
ModuleTypeWith.            ModuleType ::= ModuleType "with" [WithConstraint] ;
ModuleTypeExtension.       ModuleType ::= Extension ;

{-
(* A signature, which appears between SIG and END (among other places),
   is a list of signature elements. *)
signature:
  signature_element*
;
-}

Signature. Signature ::= [SignatureElement] ;

separator SignatureElement "" ;

{-
(* A signature element is one of the following:
   - a double semicolon;
   - a signature item. *)
%inline signature_element:
    SEMISEMI
  | signature_item
;
-}

SigSemiSemi. SignatureElement ::= ";;" ;
SigItem.     SignatureElement ::= SignatureItem ;

{-
(* A signature item. *)
signature_item:
  | item_extension post_item_attributes
  | floating_attribute
  | value_description
  | primitive_declaration
  | type_declarations
  | type_subst_declarations
  | sig_type_extension
  | sig_exception_declaration
  | module_declaration
  | module_alias
  | module_subst
  | rec_module_declarations
  | module_type_declaration
  | module_type_subst
  | open_description
  | include_statement(module_type)
  | class_descriptions
  | class_type_declarations
-}

SigItemExtension.           SignatureItem ::= ItemExtension [PostItemAttribute] ;
SigFloatingAttribute.       SignatureItem ::= FloatingAttribute ;
SigValueDescription.        SignatureItem ::= ValueDescription ;
SigPrimitiveDeclaration.    SignatureItem ::= PrimitiveDeclaration ;
SigTypeDeclarations.        SignatureItem ::= TypeDeclaration [AndTypeDeclaration] ;
SigTypeSubstDeclarations.   SignatureItem ::= TypeSubstDeclarations ;
SigSigTypeExtension.        SignatureItem ::= SigTypeExtension ;
SigSigExceptionDeclaration. SignatureItem ::= SigExceptionDeclaration ;
SigModuleDeclaration.       SignatureItem ::= ModuleDeclaration ;
SigModuleAlias.             SignatureItem ::= ModuleAlias ;
SigModuleSubst.             SignatureItem ::= ModuleSubst ;
SigRecModuleDeclarations.   SignatureItem ::= RecModuleDeclaration [AndModuleDeclaration] ; ;
SigModuleTypeDeclaration.   SignatureItem ::= ModuleTypeDeclaration ;
SigModuleTypeSubst.         SignatureItem ::= ModuleTypeSubst ;
SigOpenDescription.         SignatureItem ::= OpenDescription ;
SigIncludeStatement.        SignatureItem ::= ModuleTypeIncludeStatement ;
SigClassDescription.        SignatureItem ::= "class" Ext [Attribute] VirtualFlag FormalClassParameters LIDENT ":" ClassType [PostItemAttribute] [AndClassDescription] ;
SigClassTypeDeclarations.   SignatureItem ::= ClassTypeDeclarations ;

{-
%inline include_statement(thing):
  INCLUDE ext attributes thing post_item_attributes
;
-}

ModuleTypeIncludeStatement. ModuleTypeIncludeStatement ::= "include" Ext [Attribute] ModuleType [PostItemAttribute] ;

{-
(* A module declaration. *)
%inline module_declaration:
  MODULE ext attributes module_name module_declaration_body post_item_attributes
;
-}

ModuleDeclaration. ModuleDeclaration ::= "module" Ext [Attribute] ModuleName ModuleDeclarationBody [PostItemAttribute] ;

{-
(* The body (right-hand side) of a module declaration. *)
module_declaration_body:
    COLON module_type
  | functor_arg body module_declaration_body
;
-}

ModuleBody.  ModuleDeclarationBody ::= ":" ModuleType ;
FunctorBody. ModuleDeclarationBody ::= FunctorArg ModuleDeclarationBody ;

{-
(* A module alias declaration (in a signature). *)
%inline module_alias:
  MODULE ext attributes module_name EQUAL module_expr_alias post_item_attributes
;
-}

ModuleAlias. ModuleAlias ::= "module" Ext [Attribute] ModuleName "=" ModuleExprAlias [PostItemAttribute] ;

{-
%inline module_expr_alias:
  mod_longident
;
-}

ModuleExprAlias. ModuleExprAlias ::= ModLongident ;

{-
(* A module substitution (in a signature). *)
module_subst:
  MODULE ext attributes UIDENT COLONEQUAL mod_ext_longident post_item_attributes
;
-}

ModuleSubst. ModuleSubst ::= "module" Ext [Attribute] UIDENT ":=" ModExtLongident [PostItemAttribute] ;

{-
(* A group of recursive module declarations. *)
%inline rec_module_declarations:
  xlist(rec_module_declaration, and_module_declaration)
;
-}

-- This definition is inlined manually

{-
%inline rec_module_declaration:
  MODULE ext attributes REC module_name COLON module_type post_item_attributes
;
-}

RecModuleDeclaration. RecModuleDeclaration ::= "module" Ext [Attribute] "rec" ModuleName ":" ModuleType [PostItemAttribute] ;

{-
%inline and_module_declaration:
  AND attributes module_name COLON module_type post_item_attributes
;
-}

AndModuleDeclaration. AndModuleDeclaration ::= [Attribute] ModuleName ":" ModuleType [PostItemAttribute] ;

separator AndModuleDeclaration "and" ;

{-
(* A module type substitution *)
module_type_subst:
  MODULE TYPE ext attributes ident COLONEQUAL module_type post_item_attributes
-}

ModuleTypeSubst. ModuleTypeSubst ::= "module" "type" Ext [Attribute] OCamlIdent ":=" ModuleType [PostItemAttribute] ;

{-
(* -------------------------------------------------------------------------- *)

(* Class declarations. *)

%inline class_declarations:
  xlist(class_declaration, and_class_declaration)
;
-}

-- This definition is inlined manually

{-
%inline class_declaration:
  CLASS ext attributes virtual_flag formal_class_parameters LIDENT class_fun_binding post_item_attributes
;
-}

-- This definition is inlined manually

{-
%inline and_class_declaration:
  AND attributes virtual_flag formal_class_parameters LIDENT class_fun_binding post_item_attributes
;
-}

AndClassDeclaration. AndClassDeclaration ::= "and" [Attribute] VirtualFlag FormalClassParameters LIDENT ClassFunBinding [PostItemAttribute] ;

separator AndClassDeclaration "" ;

{-
class_fun_binding:
    EQUAL class_expr
  | COLON class_type EQUAL class_expr
  | labeled_simple_pattern class_fun_binding
;
-}

ClassFunBinding.        ClassFunBinding ::= "=" ClassExpr ;
TypedClassFunBinding.   ClassFunBinding ::= ":" ClassType "=" ClassExpr ;
LabeledClassFunBinding. ClassFunBinding ::= LabeledSimplePattern ClassFunBinding ;

{-
formal_class_parameters:
  class_parameters(type_parameter)
;
-}

NoFormalClassParamters. FormalClassParameters ::= ;
FormalClassParameters.  FormalClassParameters ::= "[" [TypeParameter] "]" ;

{-
%inline class_parameters(parameter):
  | /* empty */
  | LBRACKET separated_nonempty_llist(COMMA, parameter) RBRACKET
-}

{-
(* -------------------------------------------------------------------------- *)

(* Class expressions. *)

class_expr:
    class_simple_expr
  | FUN attributes class_fun_def
  | let_bindings(no_ext) IN class_expr
  | LET OPEN override_flag attributes mkrhs(mod_longident) IN class_expr
  | class_expr attribute
  | class_simple_expr nonempty_llist(labeled_simple_expr)
  | extension
;
-}

ClassSimpleExpr.        ClassExpr ::= ClassSimpleExpr ;
ClassExprFunctor.       ClassExpr ::= "fun" [Attribute] ClassFunDef ;
ClassExprLetBindings.   ClassExpr ::= LetBindingsNoExt "in" ClassExpr ;
ClassExprLetOpen.       ClassExpr ::= "let" "open" OverrideFlag [Attribute] ModLongident "in" ClassExpr ;
ClassExpr.              ClassExpr ::= ClassExpr Attribute ;
LabeledClassSimpleExpr. ClassExpr ::= ClassSimpleExpr [LabeledSimpleExpr] ;
ClassExprExtension.     ClassExpr ::= Extension ;

{-
class_simple_expr:
  | LPAREN class_expr RPAREN
  | actual_class_parameters class_longident
  | LPAREN class_expr COLON class_type RPAREN
  | OBJECT attributes class_structure END
;
-}

ParenClassExpr.         ClassSimpleExpr ::= "(" ClassExpr ")" ;
ClassName.              ClassSimpleExpr ::= ClassLongident ;
ClassNameWithParamters. ClassSimpleExpr ::= "[" [CoreType] "]" ClassLongident ;
TypedClassExpr.         ClassSimpleExpr ::= "(" ClassExpr ":" ClassType ")" ;
ClassSimplExprObject.   ClassSimpleExpr ::= "object" [Attribute] ClassStructure "end" ;

{-
class_fun_def:
    labeled_simple_pattern MINUSGREATER class_expr
  | labeled_simple_pattern class_fun_def
;
-}

ClassFun.           ClassFunDef ::= LabeledSimplePattern "->" ClassExpr ;
LabeledClassFunDef. ClassFunDef ::= LabeledSimplePattern ClassFunDef ;

{-
%inline class_structure:
  |  class_self_pattern class_fields
;
-}

ClassSelfPattern. ClassStructure ::= ClassSelfPattern [ClassField] ;

{-
class_self_pattern:
    LPAREN pattern RPAREN
  | LPAREN pattern COLON core_type RPAREN
  | /* empty */
;
-}

ParenClassPattern.  ClassSelfPattern ::= "(" Pattern ")" ;
TypedClassPattern.  ClassSelfPattern ::= "(" Pattern ":" CoreType ")" ;
NoClassSelfPattern. ClassSelfPattern ::= ;

{-
%inline class_fields:
  class_field*
;
-}

separator ClassField "" ;

{-
class_field:
  | INHERIT override_flag attributes class_expr preceded(AS, LIDENT)? post_item_attributes
  | VAL value post_item_attributes
  | METHOD method_ post_item_attributes
  | CONSTRAINT attributes constrain_field post_item_attributes
  | INITIALIZER attributes seq_expr post_item_attributes
  | item_extension post_item_attributes
  | floating_attribute
;

constrain_field:
  core_type EQUAL core_type
;
-}

NoAs. OptionalAs ::= ;
AAs.  OptionalAs ::= "as" LIDENT ;

ClassFieldInherit.           ClassField ::= "inherit" OverrideFlag [Attribute] ClassExpr OptionalAs [PostItemAttribute] ;
ClassFieldVal.               ClassField ::= "val" Value [PostItemAttribute] ;
ClassFieldMethod.            ClassField ::= "method" Method_ [PostItemAttribute] ;
ClassFieldConstraint.        ClassField ::= "constraint" [Attribute] CoreType "=" CoreType [PostItemAttribute] ;
ClassFieldInitializer.       ClassField ::= "initializer" [Attribute] SeqExpr [PostItemAttribute] ;
ClassFieldItemExtension.     ClassField ::= ItemExtension [PostItemAttribute] ;
ClassFieldFloatingAttribute. ClassField ::= FloatingAttribute ;

{-
value:
    no_override_flag attributes virtual_with_mutable_flag label COLON core_type
  | override_flag attributes mutable_flag label EQUAL seq_expr
  | override_flag attributes mutable_flag label type_constraint EQUAL seq_expr
;
-}

Value1. Value ::= NoOverrideFlag [Attribute] VirtualWithMutableFlag LIDENT ":" CoreType ;
Value2. Value ::= OverrideFlag [Attribute] MutableFlag LIDENT "=" SeqExpr ;
Value3. Value ::= OverrideFlag [Attribute] MutableFlag LIDENT TypeConstraint "=" SeqExpr ;

{-
method_:
    no_override_flag attributes virtual_with_private_flag label COLON poly_type
  | override_flag attributes private_flag label strict_binding
  | override_flag attributes private_flag label COLON poly_type EQUAL seq_expr
  | override_flag attributes private_flag label COLON TYPE lident_list
    DOT core_type EQUAL seq_expr
;
-}

Method1. Method_ ::= NoOverrideFlag [Attribute] VirtualWithPrivateFlag LIDENT ":" PolyType ;
Method2. Method_ ::= OverrideFlag [Attribute] PrivateFlag LIDENT StrictBinding ;
Method3. Method_ ::= OverrideFlag [Attribute] PrivateFlag LIDENT ":" PolyType "=" SeqExpr ;
Method4. Method_ ::= OverrideFlag [Attribute] PrivateFlag LIDENT ":" "type" [LIDENT] "." CoreType "=" SeqExpr ;

{-
/* Class types */

class_type:
    class_signature
  | arg_label tuple_type MINUSGREATER class_type
 ;
-}

ClassSignature.             ClassType ::= ClassSignature ;
ClassTypeWithOptLabel.      ClassType ::= OPTLABEL TupleType "->" ClassType ;
ClassTypeWithOptionalLabel. ClassType ::= "?" LIDENT ":" TupleType "->" ClassType ;
ClassTypeWithtLabel.        ClassType ::= LIDENT ":" TupleType "->" ClassType ;
ClassTypeWithoutLabel.      ClassType ::= TupleType "->" ClassType ;

{-
class_signature:
    actual_class_parameters clty_longident
  | extension
  | OBJECT attributes class_sig_body END
  | class_signature attribute
  | LET OPEN override_flag attributes mod_longident IN class_signature
;

%inline class_sig_body:
    class_self_type class_sig_fields
;

%inline class_sig_fields:
  class_sig_field*
;
-}

ClassSignatureName.              ClassSignature ::= CltyLongident ;
ClassSignatureNameWithParamters. ClassSignature ::= "[" [CoreType] "]" CltyLongident ;
ClassSignatureExtension.         ClassSignature ::= Extension ;
ClassSignatureObject.            ClassSignature ::= "object" [Attribute] ClassSelfType [ClassSigField] "end" ;
WithAttribute.                   ClassSignature ::= ClassSignature Attribute ;
ClassSignatureLetOpen.           ClassSignature ::= "let" "open" OverrideFlag [Attribute] ModLongident "in" ClassSignature ;

{-
class_self_type:
    LPAREN core_type RPAREN
  | (* empty *)
;
-}

ClassSelfType.   ClassSelfType ::= "(" CoreType ")" ;
NoClassSelfType. ClassSelfType ::= ;

{-
%inline class_parameters(parameter):
  | /* empty */
  | LBRACKET separated_nonempty_llist(COMMA, parameter) RBRACKET
;
%inline actual_class_parameters:
  class_parameters(core_type)
;
-}

-- This definition is inlined manually

{-
class_sig_field:
    INHERIT attributes class_signature post_item_attributes
  | VAL attributes value_type post_item_attributes
  | METHOD attributes private_virtual_flags label COLON poly_type post_item_attributes
  | CONSTRAINT attributes constrain_field post_item_attributes
  | item_extension post_item_attributes
  | floating_attribute
;

%inline value_type:
  mutable_virtual_flags label COLON core_type
;

constrain_field:
  core_type EQUAL core_type
;
-}

ClassSigFieldInherit.           ClassSigField ::= "inherit" [Attribute] ClassSignature [PostItemAttribute] ;
ClassSigFieldVal.               ClassSigField ::= "val" [Attribute] MutableVirtualFlags LIDENT ":" CoreType [PostItemAttribute] ;
ClassSigFieldMethod.            ClassSigField ::= "method" [Attribute] PrivateVirtualFlags LIDENT ":" PolyType [PostItemAttribute] ;
ClassSigFieldConstraint.        ClassSigField ::= "constraint" [Attribute] CoreType "=" CoreType [PostItemAttribute] ;
ClassSigFieldItemExtension.     ClassSigField ::= ItemExtension [PostItemAttribute] ;
ClassSigFieldFloatingAttribute. ClassSigField ::= FloatingAttribute ;

separator ClassSigField "" ;

{-
%inline constrain:
    core_type EQUAL core_type
;
-}

Constrain. Constrain ::= CoreType "=" CoreType ;

{-
(* A group of class descriptions. *)
%inline class_descriptions:
  xlist(class_description, and_class_description)
    { $1 }
;
%inline class_description:
  CLASS ext attributes virtual_flag formal_class_parameters LIDENT COLON class_type post_item_attributes
;
-}

-- This definition is inlined manually

{-
%inline and_class_description:
  AND attributes virtual_flag formal_class_parameters LIDENT COLON class_type post_item_attributes
;
-}

AndClassDescription. AndClassDescription ::= "and" [Attribute] VirtualFlag FormalClassParameters LIDENT ":" ClassType [PostItemAttribute] ;

separator AndClassDescription "" ;

{-
class_type_declarations:
  xlist(class_type_declaration, and_class_type_declaration)
;
-}

ClassTypeDeclarations. ClassTypeDeclarations ::= ClassTypeDeclaration [AndClassTypeDeclaration] ;

{-
%inline class_type_declaration:
  CLASS TYPE ext attributes virtual_flag formal_class_parameters LIDENT EQUAL class_signature post_item_attributes
;
-}

ClassTypeDeclaration. ClassTypeDeclaration ::= "class" "type" Ext [Attribute] VirtualFlag FormalClassParameters LIDENT "=" ClassSignature [PostItemAttribute] ;

{-
%inline and_class_type_declaration:
  AND attributes virtual_flag formal_class_parameters LIDENT EQUAL class_signature post_item_attributes
;
-}

AndClassTypeDeclaration. AndClassTypeDeclaration ::= [Attribute] VirtualFlag FormalClassParameters LIDENT "=" ClassSignature [PostItemAttribute] ;

separator AndClassTypeDeclaration "and" ;

{-
/* Core expressions */

%inline or_function(EXPR):
  | EXPR
  | FUNCTION ext_attributes match_cases
;

(* [fun_seq_expr] (and [fun_expr]) are legal expression bodies of a function.
   [seq_expr] (and [expr]) are expressions that appear in other contexts
   (e.g. subexpressions of the expression body of a function).

   [fun_seq_expr] can't be a bare [function _ -> ...]. [seq_expr] can.

   This distinction exists because [function _ -> ...] is parsed as a *function
   cases* body of a function, not an expression body. This so functions can be
   parsed with the intended arity.
*)
-}

{-
fun_seq_expr:
  | fun_expr    %prec below_SEMI
  | fun_expr SEMI
  | fun_expr SEMI seq_expr
  | fun_expr SEMI PERCENT attr_id seq_expr
;
-}

-- This definition is inlined manually

{-
seq_expr:
  | or_function(fun_seq_expr)
;

%inline or_function(EXPR):
  | EXPR
  | FUNCTION ext_attributes match_cases
;
-}

-- ; precedence 2, associativity right
FinalFunExpr.     SeqExpr ::= FunExpr1 ;
FinalFunExprSemi. SeqExpr ::= FunExpr1 ";" ;
MoreFunExprs.     SeqExpr ::= FunExpr1 ";" SeqExpr ;
MoreFunExprsAttr. SeqExpr ::= FunExpr1 ";" "%" [AttrId] SeqExpr ;
SeqExprFunction.  SeqExpr ::= "function" Ext [Attribute] [MatchCase] ;

{-
labeled_simple_pattern:
    QUESTION LPAREN label_let_pattern opt_default RPAREN
  | QUESTION label_var
  | OPTLABEL LPAREN let_pattern opt_default RPAREN
  | OPTLABEL pattern_var
  | TILDE LPAREN label_let_pattern RPAREN
  | TILDE label_var
  | LABEL simple_pattern
  | simple_pattern
;
-}

OptPattern.           LabeledSimplePattern ::= "?" "(" LabelLetPattern OptDefault ")" ;
OptLabelVar.          LabeledSimplePattern ::= "?" LIDENT ;
OptLabeledPattern.    LabeledSimplePattern ::= OPTLABEL "(" LetPattern OptDefault ")" ;
OptLabeledVar.        LabeledSimplePattern ::= OPTLABEL PatternVar ;
LabeledPattern.       LabeledSimplePattern ::= "~" "(" LabelLetPattern ")" ;
LabeledVar.           LabeledSimplePattern ::= "~" LIDENT ;
LabeledSimplePattern. LabeledSimplePattern ::= LABEL SimplePattern ;
SimplePattern.        LabeledSimplePattern ::= SimplePattern ;

{-
pattern_var:
    LIDENT
  | UNDERSCORE
;
-}

PatternVar.           PatternVar ::= LIDENT ;
UnderscorePatternVar. PatternVar ::= "_" ;

{-
%inline opt_default:
  preceded(EQUAL, seq_expr)?
;
-}

NoDefault. OptDefault ::= ;
Default.   OptDefault ::= "=" SeqExpr ;

{-
label_let_pattern:
    label_var
  | label_var COLON core_type
;
-}

LabelLetPattern.      LabelLetPattern ::= LIDENT ;
TypedLabelLetPattern. LabelLetPattern ::= LIDENT ":" CoreType ;

{-
%inline label_var:
    LIDENT
;
-}

-- This definition is inlined manually

{-
let_pattern:
    pattern
  | pattern COLON core_type
;
-}

LetPattern.      LetPattern ::= Pattern ;
TypedLetPattern. LetPattern ::= Pattern ":" CoreType ;

{-
%inline qualified_dotop: ioption(DOT mod_longident {$2}) DOTOP ;
-}

Unqualified. QualifiedDotop ::= DOTOP ;
Qualified.   QualifiedDotop ::= "." ModLongident DOTOP ;

{-
fun_expr:
    simple_expr %prec below_HASH
  | fun_expr_attrs
  | expr_
  | let_bindings(ext) IN seq_expr
  | LETOP letop_bindings IN seq_expr
  | fun_expr COLONCOLON expr
  | label LESSMINUS expr
  | simple_expr DOT label_longident LESSMINUS expr
  | indexop_expr(DOT, seq_expr, LESSMINUS expr)
  | indexop_expr(qualified_dotop, expr_semi_list, LESSMINUS expr)
  | fun_expr attribute
-}

NoAtomicTypeAnnotation. OptionalAtomicTypeAnnotation ::= ;
AnAtomicTypeAnnotation. OptionalAtomicTypeAnnotation ::= ":" AtomicType ;

ConstrName_.           FunExpr16 ::= ConstrLongident ;
-- TODO

-- function application, constructor application, tag application, assert, lazy precedence 15, associativity left
NameTagApp.            FunExpr15 ::= NameTag SimpleExpr16 ;
SimpleExprApp.         FunExpr15 ::= SimpleExpr16 [LabeledSimpleExpr] ;
Assert.                FunExpr15 ::= "assert" Ext [Attribute] SimpleExpr16 ;
Lazy.                  FunExpr15 ::= "lazy" Ext [Attribute] SimpleExpr16 ;
SimpleExpr.            FunExpr15 ::= SimpleExpr16 ;

-- - -. (prefix) precedence 14
Subtractive.           FunExpr14 ::= Subtractive Expr15 ;
Additive.              FunExpr14 ::= Additive Expr15 ;

-- ** lsl lsr asr precedence 13, associativity right
PowInfix.              FunExpr13 ::= FunExpr14 POWOP Expr13 ;

-- *... /... %... mod land lor lxor precedence 12, associativity left
MultDivInfix.          FunExpr12 ::= FunExpr12 MULTDIVOP Expr13 ;
MultInfix.             FunExpr12 ::= FunExpr12 "*" Expr13 ;
DivInfix.              FunExpr12 ::= FunExpr12 "/" Expr13 ;
ModInfix.              FunExpr12 ::= FunExpr12 "%" Expr13 ;

-- +... -... precedence 11, associativity left
PlusMinusInfix.        FunExpr11 ::= FunExpr11 PLUSMINUSOP Expr12 ;
PlusInfix.             FunExpr11 ::= FunExpr11 "+" Expr12 ;
PlusDotInfix.          FunExpr11 ::= FunExpr11 "+." Expr12 ;
MinusInfix.            FunExpr11 ::= FunExpr11 "-" Expr12 ;
MinusDotInfix.         FunExpr11 ::= FunExpr11 "-." Expr12 ;

-- :: precedence 10, associativity right
Cons.                  FunExpr10 ::= FunExpr11 "::" Expr10 ;

-- @... ^... precedence 9, associativity right
ConcatInfix.           FunExpr9  ::= FunExpr10 CONCATOP Expr9 ;

-- =... <... >... |... &... $... != precedence 8, associativity left
RelInfix.              FunExpr8  ::= FunExpr8 RELOP Expr9 ;
EqualInfix.            FunExpr8  ::= FunExpr8 "=" Expr9 ;
LessInfix.             FunExpr8  ::= FunExpr8 "<" Expr9 ;
GreaterInfix.          FunExpr8  ::= FunExpr8 ">" Expr9 ;

-- & && precedence 7, associativity right
Infix.                 FunExpr7  ::= FunExpr8 "&" Expr7 ;
Infix.                 FunExpr7  ::= FunExpr8 "&&" Expr7 ;

-- or || precedence 6, associativity right
OrInfix.               FunExpr6  ::= FunExpr7 "or" Expr6 ;
BarBarInfix.           FunExpr6  ::= FunExpr7 "||" Expr6 ;

-- , precedence 5
Comma.                 FunExpr5  ::= Expr6 "," [ExprComma] ;

-- <- := precedence 4, associativity right
UpdateExpr.            FunExpr4  ::= LIDENT "<-" Expr ;
AssignInfix.           FunExpr4  ::= FunExpr5 ":=" Expr ;
QualifiedDot.          FunExpr4  ::= SimpleExpr17 "." LabelLongident "<-" Expr ;
ArrayUpdateExpr.       FunExpr4  ::= SimpleExpr17 "." "(" SeqExpr ")" "<-" Expr ;
RecordUpdateExpr.      FunExpr4  ::= SimpleExpr17 "." "{" SeqExpr "}" "<-" Expr ;
StringUpdateExpr.      FunExpr4  ::= SimpleExpr17 "." "[" SeqExpr "]" "<-" Expr ;
ArrayUpdateDotopExpr.  FunExpr4  ::= SimpleExpr17 QualifiedDotop "(" [Expr] ")" "<-" Expr ;
RecordUpdateDotopExpr. FunExpr4  ::= SimpleExpr17 QualifiedDotop "{" [Expr] "}" "<-" Expr ;
StringUpdateDotopExpr. FunExpr4  ::= SimpleExpr17 QualifiedDotop "[" [Expr] "]" "<-" Expr ;

-- if precedence 3
IfElse.                FunExpr3  ::= "if" Ext [Attribute] SeqExpr "then" Expr "else" Expr ;
If.                    FunExpr3  ::= "if" Ext [Attribute] SeqExpr "then" Expr ;

-- ; precedence 2, associativity right
-- see SeqExpr

-- let match fun function try precedence 1
Let.                   FunExpr1 ::= LetBindingsExt "in" SeqExpr ;
LetOpBinding.          FunExpr1 ::= LETOP LetopBindings "in" SeqExpr ;
LetModule.             FunExpr1 ::= "let" "module" Ext [Attribute] ModuleName ModuleBindingBody "in" SeqExpr ;
LetException.          FunExpr1 ::= "let" "exception" Ext [Attribute] LetExceptionDeclaration "in" SeqExpr ;
LetOpen.               FunExpr1 ::= "let" "open" OverrideFlag Ext [Attribute] ModuleExpr "in" SeqExpr ;
Fun.                   FunExpr1 ::= "fun" Ext [Attribute] [FunParamAsList] OptionalAtomicTypeAnnotation "->" FunBody ;
Match.                 FunExpr1 ::= "match" Ext [Attribute] SeqExpr "with" [MatchCase] ;
Try.                   FunExpr1 ::= "try" Ext [Attribute] SeqExpr "with" [MatchCase] ;
While.                 FunExpr1 ::= "while" Ext [Attribute] SeqExpr "do" SeqExpr "done" ;
For.                   FunExpr1 ::= "for" Ext [Attribute] Pattern "=" SeqExpr DirectionFlag SeqExpr "do" SeqExpr "done" ;

-- TODO: What is the precedence of this rule?
FunExprWithAttribute.  FunExpr1   ::= FunExpr2 Attribute ;

_.                     FunExpr15 ::= FunExpr16 ;
_.                     FunExpr14 ::= FunExpr15 ;
_.                     FunExpr13 ::= FunExpr14 ;
_.                     FunExpr12 ::= FunExpr13 ;
_.                     FunExpr11 ::= FunExpr12 ;
_.                     FunExpr10 ::= FunExpr11 ;
_.                     FunExpr9  ::= FunExpr10 ;
_.                     FunExpr8  ::= FunExpr9 ;
_.                     FunExpr7  ::= FunExpr8 ;
_.                     FunExpr6  ::= FunExpr7 ;
_.                     FunExpr5  ::= FunExpr6 ;
_.                     FunExpr4  ::= FunExpr5 ;
_.                     FunExpr3  ::= FunExpr4 ;
_.                     FunExpr2  ::= FunExpr3 ;
_.                     FunExpr1  ::= FunExpr2 ;

{-
%inline indexop_expr(dot, index, right):
  | simple_expr dot LPAREN index RPAREN right
  | simple_expr dot LBRACE index RBRACE right
  | simple_expr dot LBRACKET index RBRACKET right
;
-}

-- This definition is inlined manually

{-
%inline expr:
  | or_function(fun_expr)
;

%inline or_function(EXPR):
  | EXPR
  | FUNCTION ext_attributes match_cases
;
-}

Function15.     Expr15 ::= "function" Ext [Attribute] [MatchCase] ;
Let15.          Expr15 ::= LetBindingsExt "in" SeqExpr ;
LetOpBinding15. Expr15 ::= LETOP LetopBindings "in" SeqExpr ;
LetModule15.    Expr15 ::= "let" "module" Ext [Attribute] ModuleName ModuleBindingBody "in" SeqExpr ;
LetException15. Expr15 ::= "let" "exception" Ext [Attribute] LetExceptionDeclaration "in" SeqExpr ;
LetOpen15.      Expr15 ::= "let" "open" OverrideFlag Ext [Attribute] ModuleExpr "in" SeqExpr ;
Fun15.          Expr15 ::= "fun" Ext [Attribute] [FunParamAsList] OptionalAtomicTypeAnnotation "->" FunBody ;
Match15.        Expr15 ::= "match" Ext [Attribute] SeqExpr "with" [MatchCase] ;
Try15.          Expr15 ::= "try" Ext [Attribute] SeqExpr "with" [MatchCase] ;
-- While15.        Expr15 ::= "while" Ext [Attribute] SeqExpr "do" SeqExpr "done" ;
-- For15.          Expr15 ::= "for" Ext [Attribute] Pattern "=" SeqExpr DirectionFlag SeqExpr "do" SeqExpr "done" ;
IfElse15.       Expr15 ::= "if" Ext [Attribute] SeqExpr "then" Expr "else" Expr ;
If15.           Expr15 ::= "if" Ext [Attribute] SeqExpr "then" Expr ;
FunExpr15.      Expr15 ::= FunExpr15 ;

Function13.     Expr13 ::= "function" Ext [Attribute] [MatchCase] ;
Let13.          Expr13 ::= LetBindingsExt "in" SeqExpr ;
LetOpBinding13. Expr13 ::= LETOP LetopBindings "in" SeqExpr ;
LetModule13.    Expr13 ::= "let" "module" Ext [Attribute] ModuleName ModuleBindingBody "in" SeqExpr ;
LetException13. Expr13 ::= "let" "exception" Ext [Attribute] LetExceptionDeclaration "in" SeqExpr ;
LetOpen13.      Expr13 ::= "let" "open" OverrideFlag Ext [Attribute] ModuleExpr "in" SeqExpr ;
Fun13.          Expr13 ::= "fun" Ext [Attribute] [FunParamAsList] OptionalAtomicTypeAnnotation "->" FunBody ;
Match13.        Expr13 ::= "match" Ext [Attribute] SeqExpr "with" [MatchCase] ;
Try13.          Expr13 ::= "try" Ext [Attribute] SeqExpr "with" [MatchCase] ;
-- While13.        Expr13 ::= "while" Ext [Attribute] SeqExpr "do" SeqExpr "done" ;
-- For13.          Expr13 ::= "for" Ext [Attribute] Pattern "=" SeqExpr DirectionFlag SeqExpr "do" SeqExpr "done" ;
IfElse13.       Expr13 ::= "if" Ext [Attribute] SeqExpr "then" Expr "else" Expr ;
If13.           Expr13 ::= "if" Ext [Attribute] SeqExpr "then" Expr ;
FunExpr13.      Expr13 ::= FunExpr13 ;

Function12.     Expr12 ::= "function" Ext [Attribute] [MatchCase] ;
Let12.          Expr12 ::= LetBindingsExt "in" SeqExpr ;
LetOpBinding12. Expr12 ::= LETOP LetopBindings "in" SeqExpr ;
LetModule12.    Expr12 ::= "let" "module" Ext [Attribute] ModuleName ModuleBindingBody "in" SeqExpr ;
LetException12. Expr12 ::= "let" "exception" Ext [Attribute] LetExceptionDeclaration "in" SeqExpr ;
LetOpen12.      Expr12 ::= "let" "open" OverrideFlag Ext [Attribute] ModuleExpr "in" SeqExpr ;
Fun12.          Expr12 ::= "fun" Ext [Attribute] [FunParamAsList] OptionalAtomicTypeAnnotation "->" FunBody ;
Match12.        Expr12 ::= "match" Ext [Attribute] SeqExpr "with" [MatchCase] ;
Try12.          Expr12 ::= "try" Ext [Attribute] SeqExpr "with" [MatchCase] ;
-- While12.        Expr12 ::= "while" Ext [Attribute] SeqExpr "do" SeqExpr "done" ;
-- For12.          Expr12 ::= "for" Ext [Attribute] Pattern "=" SeqExpr DirectionFlag SeqExpr "do" SeqExpr "done" ;
IfElse12.       Expr12 ::= "if" Ext [Attribute] SeqExpr "then" Expr "else" Expr ;
If12.           Expr12 ::= "if" Ext [Attribute] SeqExpr "then" Expr ;
FunExpr12.      Expr12 ::= FunExpr12 ;

Function11.     Expr11 ::= "function" Ext [Attribute] [MatchCase] ;
Let11.          Expr11 ::= LetBindingsExt "in" SeqExpr ;
LetOpBinding11. Expr11 ::= LETOP LetopBindings "in" SeqExpr ;
LetModule11.    Expr11 ::= "let" "module" Ext [Attribute] ModuleName ModuleBindingBody "in" SeqExpr ;
LetException11. Expr11 ::= "let" "exception" Ext [Attribute] LetExceptionDeclaration "in" SeqExpr ;
LetOpen11.      Expr11 ::= "let" "open" OverrideFlag Ext [Attribute] ModuleExpr "in" SeqExpr ;
Fun11.          Expr11 ::= "fun" Ext [Attribute] [FunParamAsList] OptionalAtomicTypeAnnotation "->" FunBody ;
Match11.        Expr11 ::= "match" Ext [Attribute] SeqExpr "with" [MatchCase] ;
Try11.          Expr11 ::= "try" Ext [Attribute] SeqExpr "with" [MatchCase] ;
-- While11.        Expr11 ::= "while" Ext [Attribute] SeqExpr "do" SeqExpr "done" ;
-- For11.          Expr11 ::= "for" Ext [Attribute] Pattern "=" SeqExpr DirectionFlag SeqExpr "do" SeqExpr "done" ;
IfElse11.       Expr11 ::= "if" Ext [Attribute] SeqExpr "then" Expr "else" Expr ;
If11.           Expr11 ::= "if" Ext [Attribute] SeqExpr "then" Expr ;
FunExpr11.      Expr11 ::= FunExpr11 ;

Function10.     Expr10 ::= "function" Ext [Attribute] [MatchCase] ;
Let10.          Expr10 ::= LetBindingsExt "in" SeqExpr ;
LetOpBinding10. Expr10 ::= LETOP LetopBindings "in" SeqExpr ;
LetModule10.    Expr10 ::= "let" "module" Ext [Attribute] ModuleName ModuleBindingBody "in" SeqExpr ;
LetException10. Expr10 ::= "let" "exception" Ext [Attribute] LetExceptionDeclaration "in" SeqExpr ;
LetOpen10.      Expr10 ::= "let" "open" OverrideFlag Ext [Attribute] ModuleExpr "in" SeqExpr ;
Fun10.          Expr10 ::= "fun" Ext [Attribute] [FunParamAsList] OptionalAtomicTypeAnnotation "->" FunBody ;
Match10.        Expr10 ::= "match" Ext [Attribute] SeqExpr "with" [MatchCase] ;
Try10.          Expr10 ::= "try" Ext [Attribute] SeqExpr "with" [MatchCase] ;
IfElse10.       Expr10 ::= "if" Ext [Attribute] SeqExpr "then" Expr "else" Expr ;
If10.           Expr10 ::= "if" Ext [Attribute] SeqExpr "then" Expr ;
FunExpr10.      Expr10 ::= FunExpr10 ;

Function9.      Expr9  ::= "function" Ext [Attribute] [MatchCase] ;
Let9.           Expr9  ::= LetBindingsExt "in" SeqExpr ;
LetOpBinding9.  Expr9  ::= LETOP LetopBindings "in" SeqExpr ;
LetModule9.     Expr9  ::= "let" "module" Ext [Attribute] ModuleName ModuleBindingBody "in" SeqExpr ;
LetException9.  Expr9  ::= "let" "exception" Ext [Attribute] LetExceptionDeclaration "in" SeqExpr ;
LetOpen9.       Expr9  ::= "let" "open" OverrideFlag Ext [Attribute] ModuleExpr "in" SeqExpr ;
Fun9.           Expr9  ::= "fun" Ext [Attribute] [FunParamAsList] OptionalAtomicTypeAnnotation "->" FunBody ;
Match9.         Expr9  ::= "match" Ext [Attribute] SeqExpr "with" [MatchCase] ;
Try9.           Expr9  ::= "try" Ext [Attribute] SeqExpr "with" [MatchCase] ;
IfElse9.        Expr9  ::= "if" Ext [Attribute] SeqExpr "then" Expr "else" Expr ;
If9.            Expr9  ::= "if" Ext [Attribute] SeqExpr "then" Expr ;
FunExpr9.       Expr9  ::= FunExpr9 ;

Function7.      Expr7  ::= "function" Ext [Attribute] [MatchCase] ;
Let7.           Expr7  ::= LetBindingsExt "in" SeqExpr ;
LetOpBinding7.  Expr7  ::= LETOP LetopBindings "in" SeqExpr ;
LetModule7.     Expr7  ::= "let" "module" Ext [Attribute] ModuleName ModuleBindingBody "in" SeqExpr ;
LetException7.  Expr7  ::= "let" "exception" Ext [Attribute] LetExceptionDeclaration "in" SeqExpr ;
LetOpen7.       Expr7  ::= "let" "open" OverrideFlag Ext [Attribute] ModuleExpr "in" SeqExpr ;
Fun7.           Expr7  ::= "fun" Ext [Attribute] [FunParamAsList] OptionalAtomicTypeAnnotation "->" FunBody ;
Match7.         Expr7  ::= "match" Ext [Attribute] SeqExpr "with" [MatchCase] ;
Try7.           Expr7  ::= "try" Ext [Attribute] SeqExpr "with" [MatchCase] ;
IfElse7.        Expr7  ::= "if" Ext [Attribute] SeqExpr "then" Expr "else" Expr ;
If7.            Expr7  ::= "if" Ext [Attribute] SeqExpr "then" Expr ;
FunExpr7.       Expr7  ::= FunExpr7 ;

Function6.      Expr6  ::= "function" Ext [Attribute] [MatchCase] ;
Let6.           Expr6  ::= LetBindingsExt "in" SeqExpr ;
LetOpBinding6.  Expr6  ::= LETOP LetopBindings "in" SeqExpr ;
LetModule6.     Expr6  ::= "let" "module" Ext [Attribute] ModuleName ModuleBindingBody "in" SeqExpr ;
LetException6.  Expr6  ::= "let" "exception" Ext [Attribute] LetExceptionDeclaration "in" SeqExpr ;
LetOpen6.       Expr6  ::= "let" "open" OverrideFlag Ext [Attribute] ModuleExpr "in" SeqExpr ;
Fun6.           Expr6  ::= "fun" Ext [Attribute] [FunParamAsList] OptionalAtomicTypeAnnotation "->" FunBody ;
Match6.         Expr6  ::= "match" Ext [Attribute] SeqExpr "with" [MatchCase] ;
Try6.           Expr6  ::= "try" Ext [Attribute] SeqExpr "with" [MatchCase] ;
IfElse6.        Expr6  ::= "if" Ext [Attribute] SeqExpr "then" Expr "else" Expr ;
If6.            Expr6  ::= "if" Ext [Attribute] SeqExpr "then" Expr ;
FunExpr6.       Expr6  ::= FunExpr6 ;

Function.       Expr   ::= "function" Ext [Attribute] [MatchCase] ;
FunExpr1.       Expr   ::= FunExpr1 ;

{-
%inline fun_expr_attrs:
  | LET MODULE ext_attributes module_name module_binding_body IN seq_expr
  | LET EXCEPTION ext_attributes let_exception_declaration IN seq_expr
  | LET OPEN override_flag ext_attributes module_expr IN seq_expr
  /* Cf #5939: we used to accept (fun p when e0 -> e) */
  | FUN ext_attributes fun_params preceded(COLON, atomic_type)?
      MINUSGREATER fun_body
  | TRY ext_attributes seq_expr WITH match_cases
  | IF ext_attributes seq_expr THEN expr ELSE expr
  | IF ext_attributes seq_expr THEN expr
  | WHILE ext_attributes seq_expr do_done_expr
  | FOR ext_attributes pattern EQUAL seq_expr direction_flag seq_expr
    do_done_expr
  | ASSERT ext_attributes simple_expr %prec below_HASH
  | LAZY ext_attributes simple_expr %prec below_HASH
;
-}

-- This definition is inlined manually

{-
%inline do_done_expr:s
  | DO seq_expr DONE
;
-}

-- This definition is inlined manually

{-
%inline expr_:
  | simple_expr nonempty_llist(labeled_simple_expr)
  | expr_comma_list %prec below_COMMA
  | constr_longident simple_expr %prec below_HASH
  | name_tag simple_expr %prec below_HASH
  | fun_expr infix_operator expr
  | subtractive expr %prec prec_unary_minus
  | additive expr %prec prec_unary_plus
;
-}

-- This definition is inlined manually

{-
simple_expr:
  | LPAREN seq_expr RPAREN
  | LPAREN seq_expr type_constraint RPAREN
  | indexop_expr(DOT, seq_expr, { None })
  | indexop_expr(qualified_dotop, expr_semi_list, { None })
  | simple_expr_attrs
  | simple_expr_
;
-}

-- TODO: Improve names

ParenSeqExpr.              SimpleExpr19 ::= "(" SeqExpr ")" ;
TypedSeqExpr.              SimpleExpr19 ::= "(" SeqExpr TypeConstraint ")" ;
ValLongident_.             SimpleExpr19 ::= ValLongident ;
Constant_.                 SimpleExpr19 ::= Constant ;
ConstrName.                SimpleExpr19 ::= ConstrLongident ;
NameTag_.                  SimpleExpr19 ::= NameTag ;
ObjectExpr.                SimpleExpr19 ::= "{<" [ObjectExprField] ">}" ;
EmptyObjectExpr.           SimpleExpr19 ::= "{<" ">}" ;
QualifiedArrayExpr_.       SimpleExpr19 ::= ModLongident "." "(" SeqExpr ")" ;
QualifiedObjectExpr.       SimpleExpr19 ::= ModLongident "." "{" [ObjectExprField] "}" ;
Extension.                 SimpleExpr19 ::= Extension ;
EmptyQualifiedArrayAccess. SimpleExpr19 ::= ModLongident "." "(" ")" ;
RecordExpr_.               SimpleExpr19 ::= "{" RecordExprContent "}" ;
RecordAccess.              SimpleExpr19 ::= ModLongident "." "{" RecordExprContent "}" ;
ArrayExpr_.                SimpleExpr19 ::= "[|" [Expr] "|]" ;
EmptyArrayExpr.            SimpleExpr19 ::= "[|" "|]" ;
ArrayAccesss.              SimpleExpr19 ::= ModLongident "." "[|" [Expr] "|]" ;
ArrayAccesssTodo.          SimpleExpr19 ::= ModLongident "." "[|" "|]" ;
StringExpr_.               SimpleExpr19 ::= "[" [Expr] "]" ;
StringAccess.              SimpleExpr19 ::= ModLongident "." "[" [Expr] "]" ;
StringAccessTodo.          SimpleExpr19 ::= ModLongident "." "[" "]" ;
QualifiedModule.           SimpleExpr19 ::= ModLongident "." "(" "module" Ext [Attribute] ModuleExpr ":" ModuleType ")" ;
BeginEnd.                  SimpleExpr19  ::= "begin" Ext [Attribute] SeqExpr "end" ;
EmptyBeginEnd.             SimpleExpr19  ::= "begin" Ext [Attribute] "end" ;
New.                       SimpleExpr19  ::= "new" Ext [Attribute] ClassLongident ;
Module.                    SimpleExpr19  ::= "(" "module" Ext [Attribute] ModuleExpr ")" ;
TypedModule.               SimpleExpr19  ::= "(" "module" Ext [Attribute] ModuleExpr ":" ModuleType ")" ;
Object.                    SimpleExpr19  ::= "object" Ext [Attribute] ClassStructure "end" ;

-- prefix-symbol precedence 18
PrefixApp.                 SimpleExpr18 ::= PREFIXOP SimpleExpr19 ;
BangApp.                   SimpleExpr18 ::= "!" SimpleExpr19 ;

-- . .( .[ .{ precedence 17
ArrayExpr.                 SimpleExpr17 ::= SimpleExpr17 "." "(" SeqExpr ")" ;
RecordExpr.                SimpleExpr17 ::= SimpleExpr17 "." "{" SeqExpr "}" ;
StringExpr.                SimpleExpr17 ::= SimpleExpr17 "." "[" SeqExpr "]" ;
QualifiedArrayExpr.        SimpleExpr17 ::= SimpleExpr17 QualifiedDotop "(" [Expr] ")" ;
QualifiedRecordExpr.       SimpleExpr17 ::= SimpleExpr17 QualifiedDotop "{" [Expr] "}" ;
QualifiedStringExpr.       SimpleExpr17 ::= SimpleExpr17 QualifiedDotop "[" [Expr] "]" ;
RecordAccessTodo.          SimpleExpr17 ::= SimpleExpr17 "." LabelLongident ;

-- #... precedence 16, associativity left
MethodInvocation.          SimpleExpr16 ::= SimpleExpr17 "#" LIDENT ;
HashOp.                    SimpleExpr16 ::= SimpleExpr17 HASHOP SimpleExpr16 ;

_.                         SimpleExpr18 ::= SimpleExpr19 ;
_.                         SimpleExpr17 ::= SimpleExpr18 ;
_.                         SimpleExpr16 ::= SimpleExpr17 ;
_.                         SimpleExpr   ::= SimpleExpr16 ;

{-
%inline indexop_expr(dot, index, right):
  | simple_expr dot LPAREN index RPAREN right
  | simple_expr dot LBRACE index RBRACE right
  | simple_expr dot LBRACKET index RBRACKET right
;
-}

-- This definition is inlined manually

{-
%inline simple_expr_attrs:
  | BEGIN ext attributes seq_expr END
  | BEGIN ext_attributes END
  | NEW ext_attributes mkrhs(class_longident)
  | LPAREN MODULE ext_attributes module_expr RPAREN
  | LPAREN MODULE ext_attributes module_expr COLON package_type RPAREN
  | OBJECT ext_attributes class_structure END
;
-}

-- This definition is inlined manually

{-
%inline simple_expr_:
  | val_longident
  | constant
  | constr_longident %prec prec_constant_constructor
  | name_tag %prec prec_constant_constructor
  | PREFIXOP simple_expr
  | BANG simple_expr
  | LBRACELESS object_expr_content GREATERRBRACE
  | LBRACELESS GREATERRBRACE
  | simple_expr DOT label_longident
  | open_dot_declaration DOT LPAREN seq_expr RPAREN
  | open_dot_declaration DOT LBRACELESS object_expr_content GREATERRBRACE
  | simple_expr HASH label
  | simple_expr HASHOP simple_expr
  | extension
  | open_dot_declaration DOT LPAREN RPAREN
  | LBRACE record_expr_content RBRACE
  | open_dot_declaration DOT LBRACE record_expr_content RBRACE
  | LBRACKETBAR expr_semi_list BARRBRACKET
  | LBRACKETBAR BARRBRACKET
  | open_dot_declaration DOT LBRACKETBAR expr_semi_list BARRBRACKET
  | open_dot_declaration DOT LBRACKETBAR BARRBRACKET
  | LBRACKET expr_semi_list RBRACKET
  | open_dot_declaration DOT LBRACKET expr_semi_list RBRACKET
  | open_dot_declaration DOT LBRACKET RBRACKET
  | open_dot_declaration DOT LPAREN MODULE ext_attributes module_expr COLON package_type RPAREN
;
-}

-- This definition is inlined manually

{-
labeled_simple_expr:
    simple_expr %prec below_HASH
  | LABEL simple_expr %prec below_HASH
  | TILDE label = LIDENT
  | TILDE LPAREN label = LIDENT ty = type_constraint RPAREN
  | QUESTION label = LIDENT
  | OPTLABEL simple_expr %prec below_HASH
;
-}

separator nonempty LabeledSimpleExpr "" ;

LabeldSimpleExpr16. LabeledSimpleExpr ::= SimpleExpr16 ;
LabeledExpr16.      LabeledSimpleExpr ::= LABEL SimpleExpr16 ;
Label16.            LabeledSimpleExpr ::= "~" LIDENT ;
TypedLabel16.       LabeledSimpleExpr ::= "~" "(" LIDENT TypeConstraint ")" ;
OptLabel16.         LabeledSimpleExpr ::= "?" LIDENT ;
OptLabeledExpr16.   LabeledSimpleExpr ::= OPTLABEL SimpleExpr16 ;

{-
%inline let_ident:
    val_ident
;
-}

-- This definition is inlined manually

{-
let_binding_body_no_punning:
    let_ident strict_binding
  | let_ident type_constraint EQUAL seq_expr
  | let_ident COLON poly(core_type) EQUAL seq_expr
  | let_ident COLON TYPE lident_list DOT core_type EQUAL seq_expr
  | pattern_no_exn EQUAL seq_expr
  | simple_pattern_not_ident COLON core_type EQUAL seq_expr
;
-}

-- TODO: Improve names

StrictBinding.                LetBindingBodyNoPunning ::= ValIdent StrictBinding ;
MonoTypedBinding.             LetBindingBodyNoPunning ::= ValIdent TypeConstraint "=" SeqExpr ;
PolyTypedBinding.             LetBindingBodyNoPunning ::= ValIdent ":" [TypeVar] "." CoreType "=" SeqExpr ;
TypedBindingTodo.             LetBindingBodyNoPunning ::= ValIdent ":" "type" [LIDENT] "." CoreType "=" SeqExpr ;
PatternNoExnBindingNoPunning. LetBindingBodyNoPunning ::= PatternNoExn "=" SeqExpr ;
TypedBinding.                 LetBindingBodyNoPunning ::= SimplePatternNotIdent ":" CoreType "=" SeqExpr ;

{-
let_binding_body:
  | let_binding_body_no_punning
;
-}

LetBindingBodyNoPunning. LetBindingBody ::= LetBindingBodyNoPunning ;

{-
(* The formal parameter EXT can be instantiated with ext or no_ext
   so as to indicate whether an extension is allowed or disallowed. *)
let_bindings(EXT):
    let_binding(EXT)
  | let_bindings(EXT) and_let_binding
;
-}

SingleLetBindingNoExt.   LetBindingsNoExt ::= "let" [Attribute] RecFlag LetBindingBody [PostItemAttribute] ;
MultipleLetBindingNoExt. LetBindingsNoExt ::= LetBindingsNoExt AndLetBinding ;

SingleLetBindingExt.   LetBindingsExt ::= "let" Ext [Attribute] RecFlag LetBindingBody [PostItemAttribute] ;
MultipleLetBindingExt. LetBindingsExt ::= LetBindingsExt AndLetBinding ;

{-
%inline let_binding(EXT):
  LET EXT attributes rec_flag let_binding_body post_item_attributes
;
-}

-- This definition is inlined manually

{-
and_let_binding: AND attributes let_binding_body post_item_attributes
;
-}

AndLetBinding. AndLetBinding ::= "and" [Attribute] LetBindingBody [PostItemAttribute] ;

{-
letop_binding_body:
    let_ident strict_binding
  | val_ident (* Let-punning *)
  | simple_pattern COLON core_type EQUAL seq_expr
  | pattern_no_exn EQUAL seq_expr
;
-}

LetIdent.             LetopBindingBody ::= ValIdent StrictBinding ;
LetopValIdent.        LetopBindingBody ::= ValIdent ;
SimplePatternBinding. LetopBindingBody ::= SimplePattern ":" CoreType "=" SeqExpr ;
PatternNoExnBinding.  LetopBindingBody ::= PatternNoExn "=" SeqExpr ;

{-
letop_bindings:
    letop_binding_body
  | letop_bindings ANDOP letop_binding_body
;
-}

BindingBody.  LetopBindings ::= LetopBindingBody ;
AndOpBinding. LetopBindings ::= LetopBindings ANDOP LetopBindingBody ;

{-
strict_binding:
    EQUAL seq_expr
  | fun_params type_constraint? EQUAL fun_body
;
-}

Binding.   StrictBinding ::= "=" SeqExpr ;
FunParams. StrictBinding ::= [FunParamAsList] OptionalTypeConstraint "=" FunBody ;

{-
fun_body:
  | FUNCTION ext_attributes match_cases
  | fun_seq_expr
;
-}

FunBodyFunction.         FunBody ::= "function" Ext [Attribute] [MatchCase] ;
FunBodyFinalFunExpr.     FunBody ::= FunExpr1 ;
FunBodyFinalFunExprSemi. FunBody ::= FunExpr1 ";" ;
FunBodyMoreFunExprs.     FunBody ::= FunExpr1 ";" SeqExpr ;
FunBodyMoreFunExprsAttr. FunBody ::= FunExpr1 ";" "%" [AttrId] SeqExpr ;

{-
%inline match_cases:
  preceded_or_separated_nonempty_llist(BAR, match_case)
;
-}

_. [MatchCase] ::= "|" [MatchCase] ;

separator nonempty MatchCase "|" ;

{-
match_case:
    pattern MINUSGREATER seq_expr
  | pattern WHEN seq_expr MINUSGREATER seq_expr
  | pattern MINUSGREATER DOT
;
-}

MatchCase.            MatchCase ::= Pattern "->" SeqExpr ;
GuardedMatchCase.     MatchCase ::= Pattern "when" SeqExpr "->" SeqExpr ;
UnreachableMatchCase. MatchCase ::= Pattern "->" "." ;

{-
fun_param_as_list:
  | LPAREN TYPE lident_list RPAREN
      { (* We desugar (type a b c) to (type a) (type b) (type c).
           If we do this desugaring, the loc for each parameter is a ghost.
        *)
  | labeled_simple_pattern
;
-}

FunParam1. FunParamAsList ::= "(" "type" [LIDENT] ")" ;
FunParam2. FunParamAsList ::= LabeledSimplePattern ;

{-
fun_params:
  | nonempty_concat(fun_param_as_list)
;
-}

separator nonempty FunParamAsList "" ;

{-
%inline expr_comma_list:
  separated_nontrivial_llist(COMMA, expr)
;
-}

ExprComma. ExprComma ::= Expr ;

separator nonempty ExprComma "," ;

{-
record_expr_content:
  ioption(terminated(simple_expr, WITH)) separated_or_terminated_nonempty_list(SEMI, record_expr_field)
;
-}

FinalRecordExprField1. RecordExprFields ::= RecordExprField ;
FinalRecordExprField2. RecordExprFields ::= RecordExprField ";" ;
MoreRecordExprFields.  RecordExprFields ::= RecordExprField ";" RecordExprFields ;

RecordExprContent1. RecordExprContent ::= SimpleExpr "with" RecordExprFields ;
RecordExprContent2. RecordExprContent ::= RecordExprFields ;

{-
%inline record_expr_field:
  | label_longident type_constraint? preceded(EQUAL, expr)?
;
-}

NoTypeConstraint. OptionalTypeConstraint ::= ;
ATypeConstraint.  OptionalTypeConstraint ::= TypeConstraint ;

RecordExprField. RecordExprField ::= LabelLongident OptionalTypeConstraint OptionalAssignExpr ;

{-
%inline object_expr_content:
  separated_or_terminated_nonempty_list(SEMI, object_expr_field)
;
-}

(:[]). [ObjectExprField] ::= ObjectExprField ;
(:[]). [ObjectExprField] ::= ObjectExprField ";" ;
(:).   [ObjectExprField] ::= ObjectExprField ";" [ObjectExprField] ;

{-
%inline object_expr_field:
    label preceded(EQUAL, expr)?
;
-}

NoAssign. OptionalAssignExpr ::= ;
AnAssign. OptionalAssignExpr ::= "=" Expr ;

ObjectExprField. ObjectExprField ::= LIDENT OptionalAssignExpr ;

{-
%inline expr_semi_list:
  separated_or_terminated_nonempty_list(SEMI, expr)
;
-}

(:[]). [Expr] ::= Expr ;
(:[]). [Expr] ::= Expr ";" ;
(:).   [Expr] ::= Expr ";" [Expr] ;

{-
type_constraint:
    COLON core_type
  | COLON core_type COLONGREATER core_type
  | COLONGREATER core_type
;
-}

TypeConstraint.         TypeConstraint ::= ":" CoreType ;
TypeConstraintCoercion. TypeConstraint ::= ":" CoreType ":>" CoreType ;
TypeCoercion.           TypeConstraint ::= ":>" CoreType ;

{-
/* Patterns */

(* Whereas [pattern] is an arbitrary pattern, [pattern_no_exn] is a pattern
   that does not begin with the [EXCEPTION] keyword. Thus, [pattern_no_exn]
   is the intersection of the context-free language [pattern] with the
   regular language [^EXCEPTION .*].

   Ideally, we would like to use [pattern] everywhere and check in a later
   phase that EXCEPTION patterns are used only where they are allowed (there
   is code in typing/typecore.ml to this end). Unfortunately, in the
   definition of [let_binding_body], we cannot allow [pattern]. That would
   create a shift/reduce conflict: upon seeing LET EXCEPTION ..., the parser
   wouldn't know whether this is the beginning of a LET EXCEPTION construct or
   the beginning of a LET construct whose pattern happens to begin with
   EXCEPTION. The conflict is avoided there by using [pattern_no_exn] in the
   definition of [let_binding_body].

   In order to avoid duplication between the definitions of [pattern] and
   [pattern_no_exn], we create a parameterized definition [pattern_(self)]
   and instantiate it twice. *)

pattern:
    pattern_(pattern)
  | EXCEPTION ext_attributes pattern %prec prec_constr_appl
;
-}

ConsPattern.          Pattern ::= Pattern "::" Pattern ;
PatternWithAttribute. Pattern ::= Pattern Attribute ;
PatternGen.           Pattern ::= PatternGen ;
AsPattern.            Pattern ::= Pattern "as" ValIdent ;
TuplePattern.         Pattern ::= PatternCommaListPattern ;
OrPattern.            Pattern ::= Pattern "|" Pattern ;
ExceptionPattern.     Pattern ::= "exception" Ext [Attribute] Pattern ;

{-
pattern_no_exn:
    pattern_(pattern_no_exn)
;
-}

ConsPatternNoExn.          PatternNoExn ::= PatternNoExn "::" Pattern ;
PatternWithAttributeNoExn. PatternNoExn ::= PatternNoExn Attribute ;
PatternGenNoExn.           PatternNoExn ::= PatternGen ;
AsPatternNoExn.            PatternNoExn ::= PatternNoExn "as" ValIdent ;
TuplePatternNoExn.         PatternNoExn ::= PatternCommaListPatternNoExn ;
OrPatternNoExn.            PatternNoExn ::= PatternNoExn "|" Pattern ;

{-
%inline pattern_(self):
  | self COLONCOLON pattern
  | self attribute
  | pattern_gen
  | self AS val_ident
  | pattern_comma_list(self) %prec below_COMMA
  | self BAR pattern
;
-}

-- This definition is inlined manually

{-
pattern_gen:
    simple_pattern
  | constr_longident pattern %prec prec_constr_appl
  | constr_longident LPAREN TYPE lident_list RPAREN simple_pattern
  | name_tag pattern %prec prec_constr_appl
  | LAZY ext_attributes simple_pattern
;

%inline lident_list:
  LIDENT+
;
-}

separator nonempty LIDENT "" ;

SimplePatternGen.  PatternGen ::= SimplePattern ;
ConstrPattern.     PatternGen ::= ConstrLongident Pattern ;
ConstrTypePattern. PatternGen ::= ConstrLongident "(" "type" [LIDENT] ")" SimplePattern ;
TagPatternGen.     PatternGen ::= NameTag Pattern ;
LazyPattern.       PatternGen ::= "lazy" Ext [Attribute] SimplePattern ;

{-
simple_pattern:
    val_ident %prec below_EQUAL
  | simple_pattern_not_ident
;
-}

ValIdent.              SimplePattern ::= ValIdent ;
SimplePatternNotIdent. SimplePattern ::= SimplePatternNotIdent ;

{-
simple_pattern_not_ident:
  | LPAREN pattern RPAREN
  | simple_delimited_pattern
  | LPAREN MODULE ext_attributes module_name RPAREN
  | LPAREN MODULE ext_attributes module_name COLON package_type RPAREN
  | simple_pattern_not_ident_
;
-}

ParenPattern.           SimplePatternNotIdent ::= "(" Pattern ")" ;
SimpleDelimitedPattern. SimplePatternNotIdent ::= SimpleDelimitedPattern ;
ParenModule.            SimplePatternNotIdent ::= "(" "module" Ext [Attribute] ModuleName ")" ;
TypedParenModule.       SimplePatternNotIdent ::= "(" "module" Ext [Attribute] ModuleName ":" PackageType ")" ;
SimplePatternNotIdent_. SimplePatternNotIdent ::= SimplePatternNotIdent_ ;

{-
%inline simple_pattern_not_ident_:
  | UNDERSCORE
  | signed_constant
  | signed_constant DOTDOT signed_constant
  | constr_longident
  | name_tag
  | HASH type_longident
  | mod_longident DOT simple_delimited_pattern
  | mod_longident DOT LBRACKET RBRACKET
  | mod_longident DOT LPAREN RPAREN
  | mod_longident DOT LPAREN pattern RPAREN
  | LPAREN pattern COLON core_type RPAREN
  | LPAREN MODULE ext_attributes module_name COLON package_type
  | extension
;
-}

UnderscorePattern.  SimplePatternNotIdent_ ::= "_" ;
ConstantPattern.    SimplePatternNotIdent_ ::= SignedConstant ;
RangePattern.       SimplePatternNotIdent_ ::= SignedConstant ".." SignedConstant ;
ConstrNamePattern.  SimplePatternNotIdent_ ::= ConstrLongident ;
TagPattern.         SimplePatternNotIdent_ ::= NameTag ;
TypeConstrPattern.  SimplePatternNotIdent_ ::= "#" TypeLongident ;
DotPattern.         SimplePatternNotIdent_ ::= ModLongident "." SimpleDelimitedPattern ;
EmptyStringPattern. SimplePatternNotIdent_ ::= ModLongident "." "[" "]" ;
EmptyArrayPattern_. SimplePatternNotIdent_ ::= ModLongident "." "(" ")" ;
ArrayPattern_.      SimplePatternNotIdent_ ::= ModLongident "." "(" Pattern ")" ;
TypedPattern.       SimplePatternNotIdent_ ::= "(" Pattern ":" CoreType ")" ;
ModulePattern.      SimplePatternNotIdent_ ::= "(" "module" Ext [Attribute] ModuleName ":" PackageType ")" ;
ExtensionPattern.   SimplePatternNotIdent_ ::= Extension ;

{-
simple_delimited_pattern:
    LBRACE record_pat_content RBRACE
  | LBRACKET pattern_semi_list RBRACKET
  | LBRACKETBAR pattern_semi_list BARRBRACKET
  | LBRACKETBAR BARRBRACKET
-}

RecordPattern.     SimpleDelimitedPattern ::= "{" RecordPatContent "}" ;
ListPattern.       SimpleDelimitedPattern ::= "[" [PatternSemi] "]" ;
ArrayPattern.      SimpleDelimitedPattern ::= "[|" [PatternSemi] "|]" ;
EmptyArrayPattern. SimpleDelimitedPattern ::= "[|" "|]" ;

{-
pattern_comma_list(self):
    pattern_comma_list(self) COMMA pattern
  | self COMMA pattern
;
-}

MorePattern. PatternCommaListPattern ::= PatternCommaListPattern "," Pattern ;
TwoPattern.  PatternCommaListPattern ::= Pattern "," Pattern ;

MorePatternNoExn. PatternCommaListPatternNoExn ::= PatternCommaListPatternNoExn "," Pattern ;
TwoPatternNoExn.  PatternCommaListPatternNoExn ::= PatternNoExn "," Pattern ;

{-
%inline pattern_semi_list:
  separated_or_terminated_nonempty_list(SEMI, pattern)
;
-}

PatternSemi. PatternSemi ::= Pattern ;

(:[]). [PatternSemi] ::= PatternSemi ;
(:[]). [PatternSemi] ::= PatternSemi ";" ;
(:).   [PatternSemi] ::= PatternSemi ";" [PatternSemi] ;

{-
(* A label-pattern list is a nonempty list of label-pattern pairs, optionally
   followed with an UNDERSCORE, separated-or-terminated with semicolons. *)
%inline record_pat_content:
  listx(SEMI, record_pat_field, UNDERSCORE)
;

listx(delimiter, X, Y):
| X ioption(delimiter)
| X delimiter Y delimiter?
| X delimiter listx(delimiter, X, Y)
-}

NoSemi. OptionalSemi ::= ;
ASemi.  OptionalSemi ::= ";" ;

FinalRecordPattern.      RecordPatContent ::= RecordPatField OptionalSemi ;
UnderscoreRecordPattern. RecordPatContent ::= RecordPatField ";" "_" OptionalSemi ;
MoreRecordPatterns.      RecordPatContent ::= RecordPatField ";" RecordPatContent ;

{-
%inline record_pat_field:
  label_longident preceded(COLON, core_type)? preceded(EQUAL, pattern)?
;
-}

NoCoreType. OptionalCoreType ::= ;
ACoreType.  OptionalCoreType ::= ":" CoreType ;

NoAssignPattern. OptionalAssignPattern ::= ;
AnAssignPattern. OptionalAssignPattern ::= "=" Pattern ;

RecordPatField. RecordPatField ::= LabelLongident OptionalCoreType OptionalAssignPattern ;

{-
/* Value descriptions */

value_description:
  VAL ext attributes val_ident COLON possibly_poly(core_type) post_item_attributes
;
-}

ValueDescription. ValueDescription ::= "val" Ext [Attribute] ValIdent ":" PolyType [PostItemAttribute] ;

{-
/* Primitive declarations */

primitive_declaration:
  EXTERNAL ext attributes val_ident COLON possibly_poly(core_type) EQUAL raw_string+ post_item_attributes
;
-}

separator nonempty STRING "" ;

PrmitiveDeclaration. PrimitiveDeclaration ::= "external" Ext [Attribute] ValIdent ":" PolyType "=" [STRING] [PostItemAttribute] ;

{-
(* Type declarations and type substitutions. *)

(* Type declarations [type t = u] and type substitutions [type t := u] are very
   similar, so we view them as instances of [generic_type_declarations]. In the
   case of a type declaration, the use of [nonrec_flag] means that [NONREC] may
   be absent or present, whereas in the case of a type substitution, the use of
   [no_nonrec_flag] means that [NONREC] must be absent. The use of [type_kind]
   versus [type_subst_kind] means that in the first case, we expect an [EQUAL]
   sign, whereas in the second case, we expect [COLONEQUAL]. *)

%inline type_declarations:
  generic_type_declarations(nonrec_flag, type_kind)
;
-}

-- This definition is inlined manually

{-
%inline generic_and_type_declaration(kind):
  AND attributes type_parameters LIDENT kind constraints post_item_attributes
;
-}

AndTypeDeclaration. AndTypeDeclaration ::= "and" [Attribute] TypeParameters LIDENT TypeKind [Constraint] [PostItemAttribute] ;

separator AndTypeDeclaration "" ;

{-
%inline type_subst_declarations:
  generic_type_declarations(no_nonrec_flag, type_subst_kind)
;
-}

TypeSubstDeclarations. TypeSubstDeclarations ::= TypeSubstDeclaration [AndTypeSubstDeclaration] ;

{-
%inline generic_and_type_declaration(kind):
  AND attributes type_parameters LIDENT kind constraints post_item_attributes
;
-}

AndTypeSubstDeclaration. AndTypeSubstDeclaration ::= "and" [Attribute] TypeParameters LIDENT TypeSubstKind [Constraint] [PostItemAttribute] ;

separator AndTypeSubstDeclaration "and" ;

{-
(* A set of type declarations or substitutions begins with a
   [generic_type_declaration] and continues with a possibly empty list of
   [generic_and_type_declaration]s. *)

%inline generic_type_declarations(flag, kind):
  xlist(
    generic_type_declaration(flag, kind),
    generic_and_type_declaration(kind)
  )
;

(* [generic_type_declaration] and [generic_and_type_declaration] look similar,
   but are in reality different enough that it is difficult to share anything
   between them. *)

generic_type_declaration(flag, kind):
  TYPE ext attributes flag type_parameters LIDENT kind constraints post_item_attributes
;
-}

NonrecTypeDeclaration. TypeDeclaration ::= "type" Ext [Attribute] "nonrec" TypeParameters LIDENT TypeKind [Constraint] [PostItemAttribute] ;
TypeDeclaration.       TypeDeclaration ::= "type" Ext [Attribute] TypeParameters LIDENT TypeKind [Constraint] [PostItemAttribute] ;

TypeSubstDeclaration. TypeSubstDeclaration ::= "type" Ext [Attribute] TypeParameters LIDENT TypeSubstKind [Constraint] [PostItemAttribute] ;


{-
%inline constraints:
  llist(preceded(CONSTRAINT, constrain))
;
-}

Constraint. Constraint ::= "constraint" Constrain ;

separator Constraint "" ;

{-
(* Lots of %inline expansion are required for [nonempty_type_kind] to be
   LR(1). At the cost of some manual expansion, it would be possible to give a
   definition that leads to a smaller grammar (after expansion) and therefore
   a smaller automaton. *)
nonempty_type_kind:
  | inline_private_flag core_type
  | type_synonym inline_private_flag constructor_declarations
  | type_synonym inline_private_flag DOTDOT
  | type_synonym inline_private_flag LBRACE label_declarations RBRACE
;
-}

AbstractType.                  NonemptyTypeKind ::= CoreType ;
VariantType.                   NonemptyTypeKind ::= ConstructorDeclarations ;
OpenType.                      NonemptyTypeKind ::= ".." ;
RecordType.                    NonemptyTypeKind ::= "{" LabelDeclarations "}" ;
PrivateAbstractType.           NonemptyTypeKind ::= "private" CoreType ;
PrivateVariantType.            NonemptyTypeKind ::= "private" ConstructorDeclarations ;
PrivateOpenType.               NonemptyTypeKind ::= "private" ".." ;
PrivateRecordType.             NonemptyTypeKind ::= "private" "{" LabelDeclarations "}" ;
TypeSynonymVariantType.        NonemptyTypeKind ::= CoreType "=" ConstructorDeclarations ;
TypeSynonymPrivateVariantType. NonemptyTypeKind ::= CoreType "=" "private" ConstructorDeclarations ;
TypeSynonymOpenType.           NonemptyTypeKind ::= CoreType "=" ".." ;
TypeSynonymPrivateOpenType.    NonemptyTypeKind ::= CoreType "=" "private" ".." ;
TypeSynonymRecordType.         NonemptyTypeKind ::= CoreType "=" "{" LabelDeclarations "}" ;
TypeSynonymPrivateRecordType.  NonemptyTypeKind ::= CoreType "=" "private" "{" LabelDeclarations "}" ;

{-
%inline type_synonym:
  ioption(terminated(core_type, EQUAL))
;
-}

-- This definition is inlined manually

{-
type_kind:
    /*empty*/
  | EQUAL nonempty_type_kind
;
-}

NoTypeKind. TypeKind ::= ;
TypeKind.   TypeKind ::= "=" NonemptyTypeKind ;

{-
%inline type_subst_kind:
    COLONEQUAL nonempty_type_kind
;
-}

TypeSubstKind. TypeSubstKind ::= ":=" NonemptyTypeKind ;

{-
type_parameters:
    /* empty */
  | type_parameter
  | LPAREN separated_nonempty_llist(COMMA, type_parameter) RPAREN
;
-}

NoTypeParameters.    TypeParameters ::= ;
SingleTypeParameter. TypeParameters ::= TypeParameter ;
TypeParameters.      TypeParameters ::= "(" [TypeParameter] ")" ;

separator nonempty TypeParameter "," ;

{-
type_parameter:
    type_variance type_variable
;
-}

TypeParameter. TypeParameter ::= TypeVariance TypeVariable ;

{-
type_variable:
    QUOTE ident
  | UNDERSCORE
;
-}

TypeVariable. TypeVariable ::= "'" OCamlIdent ;
Underscore.   TypeVariable ::= "_" ;

{-
type_variance:
    /* empty */                             { NoVariance, NoInjectivity }
  | PLUS                                    { Covariant, NoInjectivity }
  | MINUS                                   { Contravariant, NoInjectivity }
  | BANG                                    { NoVariance, Injective }
  | PLUS BANG | BANG PLUS                   { Covariant, Injective }
  | MINUS BANG | BANG MINUS                 { Contravariant, Injective }
  | INFIXOP2
  | PREFIXOP
;
-}

NoVarianceNoInjectivity.    TypeVariance ::= ;
CovariantNoInjectivity.     TypeVariance ::= "+" ;
ContravariantNoInjectivity. TypeVariance ::= "-" ;
NoVarianceInjective.        TypeVariance ::= "!" ;
CovariantInjective.         TypeVariance ::= "+!" ;
InjectiveCovariant.         TypeVariance ::= "!+" ;
ContravariantInjective.     TypeVariance ::= "-!" ;
InjectiveContravariant.     TypeVariance ::= "!-" ;
InfixOpVariance.            TypeVariance ::= PLUSMINUSOP ;
PrefixOpVariance.           TypeVariance ::= PREFIXOP ;

{-
(* A sequence of constructor declarations is either a single BAR, which
   means that the list is empty, or a nonempty BAR-separated list of
   declarations, with an optional leading BAR. *)
constructor_declarations:
  | BAR
  | bar_llist(constructor_declaration)
;

reversed_bar_llist(X):
    (* An [X] without a leading BAR. *)
    X(epsilon)
  | (* An [X] with a leading BAR. *)
    X(BAR)
  | (* An initial list, followed with a BAR and an [X]. *)
    reversed_bar_llist(X) X(BAR)

%inline bar_llist(X):
  reversed_bar_llist(X)
-}

separator nonempty ConstructorDeclaration "|" ;

EmptyConstructorDeclarations. ConstructorDeclarations ::= "|" ;
BarConstructorDeclarations.   ConstructorDeclarations ::= "|" [ConstructorDeclaration] ;
ConstructorDeclarations.      ConstructorDeclarations ::= [ConstructorDeclaration] ;

{-
(* A constructor declaration begins with an opening symbol, which can
   be either epsilon or BAR. Note that this opening symbol is included
   in the footprint $sloc. *)
(* Because [constructor_declaration] and [extension_constructor_declaration]
   are identical except for their semantic actions, we introduce the symbol
   [generic_constructor_declaration], whose semantic action is neutral -- it
   merely returns a tuple. *)
generic_constructor_declaration(opening):
  opening constr_ident generalized_constructor_arguments attributes
;
%inline constructor_declaration(opening):
  generic_constructor_declaration(opening)
;
-}

ConstructorDeclaration. ConstructorDeclaration ::= ConstrIdent GeneralizedConstructorArguments [Attribute] ;

{-
str_exception_declaration:
  sig_exception_declaration
| EXCEPTION ext attributes constr_ident EQUAL constr_longident attributes post_item_attributes
;
-}

SigStrExceptionDeclaration. StrExceptionDeclaration ::= SigExceptionDeclaration ;
Exception.                  StrExceptionDeclaration ::= "exception" Ext [Attribute] ConstrIdent "=" ConstrLongident [Attribute] [PostItemAttribute] ;

{-
sig_exception_declaration:
  EXCEPTION ext attributes constr_ident generalized_constructor_arguments attributes post_item_attributes
;
-}

SigExceptionDeclaration. SigExceptionDeclaration ::= "exception" Ext [Attribute] ConstrIdent GeneralizedConstructorArguments [Attribute] [PostItemAttribute] ;

{-
%inline let_exception_declaration:
    constr_ident generalized_constructor_arguments attributes
;
-}

LetExceptionDeclaration. LetExceptionDeclaration ::= ConstrIdent GeneralizedConstructorArguments [Attribute] ;

{-
generalized_constructor_arguments:
    /*empty*/
  | OF constructor_arguments
  | COLON constructor_arguments MINUSGREATER atomic_type %prec below_HASH
  | COLON typevar_list DOT constructor_arguments MINUSGREATER atomic_type
     %prec below_HASH
  | COLON atomic_type %prec below_HASH
  | COLON typevar_list DOT atomic_type %prec below_HASH
;
-}

NoGeneralizedConstructorArguments. GeneralizedConstructorArguments ::= ;
GeneralizedConstructorArguments1.  GeneralizedConstructorArguments ::= "of" ConstructorArguments ;
GeneralizedConstructorArguments2.  GeneralizedConstructorArguments ::= ":" ConstructorArguments "->" AtomicType ;
GeneralizedConstructorArguments3.  GeneralizedConstructorArguments ::= ":" [TypeVar] "." ConstructorArguments "->" AtomicType ;
GeneralizedConstructorArguments4.  GeneralizedConstructorArguments ::= ":" AtomicType ;
GeneralizedConstructorArguments5.  GeneralizedConstructorArguments ::= ":" [TypeVar] "." AtomicType ;

{-
constructor_arguments:
  | inline_separated_nonempty_llist(STAR, atomic_type)
    %prec below_HASH
  | LBRACE label_declarations RBRACE
;
-}

Arg1. ConstructorArguments ::= [AtomicType] ;
Arg2. ConstructorArguments ::= "{" LabelDeclarations "}" ;

{-
label_declarations:
    label_declaration
  | label_declaration_semi
  | label_declaration_semi label_declarations
;
-}

FinalLabelDeclaration.     LabelDeclarations ::= LabelDeclaration ;
FinalLabelDeclarationSemi. LabelDeclarations ::= LabelDeclarationSemi ;
MoreLabelDeclarations.     LabelDeclarations ::= LabelDeclarationSemi LabelDeclarations ;

{-
label_declaration:
    mutable_flag label COLON poly_type_no_attr attributes
;
-}

LabelDeclarationMonoType. LabelDeclaration ::= MutableFlag LIDENT ":" AliasType [Attribute] ;
LabelDeclarationPolyType. LabelDeclaration ::= MutableFlag LIDENT ":" [TypeVar] "." AliasType [Attribute] ;

{-
label_declaration_semi:
    mutable_flag label COLON poly_type_no_attr attributes SEMI attributes
;
-}

LabelDeclarationSemiMonoType. LabelDeclarationSemi ::= MutableFlag LIDENT ":" AliasType [Attribute] ";" [Attribute] ;
LabelDeclarationSemiPolyType. LabelDeclarationSemi ::= MutableFlag LIDENT ":" [TypeVar] "." AliasType [Attribute] ";" [Attribute] ;

{-
/* Type Extensions */

%inline str_type_extension:
  type_extension(extension_constructor)
;

%inline type_extension(declaration):
  TYPE ext attributes no_nonrec_flag type_parameters type_longident PLUSEQ private_flag bar_llist(declaration) post_item_attributes
;
-}

StrTypeExtension. StrTypeExtension ::= "type" Ext [Attribute] TypeParameters TypeLongident "+=" PrivateFlag BarLlistExtensionConstructor [PostItemAttribute] ;

NoExtensionConstructors.  BarLlistExtensionConstructor ::= "|" ;
BarExtensionConstructors. BarLlistExtensionConstructor ::= "|" [ExtensionConstructor] ;
ExtensionConstructors.    BarLlistExtensionConstructor ::= [ExtensionConstructor] ;

separator ExtensionConstructor "|" ;

{-
%inline sig_type_extension:
  type_extension(extension_constructor_declaration)
;

%inline type_extension(declaration):
  TYPE ext attributes no_nonrec_flag type_parameters type_longident PLUSEQ private_flag bar_llist(declaration) post_item_attributes
;
-}

SigTypeExtension. SigTypeExtension ::= "type" Ext [Attribute] TypeParameters TypeLongident "+=" PrivateFlag BarLlistExtensionConstructorDeclaration [PostItemAttribute] ;

NoConstructor. BarLlistExtensionConstructorDeclaration ::= "|" ;
Constructor.   BarLlistExtensionConstructorDeclaration ::= "|" [ExtensionConstructorDeclaration] ;
Constructor.   BarLlistExtensionConstructorDeclaration ::= [ExtensionConstructorDeclaration] ;

separator ExtensionConstructorDeclaration "|" ;

{-
%inline extension_constructor(opening):
    extension_constructor_declaration(opening)
  | extension_constructor_rebind(opening)
;
-}

Declaration. ExtensionConstructor ::= ExtensionConstructorDeclaration ;
Rebind.      ExtensionConstructor ::= ExtensionConstructorRebind ;

{-
%inline extension_constructor_declaration(opening):
  generic_constructor_declaration(opening)
;

generic_constructor_declaration(opening):
  opening constr_ident generalized_constructor_arguments attributes
;
-}

ExtensionConstructorDeclaration. ExtensionConstructorDeclaration ::= ConstrIdent GeneralizedConstructorArguments [Attribute] ;

{-
extension_constructor_rebind(opening):
  opening constr_ident EQUAL constr_longident attributes
;
-}

ExtensionConstructorRebind. ExtensionConstructorRebind ::= ConstrIdent "=" ConstrLongident [Attribute] ;

{-
/* "with" constraints (additional type equations over signature components) */

with_constraint:
    TYPE type_parameters label_longident with_type_binder core_type_no_attr constraints
  | TYPE type_parameters label_longident COLONEQUAL core_type_no_attr
  | MODULE mod_longident EQUAL mod_ext_longident
  | MODULE mod_longident COLONEQUAL mod_ext_longident
  | MODULE TYPE mty_longident EQUAL module_type
  | MODULE TYPE mty_longident COLONEQUAL module_type
;
-}

-- TODO: Improve names

WithConstraint1. WithConstraint ::= "type" TypeParameters LabelLongident WithTypeBinder AliasType [Constraint] ;
WithConstraint2. WithConstraint ::= "type" TypeParameters LabelLongident ":=" AliasType ;
WithConstraint3. WithConstraint ::= "module" ModLongident "=" ModExtLongident ;
WithConstraint4. WithConstraint ::= "module" ModLongident ":=" ModExtLongident ;
WithConstraint5. WithConstraint ::= "module" "type" MtyLongident "=" ModuleType ;
WithConstraint6. WithConstraint ::= "module" "type" MtyLongident ":=" ModuleType ;

{-
with_type_binder:
    EQUAL
  | EQUAL PRIVATE
;
-}

WithTypeBinderEqual.        WithTypeBinder ::= "=" ;
WithTypeBinderEqualPrivate. WithTypeBinder ::= "= private" ;

{-
/* Polymorphic types */

%inline typevar:
  QUOTE ident
;-}

TypeVarIdent. TypeVar ::= "'" OCamlIdent ;

{-
%inline typevar_list:
  nonempty_llist(typevar)
;
-}

separator nonempty TypeVar "" ;

{-
%inline poly(X):x
  typevar_list DOT X
;
possibly_poly(X):
  X
| poly(X)
;
-}

-- We use poly_type instead of possibly_poly(core_type)

{-
%inline poly_type:
  possibly_poly(core_type)
;
-}

MonoCoreType. PolyType ::= CoreType ;
PolyCoreType. PolyType ::= [TypeVar] "." CoreType ;

{-
%inline poly_type_no_attr:
  possibly_poly(core_type_no_attr)
;
-}

-- This definition is inlined manually

{-

(* -------------------------------------------------------------------------- *)

(* Core language types. *)

(* A core type (core_type) is a core type without attributes (core_type_no_attr)
   followed with a list of attributes. *)
core_type:
    core_type_no_attr
  | core_type attribute
;
-}

CoreTypeWithoutAttribute. CoreType ::= AliasType ;
CoreTypeWithAttribute.    CoreType ::= CoreType Attribute ;

separator nonempty CoreType "," ;

{-
(* A core type without attributes is currently defined as an alias type, but
   this could change in the future if new forms of types are introduced. From
   the outside, one should use core_type_no_attr. *)
%inline core_type_no_attr:
  alias_type
;
-}

-- This definition is inlined manually

{-

(* Alias types include:
   - function types (see below);
   - proper alias types:                  'a -> int as 'a
 *)
alias_type:
    function_type
  | alias_type AS typevar
;
-}

FunctionType. AliasType ::= FunctionType ;
AliasType.    AliasType ::= AliasType "as" TypeVar ;

{-
(* Function types include:
   - tuple types (see below);
   - proper function types:               int -> int
                                          foo: int -> int
                                          ?foo: int -> int
 *)
function_type:
  | tuple_type %prec MINUSGREATER
  | arg_label tuple_type MINUSGREATER function_type
;
-}

TupleType.                FunctionType ::= TupleType ;
FunTypeWithOptLabel.      FunctionType ::= OPTLABEL TupleType "->" FunctionType ;
FunTypeWithOptionalLabel. FunctionType ::= "?" LIDENT ":" TupleType "->" FunctionType ;
FunTypeWithtLabel.        FunctionType ::= LIDENT ":" TupleType "->" FunctionType ;
FunTypeWithoutLabel.      FunctionType ::= TupleType "->" FunctionType ;

{-
(* Tuple types include:
   - atomic types (see below);
   - proper tuple types:                  int * int * int list
   A proper tuple type is a star-separated list of at least two atomic types.
 *)
-}

{-
%inline arg_label:
  | optlabel
  | LIDENT COLON
  | /* empty */
;
-}

-- This definition is inlined manually

{-
(* Tuple types include:
   - atomic types (see below);
   - proper tuple types:                  int * int * int list
   A proper tuple type is a star-separated list of at least two atomic types.
 *)
tuple_type:
  | atomic_type %prec below_HASH
  | separated_nontrivial_llist(STAR, atomic_type)
;
-}

AtomicType.  TupleType ::= AtomicType ;
AtomicTypes. TupleType ::= AtomicType "*" [AtomicType] ;

separator nonempty AtomicType "*";

{-
(* Atomic types are the most basic level in the syntax of types.
   Atomic types include:
   - types between parentheses:           (int -> int)
   - first-class module types:            (module S)
   - type variables:                      'a
   - applications of type constructors:   int, int list, int option list
   - variant types:                       [`A]
 *)

(*
  Delimited types:
    - parenthesised type          (type)
    - first-class module types    (module S)
    - object types                < x: t; ... >
    - variant types               [ `A ]
    - extension                   [%foo ...]

  We support local opens on the following classes of types:
    - parenthesised
    - first-class module types
    - variant types

  Object types are not support for local opens due to a potential
  conflict with MetaOCaml syntax:
    M.< x: t, y: t >
  and quoted expressions:
    .< e >.

  Extension types are not support for local opens merely as a precaution.
*)
delimited_type_supporting_local_open:
  | LPAREN core_type RPAREN
  | LPAREN MODULE ext_attributes package_type RPAREN
  | LBRACKET tag_field RBRACKET
  | LBRACKET BAR row_field_list RBRACKET
  | LBRACKET row_field BAR row_field_list RBRACKET
  | LBRACKETGREATER BAR? row_field_list RBRACKET
  | LBRACKETGREATER RBRACKET
  | LBRACKETLESS BAR? row_field_list RBRACKET
  | LBRACKETLESS BAR? row_field_list GREATER name_tag_list RBRACKET
;
-}

NoBar. OptionalBar ::= ;
ABar.  OptionalBar ::= "|" ;

-- TODO: Improve names

LocalOpen1. DelimitedTypeSupportingLocalOpen ::= "(" CoreType ")" ;
LocalOpen2. DelimitedTypeSupportingLocalOpen ::= "(" "module" Ext [Attribute] PackageType ")" ;
LocalOpen3. DelimitedTypeSupportingLocalOpen ::= "[" TagField "]" ;
LocalOpen4. DelimitedTypeSupportingLocalOpen ::= "[" "|" [RowField] "]" ;
LocalOpen5. DelimitedTypeSupportingLocalOpen ::= "[" RowField "|" [RowField] "]" ;
LocalOpen6. DelimitedTypeSupportingLocalOpen ::= "[>" OptionalBar [RowField] "]" ;
LocalOpen7. DelimitedTypeSupportingLocalOpen ::= "[>" "]" ;
LocalOpen8. DelimitedTypeSupportingLocalOpen ::= "[<" OptionalBar [RowField] "]" ;
LocalOpen9. DelimitedTypeSupportingLocalOpen ::= "[<" OptionalBar [RowField] ">" [NameTag] "]" ;

{-
object_type:
  | LESS meth_list GREATER
  | LESS GREATER
;
-}

MethList. ObjectType ::= "<" MethList ">" ;
Empty.    ObjectType ::= "<" ">" ;

{-
delimited_type:
  | object_type
  | extension
  | delimited_type_supporting_local_open
;
-}

ObjectType.                       DelimitedType ::= ObjectType ;
DelimitedTypeExtension.           DelimitedType ::= Extension ;
DelimitedTypeSupportingLocalOpen. DelimitedType ::= DelimitedTypeSupportingLocalOpen ;

{-
atomic_type:
  | delimited_type
  | ( /* begin mktyp group */
    actual_type_parameters type_longident
  | actual_type_parameters HASH clty_longident
  | mod_ext_longident DOT delimited_type_supporting_local_open
  | QUOTE ident
  | UNDERSCORE
;
-}

DelimitedType.           AtomicType ::= DelimitedType ;
TypeConstr.              AtomicType ::= TypeLongident ;
SimpleTypeApp.           AtomicType ::= AtomicType TypeLongident ;
ComplexTypeApp.          AtomicType ::= "(" CoreType "," [CoreType] ")" TypeLongident ;
ClassTypeConstr.         AtomicType ::= "#" CltyLongident ;
SimpleSubTypeApp.        AtomicType ::= AtomicType "#" CltyLongident ;
ComplexSubTypeApp.       AtomicType ::= "(" CoreType "," [CoreType] ")" "#" CltyLongident ;
QualifiedDelimitedType.  AtomicType ::= ModExtLongident "." DelimitedTypeSupportingLocalOpen ;
TypeVar.                 AtomicType ::= "'" OCamlIdent ;
UnderscoreType.          AtomicType ::= "_" ;

{-
(* This is the syntax of the actual type parameters in an application of
   a type constructor, such as int, int list, or (int, bool) Hashtbl.t.
   We allow one of the following:
   - zero parameters;
   - one parameter:
     an atomic type;
     among other things, this can be an arbitrary type between parentheses;
   - two or more parameters:
     arbitrary types, between parentheses, separated with commas.
 *)
%inline actual_type_parameters:
  | /* empty */
  | atomic_type
  | LPAREN separated_nontrivial_llist(COMMA, core_type) RPAREN
;
-}

-- This definition is inlined manually

{-
%inline package_type: module_type;
-}

PackageType. PackageType ::= ModuleType ;

{-
%inline row_field_list:
  separated_nonempty_llist(BAR, row_field)
;
-}

separator nonempty RowField "|" ;

{-
row_field:
    tag_field
  | core_type
;
-}

TagField. RowField ::= TagField ;
CoreType. RowField ::= CoreType ;

{-
tag_field:
    name_tag OF opt_ampersand amper_type_list attributes
  | name_tag attributes
;
-}

Of.  TagField ::= NameTag "of" OptAmpersand [AliasType] [Attribute] ;
Tag. TagField ::= NameTag [Attribute] ;

{-
opt_ampersand:
    AMPERSAND                                   { true }
  | /* empty */                                 { false }
;
-}

Ampersand.   OptAmpersand ::= "&" ;
NoAmpersand. OptAmpersand ::= ;

{-
%inline amper_type_list:
  separated_nonempty_llist(AMPERSAND, core_type_no_attr)
;
-}

separator nonempty AliasType "&" ;

{-
%inline name_tag_list:
  nonempty_llist(name_tag)
;
-}

separator nonempty NameTag "" ;

{-
(* A method list (in an object type). *)
meth_list:
    field_semi meth_list
  | inherit_field SEMI meth_list
  | field_semi
  | inherit_field SEMI
  | field
  | inherit_field
  | DOTDOT
;
-}

FieldSemiMethListMonoType. MethList ::= LIDENT ":" AliasType [Attribute] ";" [Attribute] MethList ;
FieldSemiMethListPolyType. MethList ::= LIDENT ":" [TypeVar] "." AliasType [Attribute] ";" [Attribute] MethList ;
InheritSemiMethList.       MethList ::= AtomicType ";" MethList ;
FieldSemiMonoType.         MethList ::= LIDENT ":" AliasType [Attribute] ";" ;
FieldSemiPolyType.         MethList ::= LIDENT ":" [TypeVar] "." AliasType [Attribute] ";" ;
InheritSemi.               MethList ::= AtomicType ";" ;
FieldMonoType.             MethList ::= LIDENT ":" AliasType [Attribute] ;
FieldPolyType.             MethList ::= LIDENT ":" [TypeVar] "." AliasType [Attribute] ;
Inherit.                   MethList ::= AtomicType ;
DotDot.                    MethList ::= ".." ;

{-
%inline field:
  label COLON poly_type_no_attr attributes
;
-}

-- This definition is inlined manually

{-
%inline field_semi:
  label COLON poly_type_no_attr attributes SEMI attributes
;
-}

-- This definition is inlined manually

{-
%inline inherit_field:
  atomic_type
;
-}

-- This definition is inlined manually

{-
%inline label:
    LIDENT
;
-}

-- This definition is inlined manually

{-
/* Constants */

constant:
  | INT
  | CHAR
  | STRING
  | FLOAT
;
-}

Int.    Constant ::= INT ;
Char.   Constant ::= CHAR ;
String. Constant ::= STRING ;
Float.  Constant ::= FLOAT ;

{-
signed_constant:
    constant
  | MINUS INT
  | MINUS FLOAT
  | PLUS INT
  | PLUS FLOAT
;
-}

Constant. SignedConstant ::= Constant ;
NegInt.   SignedConstant ::= "-" INT ;
NegFloat. SignedConstant ::= "-" FLOAT ;
PosInt.   SignedConstant ::= "+" INT ;
PosFloat. SignedConstant ::= "+" FLOAT ;

{-
/* Identifiers and long identifiers */

ident:
    UIDENT
  | LIDENT
;
-}

Uppercase. OCamlIdent ::= UIDENT ;
Lowercase. OCamlIdent ::= LIDENT ;

{-
val_extra_ident:
  | LPAREN operator RPAREN
;
-}

Operator. ValExtraIdent ::= "(" Operator ")" ;

{-
val_ident:
    LIDENT
  | val_extra_ident
;
-}

LowercaseValIdent. ValIdent ::= LIDENT ;
ValExtraIdent.     ValIdent ::= ValExtraIdent ;

{-
operator:
    PREFIXOP
  | LETOP
  | ANDOP
  | DOTOP LPAREN index_mod RPAREN
  | DOTOP LPAREN index_mod RPAREN LESSMINUS
  | DOTOP LBRACKET index_mod RBRACKET
  | DOTOP LBRACKET index_mod RBRACKET LESSMINUS
  | DOTOP LBRACE index_mod RBRACE
  | DOTOP LBRACE index_mod RBRACE LESSMINUS
  | HASHOP
  | BANG
  | infix_operator
;
-}

PrefixOp.       Operator ::= PREFIXOP ;
LetOp.          Operator ::= LETOP ;
AndOp.          Operator ::= ANDOP ;
ArrayAccessOp.  Operator ::= DOTOP "(" IndexMod ")" ;
ArrayUpdateOp.  Operator ::= DOTOP "(" IndexMod ")" "<-" ;
StringAccessOp. Operator ::= DOTOP "[" IndexMod "]" ;
StringUpdateOp. Operator ::= DOTOP "[" IndexMod "]" "<-" ;
RecordAccessOp. Operator ::= DOTOP "{" IndexMod "}" ;
RecordUpdateOp. Operator ::= DOTOP "{" IndexMod "}" "<-" ;
HashSymbolOp.   Operator ::= HASHOP ;
BangOp.         Operator ::= "!" ;
InfixOp.        Operator ::= InfixOperator ;

{-
%inline infix_operator:
  | INFIXOP0
  | INFIXOP1
  | INFIXOP2
  | INFIXOP3
  | INFIXOP4
  | PLUS
  | PLUSDOT
  | PLUSEQ
  | MINUS
  | MINUSDOT
  | STAR
  | PERCENT
  | EQUAL
  | LESS
  | GREATER
  | OR
  | BARBAR
  | AMPERSAND
  | AMPERAMPER
  | COLONEQUAL
;
-}

RelOp.                   InfixOperator ::= RELOP ;
InfixEqual.              InfixOperator ::= "=" ;
InfixLess.               InfixOperator ::= "<" ;
InfixGreater.            InfixOperator ::= ">" ;
InfixBarBar.             InfixOperator ::= "||" ;
InfixAmpersand.          InfixOperator ::= "&" ;
InfixAmpersandAmpersand. InfixOperator ::= "&&" ;
ConcatOp.                InfixOperator ::= CONCATOP ;
PlusMinusOp.             InfixOperator ::= PLUSMINUSOP ;
InfixPlus.               InfixOperator ::= "+" ;
InfixMinus.              InfixOperator ::= "-" ;
MultDivOp.               InfixOperator ::= MULTDIVOP ;
InfixStar.               InfixOperator ::= "*" ;
InfixSlash.              InfixOperator ::= "/" ;
InfixPercent.            InfixOperator ::= "%" ;
PowOp.                   InfixOperator ::= POWOP ;
InfixOr.                 InfixOperator ::= "or" ;
InfixColonEqual.         InfixOperator ::= ":=" ;

{-
index_mod:
| (* empty *)
| SEMI DOTDOT
;
-}

NoIndexMod. IndexMod ::= ;
SemiDotDot. IndexMod ::= ";" ".." ;

{-
%inline constr_extra_ident:
  | LPAREN COLONCOLON RPAREN
;
-}

ConstrIdent. ConstrExtraIdent ::= "(" "::" ")" ;

{-
constr_extra_nonprefix_ident:
  | LBRACKET RBRACKET
  | LPAREN RPAREN
  | FALSE
  | TRUE
;
-}

Brackets.     ConstrExtraNonprefixIdent ::= "[" "]" ;
Parens.       ConstrExtraNonprefixIdent ::= "(" ")" ;
FalseLiteral. ConstrExtraNonprefixIdent ::= "false" ;
TrueLiteral.  ConstrExtraNonprefixIdent ::= "true" ;

{-
constr_ident:
    UIDENT
  | constr_extra_ident
  | constr_extra_nonprefix_ident
;
-}

ConstrUppercaseIdent.      ConstrIdent ::= UIDENT ;
ConstrExtraIdent.          ConstrIdent ::= ConstrExtraIdent ;
ConstrExpraNonprefixIdent. ConstrIdent ::= ConstrExtraNonprefixIdent ;

{-
constr_longident:
    mod_longident       %prec below_DOT
  | mod_longident DOT constr_extra_ident
  | constr_extra_ident
  | constr_extra_nonprefix_ident
;
-}

-- TODO: Improve names

ModLongidentTodo.              ConstrLongident ::= ModLongident ;
QualifiedConstrExtraLongident. ConstrLongident ::= ModLongident "." ConstrExtraIdent ;
ConstrExtraLongdent.           ConstrLongident ::= ConstrExtraIdent ;
ConstrExtraNonprefixLonident.  ConstrLongident ::= ConstrExtraNonprefixIdent ;

{-
mk_longident(prefix,final):
   | final
   | prefix DOT final
;
-}

{-
val_longident:
    mk_longident(mod_longident, val_ident)
;
-}

ValLongident.          ValLongident ::= ValIdent ;
QualifiedValLongident. ValLongident ::= ModLongident "." ValIdent ;

{-
label_longident:
    mk_longident(mod_longident, LIDENT)
;
-}

LabelLongident.          LabelLongident ::= LIDENT ;
QualifiedLabelLongident. LabelLongident ::= ModLongident "." LIDENT ;

{-
type_longident:
    mk_longident(mod_ext_longident, LIDENT)
;
-}

TypeLongident.           TypeLongident ::= LIDENT ;
QualifiedTypelLongident. TypeLongident ::= ModExtLongident "." LIDENT ;

{-
mod_longident:
    mk_longident(mod_longident, UIDENT)
;
-}

ModLongident.          ModLongident ::= UIDENT ;
QualifiedModLongident. ModLongident ::= ModLongident "." UIDENT ;

{-
mod_ext_longident:
    mk_longident(mod_ext_longident, UIDENT)
  | mod_ext_longident LPAREN mod_ext_longident RPAREN
;

mk_longident(prefix,final):
   | final
   | prefix DOT final
;
-}

ModExtLongident.          ModExtLongident ::= UIDENT ;
QualifiedModExtLongident. ModExtLongident ::= ModExtLongident "." UIDENT ;
ParenModExtLongident.     ModExtLongident ::= ModExtLongident "(" ModExtLongident ")" ;

{-
mty_longident:
    mk_longident(mod_ext_longident,ident)
;
-}

MtyLongident.          MtyLongident ::= OCamlIdent ;
QualifiedMtyLongident. MtyLongident ::= ModExtLongident "." OCamlIdent ;

{-
clty_longident:
    mk_longident(mod_ext_longident,LIDENT)
;
-}

CltyLongident.          CltyLongident ::= LIDENT ;
QualifiedCltyLongident. CltyLongident ::= ModExtLongident "." LIDENT ;

{-
class_longident:
   mk_longident(mod_longident,LIDENT)
;
-}

ClassLongident.          ClassLongident ::= LIDENT ;
QualifiedClassLongident. ClassLongident ::= ModLongident "." LIDENT ;

{-
/* Toplevel directives */

toplevel_directive:
  HASH mkrhs(ident) ioption(toplevel_directive_argument)
;
-}

NoToplevelDirectiveArgument. OptionalToplevelDirectiveArgument ::= ;
AToplevelDirectiveArgument.  OptionalToplevelDirectiveArgument ::= ToplevelDirectiveArgument ;

ToplevelDirectiveApp. ToplevelDirective ::= "#" OCamlIdent ToplevelDirectiveArgument ;

{-
%inline toplevel_directive_argument:
  | STRING
  | INT
  | val_longident
  | mod_longident
  | FALSE
  | TRUE
;
-}

ToplevelString.      ToplevelDirectiveArgument ::= STRING ;
ToplevelInt.         ToplevelDirectiveArgument ::= INT ;
ValueIdent.          ToplevelDirectiveArgument ::= ValLongident ;
ToplevelModuleIdent. ToplevelDirectiveArgument ::= ModLongident ;
ToplevelFalse.       ToplevelDirectiveArgument ::= "false" ;
ToplevelTrue.        ToplevelDirectiveArgument ::= "true" ;

{-
/* Miscellaneous */

(* The symbol epsilon can be used instead of an /* empty */ comment. *)
%inline epsilon:
  /* empty */
;

%inline raw_string:
  STRING
;
-}

-- This definition is inlined manually

{-
name_tag:
    BACKQUOTE ident
;
-}

NameTag. NameTag ::= "`" OCamlIdent ;

{-
rec_flag:
    /* empty */                                 { Nonrecursive }
  | REC                                         { Recursive }
;
-}

Nonrecursive. RecFlag ::= ;
Recursive.    RecFlag ::= "rec" ;

{-
%inline nonrec_flag:
    /* empty */
  | NONREC
;
-}

-- This definition is inlined manually

{-
%inline no_nonrec_flag:
    /* empty */
;
-}

-- This definition is inlined manually

{-
direction_flag:
    TO
  | DOWNTO
;
-}

UpTo.   DirectionFlag ::= "to" ;
DownTo. DirectionFlag ::= "downto" ;

{-
private_flag:
  inline_private_flag
;
-}

Public.  PrivateFlag ::= ;
Private. PrivateFlag ::= "private" ;

{-
%inline inline_private_flag:
    /* empty */                                 { Public }
  | PRIVATE                                     { Private }
;
-}

-- This definition is inlined manually

{-
mutable_flag:
    /* empty */                                 { Immutable }
  | MUTABLE                                     { Mutable }
;
-}

Immutable. MutableFlag ::= ;
Mutable.   MutableFlag ::= "mutable" ;

{-
virtual_flag:
    /* empty */                                 { Concrete }
  | VIRTUAL                                     { Virtual }
;
-}

Concrete. VirtualFlag ::= ;
Virtual.  VirtualFlag ::= "virtual" ;

{-
mutable_virtual_flags:
    /* empty */
      { Immutable, Concrete }
  | MUTABLE
      { Mutable, Concrete }
  | VIRTUAL
      { Immutable, Virtual }
  | MUTABLE VIRTUAL
  | VIRTUAL MUTABLE
      { Mutable, Virtual }
;
-}

ImmutableContrete. MutableVirtualFlags ::= ;
MutableConcrete.   MutableVirtualFlags ::= "mutable" ;
ImmutableVirtual.  MutableVirtualFlags ::= "virtual" ;
MutableVirtual.    MutableVirtualFlags ::= "mutable" "virtual" ;
VirtualMutable.    MutableVirtualFlags ::= "virtual" "mutable" ;

{-
private_virtual_flags:
    /* empty */  { Public, Concrete }
  | PRIVATE { Private, Concrete }
  | VIRTUAL { Public, Virtual }
  | PRIVATE VIRTUAL { Private, Virtual }
  | VIRTUAL PRIVATE { Private, Virtual }
;
-}

PublicConcrete.  PrivateVirtualFlags ::= ;
PrivateConcrete. PrivateVirtualFlags ::= "private" ;
PublicVirtual.   PrivateVirtualFlags ::= "virtual" ;
PrivateVirtual.  PrivateVirtualFlags ::= "private" "virtual" ;
VirtualPrivate.  PrivateVirtualFlags ::= "virtual" "private" ;

{-
(* This nonterminal symbol indicates the definite presence of a VIRTUAL
   keyword and the possible presence of a MUTABLE keyword. *)
virtual_with_mutable_flag:
  | VIRTUAL { Immutable }
  | MUTABLE VIRTUAL { Mutable }
  | VIRTUAL MUTABLE { Mutable }
;
-}

VirtualWithImmutable. VirtualWithMutableFlag ::= "virtual" ;
MutableWithVirtual.   VirtualWithMutableFlag ::= "mutable" "virtual" ;
VirtualWithMutable.   VirtualWithMutableFlag ::= "virtual" "mutable" ;

{-
(* This nonterminal symbol indicates the definite presence of a VIRTUAL
   keyword and the possible presence of a PRIVATE keyword. *)
virtual_with_private_flag:
  | VIRTUAL { Public }
  | PRIVATE VIRTUAL { Private }
  | VIRTUAL PRIVATE { Private }
;
-}

VirtualWithPublic.  VirtualWithPrivateFlag ::= "virtual" ;
PrivateWithVirtual. VirtualWithPrivateFlag ::= "private" "virtual" ;
VirtualWithPrivate. VirtualWithPrivateFlag ::= "virtual" "private" ;

{-
%inline no_override_flag:
    /* empty */                                 { Fresh }
;
-}

NoFlag. NoOverrideFlag ::= ;

{-
%inline override_flag:
    /* empty */                                 { Fresh }
  | BANG                                        { Override }
;
-}

Fresh.    OverrideFlag ::= ;
Override. OverrideFlag ::= "!" ;

{-
subtractive:
  | MINUS                                       { "-" }
  | MINUSDOT                                    { "-." }
;
-}

Minus.    Subtractive ::= "-" ;
MinusDot. Subtractive ::= "-." ;

{-
additive:
  | PLUS                                        { "+" }
  | PLUSDOT                                     { "+." }
;
-}

Plus.    Additive ::= "+" ;
PlusDot. Additive ::= "+." ;

{-
optlabel:
   | OPTLABEL
   | QUESTION LIDENT COLON
;
-}

-- This definition is inlined manually

{-
/* Attributes and extensions */

single_attr_id:
    LIDENT { $1 }
  | UIDENT { $1 }
  | AND { "and" }
  | AS { "as" }
  | ASSERT { "assert" }
  | BEGIN { "begin" }
  | CLASS { "class" }
  | CONSTRAINT { "constraint" }
  | DO { "do" }
  | DONE { "done" }
  | DOWNTO { "downto" }
  | ELSE { "else" }
  | END { "end" }
  | EXCEPTION { "exception" }
  | EXTERNAL { "external" }
  | FALSE { "false" }
  | FOR { "for" }
  | FUN { "fun" }
  | FUNCTION { "function" }
  | FUNCTOR { "functor" }
  | IF { "if" }
  | IN { "in" }
  | INCLUDE { "include" }
  | INHERIT { "inherit" }
  | INITIALIZER { "initializer" }
  | LAZY { "lazy" }
  | LET { "let" }
  | MATCH { "match" }
  | METHOD { "method" }
  | MODULE { "module" }
  | MUTABLE { "mutable" }
  | NEW { "new" }
  | NONREC { "nonrec" }
  | OBJECT { "object" }
  | OF { "of" }
  | OPEN { "open" }
  | OR { "or" }
  | PRIVATE { "private" }
  | REC { "rec" }
  | SIG { "sig" }
  | STRUCT { "struct" }
  | THEN { "then" }
  | TO { "to" }
  | TRUE { "true" }
  | TRY { "try" }
  | TYPE { "type" }
  | VAL { "val" }
  | VIRTUAL { "virtual" }
  | WHEN { "when" }
  | WHILE { "while" }
  | WITH { "with" }
/* mod/land/lor/lxor/lsl/lsr/asr are not supported for now */
;
-}

LowercaseAttr.   AttrId ::= LIDENT ;
UppercaseAttr.   AttrId ::= UIDENT ;
AndAttr.         AttrId ::= "and" ;
AsAttr.          AttrId ::= "as" ;
AssertAttr.      AttrId ::= "assert" ;
BeginAttr.       AttrId ::= "begin" ;
ClassAttr.       AttrId ::= "class" ;
ConstraintAttr.  AttrId ::= "constraint" ;
DoAttr.          AttrId ::= "do" ;
DoneAttr.        AttrId ::= "done" ;
DowntoAttr.      AttrId ::= "downto" ;
ElseAttr.        AttrId ::= "else" ;
EndAttr.         AttrId ::= "end" ;
ExceptionAttr.   AttrId ::= "exception" ;
ExternalAttr.    AttrId ::= "external" ;
FalseAttr.       AttrId ::= "false" ;
ForAttr.         AttrId ::= "for" ;
FunAttr.         AttrId ::= "fun" ;
FunctionAttr.    AttrId ::= "function" ;
FunctorAttr.     AttrId ::= "functor" ;
IfAttr.          AttrId ::= "if" ;
InAttr.          AttrId ::= "in" ;
IncludeAttr.     AttrId ::= "include" ;
InheritAttr.     AttrId ::= "inherit" ;
InitializerAttr. AttrId ::= "initializer" ;
LazyAttr.        AttrId ::= "lazy" ;
LetAttr.         AttrId ::= "let" ;
MatchAttr.       AttrId ::= "match" ;
MethodAttr.      AttrId ::= "method" ;
ModuleAttr.      AttrId ::= "module" ;
MutableAttr.     AttrId ::= "mutable" ;
NewAttr.         AttrId ::= "new" ;
NonrecAttr.      AttrId ::= "nonrec" ;
ObjectAttr.      AttrId ::= "object" ;
OfAttr.          AttrId ::= "of" ;
OpenAttr.        AttrId ::= "open" ;
OrAttr.          AttrId ::= "or" ;
PrivateAttr.     AttrId ::= "private" ;
RecAttr.         AttrId ::= "rec" ;
SigAttr.         AttrId ::= "sig" ;
StructAttr.      AttrId ::= "struct" ;
ThenAttr.        AttrId ::= "then" ;
ToAttr.          AttrId ::= "to" ;
TrueAttr.        AttrId ::= "true" ;
TryAttr.         AttrId ::= "try" ;
TypeAttr.        AttrId ::= "type" ;
ValAttr.         AttrId ::= "val" ;
VirtualAttr.     AttrId ::= "virtual" ;
WhenAttr.        AttrId ::= "when" ;
WhileAttr.       AttrId ::= "while" ;
WithAttr.        AttrId ::= "with" ;

{-
attr_id:
      single_attr_id
    | single_attr_id DOT attr_id
;
-}

separator nonempty AttrId "." ;

{-
attribute:
  LBRACKETAT attr_id attr_payload RBRACKET
;
-}

Attribute. Attribute ::= "[@" [AttrId] AttrPayload "]" ;

{-
post_item_attribute:
  LBRACKETATAT attr_id attr_payload RBRACKET
;
-}

PostItemAttribute. PostItemAttribute ::= "[@@" [AttrId] AttrPayload "]" ;

{-
floating_attribute:
  LBRACKETATATAT attr_id attr_payload RBRACKET
;
-}

FloatingAttribute. FloatingAttribute ::= "[@@@" [AttrId] AttrPayload "]" ;

{-
%inline post_item_attributes:
  post_item_attribute*
;
-}

separator PostItemAttribute "" ;

{-
%inline attributes:
  attribute*
;
-}

separator Attribute "" ;

{-
ext:
  | /* empty */
  | PERCENT attr_id
;
-}

NoExt. Ext ::= ;
Ext.   Ext ::= "%" [AttrId] ;

{-
%inline no_ext:
  | /* empty */
;
-}

-- This definition is inlined manually

{-
%inline ext_attributes:
  ext attributes
;
-}

-- This definition is inlined manually

{-
extension:
  | LBRACKETPERCENT attr_id payload RBRACKET
  | QUOTED_STRING_EXPR
;
-}

ExtensionPayload. Extension ::= "[%" [AttrId] Payload "]" ;
QuotedStringExpr. Extension ::= QUOTED_STRING_EXPR ;

{-
item_extension:
  | LBRACKETPERCENTPERCENT attr_id payload RBRACKET
  | QUOTED_STRING_ITEM
;
-}

ItemExtensionPayload. ItemExtension ::= "[%%" [AttrId] Payload "]" ;
QuotedStringItem.     ItemExtension ::= QUOTED_STRING_ITEM ;

{-
payload:
    structure
  | COLON signature
  | COLON core_type
  | QUESTION pattern
  | QUESTION pattern WHEN seq_expr
;
-}

PayloadStructure.      Payload ::= Structure ;
PayloadSignature.      Payload ::= ":" Signature ;
PayloadCoreType.       Payload ::= ":" CoreType ;
PayloadPattern.        Payload ::= "?" Pattern ;
PayloadGuardedPattern. Payload ::= "?" Pattern "when" SeqExpr ;

{-
attr_payload:
  payload
;
-}

AttrPayload. AttrPayload ::= Payload ;
