-- automatically generated by BNF Converter
module Main where

import Control.Monad (when)
import Data.List (intercalate)
import Ocaml.Abs
import Ocaml.ErrM
import Ocaml.Lex
import Ocaml.Lex (Tok (T_STRING))
import Ocaml.Par
import Ocaml.Par (pImplementation)
import Ocaml.Print
import System.Environment (getArgs, getProgName)
import System.Exit (exitFailure, exitSuccess)
import System.IO (hGetContents, stdin)

type ParseFun a = [Token] -> Err a

myLLexer = myLexer

type Verbosity = Int

putStrV :: Verbosity -> String -> IO ()
putStrV v s = when (v > 1) $ putStrLn s

runFile :: (Print a, Show a) => Verbosity -> ParseFun a -> FilePath -> IO ()
runFile v p f = putStrLn f >> readFile f >>= run v p

showToken :: Token -> String
showToken (PT _ tok) = showTok tok
showToken (Err pos) = "lexical error at " ++ show pos

showTok :: Tok -> String
showTok (TS token _) = token
showTok (TI _) = "TI"
showTok (TV _) = "TV"
showTok (TD _) = "TD"
showTok (TC _) = "TC"
showTok (T_STRING _) = "L_STRING"
showTok (T_FLOAT _) = "L_FLOAT"
showTok (T_RELOP _) = "L_RELOP"
showTok (T_CONCATOP _) = "L_CONCATOP"
showTok (T_PLUSMINUSOP _) = "L_PLUSMINUSOP"
showTok (T_MULTDIVOP _) = "L_MULTDIVOP"
showTok (T_POWOP _) = "L_POWOP"
showTok (T_DOTOP _) = "L_DOTOP"
showTok (T_LETOP _) = "L_LETOP"
showTok (T_ANDOP _) = "L_ANDOP"
showTok (T_DecimalLiteral _) = "L_DecimalLiteral"
showTok (T_DecimalLiteralModifier _) = "L_DecimalLiteralModifier"
showTok (T_HexLiteral _) = "L_HexLiteral"
showTok (T_HexLiteralModifier _) = "L_HexLiteralModifier"
showTok (T_OctLiteral _) = "L_OctLiteral"
showTok (T_OctLiteralModifier _) = "L_OctLiteralModifier"
showTok (T_BinLiteral _) = "L_BinLiteral"
showTok (T_BinLiteralModifier _) = "L_BinLiteralModifier"
showTok (T_LABEL _) = "L_LABEL"
showTok (T_LIDENT _) = "L_LIDENT"
showTok (T_OPTLABEL _) = "L_OPTLABEL"
showTok (T_PREFIXOP _) = "L_PREFIXOP"
showTok (T_HASHOP _) = "L_HASHOP"
showTok (T_QUOTED_STRING_EXPR _) = "L_QUOTED_STRING_EXPR"
showTok (T_QUOTED_STRING_ITEM _) = "L_QUOTED_STRING_ITEM"
showTok (T_UIDENT _) = "L_UIDENT"
showTok tok = error ("showTok: " ++ show tok)

run :: (Print a, Show a) => Verbosity -> ParseFun a -> String -> IO ()
run v p s =
  let ts = myLLexer s
   in case p ts of
        Bad s -> do
          putStrLn "\nParse              Failed...\n"
          putStrV v "Tokens:"
          putStrV v ("[" ++ intercalate ", " (map (show . showToken) ts) ++ ", \"%eof\" ]")
          putStrV v (show ts)
          putStrLn s
          exitFailure
        Ok tree -> do
          putStrLn "\nParse Successful!"
          showTree v tree

          exitSuccess

showTree :: (Show a, Print a) => Int -> a -> IO ()
showTree v tree =
  do
    putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
    putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree

usage :: IO ()
usage = do
  putStrLn $
    unlines
      [ "usage: Call with one of the following argument combinations:",
        "  --help          Display this help message.",
        "  (no arguments)  Parse stdin verbosely.",
        "  (files)         Parse content of files verbosely.",
        "  -s (files)      Silent mode. Parse content of files silently."
      ]
  exitFailure

main :: IO ()
main = do
  args <- getArgs
  case args of
    ["--help"] -> usage
    [] -> getContents >>= run 2 pImplementation
    "-s" : fs -> mapM_ (runFile 0 pImplementation) fs
    fs -> mapM_ (runFile 2 pImplementation) fs
