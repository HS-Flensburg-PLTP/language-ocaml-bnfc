-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.6).

-- Lexer definition for use with Alex 3
{
{-# OPTIONS -fno-warn-incomplete-patterns #-}
{-# OPTIONS_GHC -w #-}

{-# LANGUAGE PatternSynonyms #-}

module Language.Ocaml.Lex where

import Prelude

import qualified Data.Bits
import Data.Char     (ord)
import Data.Function (on)
import Data.Word     (Word8)
}

-- Predefined character classes

$c = [A-Z\192-\221] # [\215]  -- capital isolatin1 letter (215 = \times) FIXME
$s = [a-z\222-\255] # [\247]  -- small   isolatin1 letter (247 = \div  ) FIXME
$l = [$c $s]         -- letter
$d = [0-9]           -- digit
$i = [$l $d _ ']     -- identifier character
$u = [. \n]          -- universal: any character

-- Symbols and non-identifier-like reserved words

@rsyms = \# | \; \; | \( | \) | \: | \_ | \- \> | \: \> | \[ | \] | \. | \? | \; | \~ | \: \: | \, | \< \- | \{ | \} | \[ \| | \| \] | \{ \< | \> \} | \| | \. \. | \' | \+ \! | \! \+ | \- \! | \! \- | \[ \> | \[ \< | \` | \[ \@ | \[ \@ \@ | \[ \@ \@ \@ | \[ \% | \[ \% \%

:-

-- Whitespace (skipped)
<0> $white+ ;

-- Symbols
<0> @rsyms
    { tok (eitherResIdent TV) }

-- token AMPERAMPER
<0> \& \&
    { tok (eitherResIdent T_AMPERAMPER) }

-- token AMPERSAND
<0> \&
    { tok (eitherResIdent T_AMPERSAND) }

-- token BANG
<0> \!
    { tok (eitherResIdent T_BANG) }

-- token BARBAR
<0> \| \|
    { tok (eitherResIdent T_BARBAR) }

-- token COLONEQUAL
<0> \: \=
    { tok (eitherResIdent T_COLONEQUAL) }

-- token EQUAL
<0> \=
    { tok (eitherResIdent T_EQUAL) }

-- token BANGEQUAL
<0> \! \=
    { tok (eitherResIdent T_BANGEQUAL) }

-- token GREATER
<0> \>
    { tok (eitherResIdent T_GREATER) }

-- token LESS
<0> \<
    { tok (eitherResIdent T_LESS) }

-- token MINUS
<0> \-
    { tok (eitherResIdent T_MINUS) }

-- token MINUSDOT
<0> \- \.
    { tok (eitherResIdent T_MINUSDOT) }

-- token OR
<0> o r
    { tok (eitherResIdent T_OR) }

-- token PERCENT
<0> \%
    { tok (eitherResIdent T_PERCENT) }

-- token PLUS
<0> \+
    { tok (eitherResIdent T_PLUS) }

-- token PLUSDOT
<0> \+ \.
    { tok (eitherResIdent T_PLUSDOT) }

-- token PLUSEQ
<0> \+ \=
    { tok (eitherResIdent T_PLUSEQ) }

-- token STAR
<0> \*
    { tok (eitherResIdent T_STAR) }

-- token RELOP
<0> [\$ \& \< \= \> \|][\! \$ \% \& \* \+ \- \. \/ \: \< \= \> \? \@ \^ \| \~]*
    { tok (eitherResIdent T_RELOP) }

-- token CONCATOP
<0> [\@ \^][\! \$ \% \& \* \+ \- \. \/ \: \< \= \> \? \@ \^ \| \~]*
    { tok (eitherResIdent T_CONCATOP) }

-- token PLUSMINUSOP
<0> [\+ \-][\! \$ \% \& \* \+ \- \. \/ \: \< \= \> \? \@ \^ \| \~]* | l o r | l x o r
    { tok (eitherResIdent T_PLUSMINUSOP) }

-- token MULTDIVOP
<0> [\% \* \/][\! \$ \% \& \* \+ \- \. \/ \: \< \= \> \? \@ \^ \| \~]* | m o d | l a n d
    { tok (eitherResIdent T_MULTDIVOP) }

-- token POWOP
<0> \* \* [\! \$ \% \& \* \+ \- \. \/ \: \< \= \> \? \@ \^ \| \~]* | l s l | l s r | a s r
    { tok (eitherResIdent T_POWOP) }

-- token DOTOP
<0> \. [\! \$ \% \& \* \+ \- \/ \: \= \> \? \@ \^ \|][\! \$ \% \& \* \+ \- \. \/ \: \< \= \> \? \@ \^ \| \~]*
    { tok (eitherResIdent T_DOTOP) }

-- token LETOP
<0> l e t [\$ \& \* \+ \- \/ \< \= \> \@ \^ \|][\! \$ \% \& \* \+ \- \/ \: \= \> \? \@ \^ \|]*
    { tok (eitherResIdent T_LETOP) }

-- token ANDOP
<0> a n d [\$ \& \* \+ \- \/ \< \= \> \@ \^ \|][\! \$ \% \& \* \+ \- \/ \: \= \> \? \@ \^ \|]*
    { tok (eitherResIdent T_ANDOP) }

-- token HASHOP
<0> \# [\! \# \$ \% \& \* \+ \- \. \/ \: \< \= \> \? \@ \^ \| \~]+
    { tok (eitherResIdent T_HASHOP) }

-- token PREFIXOP
<0> \! [\! \# \$ \% \& \* \+ \- \. \/ \: \< \= \> \? \@ \^ \| \~]+ | [\? \~][\! \# \$ \% \& \* \+ \- \. \/ \: \< \= \> \? \@ \^ \| \~]+
    { tok (eitherResIdent T_PREFIXOP) }

-- token DecimalLiteral
<0> $d (\_ | $d)*
    { tok (eitherResIdent T_DecimalLiteral) }

-- token DecimalLiteralModifier
<0> $d (\_ | $d)* [G H I J K L M N O P Q R S T U V W X Y Z g h i j k l m n o p q r s t u v w x y z]
    { tok (eitherResIdent T_DecimalLiteralModifier) }

-- token HexLiteral
<0> 0 [X x]($d | $l)(\_ | ($d | $l)) *
    { tok (eitherResIdent T_HexLiteral) }

-- token HexLiteralModifier
<0> 0 [X x]($d | $l)(\_ | ($d | $l)) * [G H I J K L M N O P Q R S T U V W X Y Z g h i j k l m n o p q r s t u v w x y z]
    { tok (eitherResIdent T_HexLiteralModifier) }

-- token OctLiteral
<0> 0 [O o][0 1 2 3 4 5 6 7][0 1 2 3 4 5 6 7 \_]*
    { tok (eitherResIdent T_OctLiteral) }

-- token OctLiteralModifier
<0> 0 [O o][0 1 2 3 4 5 6 7][0 1 2 3 4 5 6 7 \_]* [G H I J K L M N O P Q R S T U V W X Y Z g h i j k l m n o p q r s t u v w x y z]
    { tok (eitherResIdent T_OctLiteralModifier) }

-- token BinLiteral
<0> 0 [B b][0 1][0 1 \_]*
    { tok (eitherResIdent T_BinLiteral) }

-- token BinLiteralModifier
<0> 0 [B b][0 1][0 1 \_]* [G H I J K L M N O P Q R S T U V W X Y Z g h i j k l m n o p q r s t u v w x y z]
    { tok (eitherResIdent T_BinLiteralModifier) }

-- token FLOAT
<0> $d (\_ | $d)* (\. (\_ | $d)*)? ([E e][\+ \-]? $d (\_ | $d)*)? | 0 [X x]($d | $l)(\_ | ($d | $l)) * (\. (\_ | ($d | $l)) *)? ([P p][\+ \-]$d (\_ | $d)*)?
    { tok (eitherResIdent T_FLOAT) }

-- token CHAR
<0> \' ([$u # [\' \\]] | \\ ([\  \" \' \\ b n r t]| $d $d $d | x ($d | $l)($d | $l)| o [0 1 2 3][0 1 2 3 4 5 6 7][0 1 2 3 4 5 6 7]))\'
    { tok (eitherResIdent T_CHAR) }

-- token STRING
<0> \" ([$u # [\" \\]] | \\ ([\  \" \' \\ b n r t]| $d $d $d | x ($d | $l)($d | $l)| o [0 1 2 3][0 1 2 3 4 5 6 7][0 1 2 3 4 5 6 7]| u \{ ($d | $l)+ \})| \n | \\ [\n \r][\t \ ]*)* \"
    { tok (eitherResIdent T_STRING) }

-- token QUOTED_STRING_EXPR
<0> \{ \% $l (\_ | ($d | $l)) * (\. $l (\_ | ($d | $l)) *)* \|
    { tok (eitherResIdent T_QUOTED_STRING_EXPR) }

-- token QUOTED_STRING_ITEM
<0> \{ \% \% $l (\_ | ($d | $l)) * (\. $l (\_ | ($d | $l)) *)* \|
    { tok (eitherResIdent T_QUOTED_STRING_ITEM) }

-- token LIDENT
<0> (\_ | $s)([\' \_]| ($d | $l)) *
    { tok (eitherResIdent T_LIDENT) }

-- token UIDENT
<0> $c ([\' \_]| ($d | $l)) *
    { tok (eitherResIdent T_UIDENT) }

-- token LABEL
<0> \~ (\_ | ($d | $l)) (\_ | ($d | $l)) * \:
    { tok (eitherResIdent T_LABEL) }

-- token OPTLABEL
<0> \? (\_ | ($d | $l)) (\_ | ($d | $l)) * \:
    { tok (eitherResIdent T_OPTLABEL) }

-- Keywords and Ident
<0> $l $i*
    { tok (eitherResIdent TV) }

{
-- | Create a token with position.
tok :: (String -> Tok) -> (Posn -> String -> Token)
tok f p = PT p . f

-- | Token without position.
data Tok
  = TK {-# UNPACK #-} !TokSymbol  -- ^ Reserved word or symbol.
  | TL !String                    -- ^ String literal.
  | TI !String                    -- ^ Integer literal.
  | TV !String                    -- ^ Identifier.
  | TD !String                    -- ^ Float literal.
  | TC !String                    -- ^ Character literal.
  | T_AMPERAMPER !String
  | T_AMPERSAND !String
  | T_BANG !String
  | T_BARBAR !String
  | T_COLONEQUAL !String
  | T_EQUAL !String
  | T_BANGEQUAL !String
  | T_GREATER !String
  | T_LESS !String
  | T_MINUS !String
  | T_MINUSDOT !String
  | T_OR !String
  | T_PERCENT !String
  | T_PLUS !String
  | T_PLUSDOT !String
  | T_PLUSEQ !String
  | T_STAR !String
  | T_RELOP !String
  | T_CONCATOP !String
  | T_PLUSMINUSOP !String
  | T_MULTDIVOP !String
  | T_POWOP !String
  | T_DOTOP !String
  | T_LETOP !String
  | T_ANDOP !String
  | T_HASHOP !String
  | T_PREFIXOP !String
  | T_DecimalLiteral !String
  | T_DecimalLiteralModifier !String
  | T_HexLiteral !String
  | T_HexLiteralModifier !String
  | T_OctLiteral !String
  | T_OctLiteralModifier !String
  | T_BinLiteral !String
  | T_BinLiteralModifier !String
  | T_FLOAT !String
  | T_CHAR !String
  | T_STRING !String
  | T_QUOTED_STRING_EXPR !String
  | T_QUOTED_STRING_ITEM !String
  | T_LIDENT !String
  | T_UIDENT !String
  | T_LABEL !String
  | T_OPTLABEL !String
  deriving (Eq, Show, Ord)

-- | Smart constructor for 'Tok' for the sake of backwards compatibility.
pattern TS :: String -> Int -> Tok
pattern TS t i = TK (TokSymbol t i)

-- | Keyword or symbol tokens have a unique ID.
data TokSymbol = TokSymbol
  { tsText :: String
      -- ^ Keyword or symbol text.
  , tsID   :: !Int
      -- ^ Unique ID.
  } deriving (Show)

-- | Keyword/symbol equality is determined by the unique ID.
instance Eq  TokSymbol where (==)    = (==)    `on` tsID

-- | Keyword/symbol ordering is determined by the unique ID.
instance Ord TokSymbol where compare = compare `on` tsID

-- | Token with position.
data Token
  = PT  Posn Tok
  | Err Posn
  deriving (Eq, Show, Ord)

-- | Pretty print a position.
printPosn :: Posn -> String
printPosn (Pn _ l c) = "line " ++ show l ++ ", column " ++ show c

-- | Pretty print the position of the first token in the list.
tokenPos :: [Token] -> String
tokenPos (t:_) = printPosn (tokenPosn t)
tokenPos []    = "end of file"

-- | Get the position of a token.
tokenPosn :: Token -> Posn
tokenPosn (PT p _) = p
tokenPosn (Err p)  = p

-- | Get line and column of a token.
tokenLineCol :: Token -> (Int, Int)
tokenLineCol = posLineCol . tokenPosn

-- | Get line and column of a position.
posLineCol :: Posn -> (Int, Int)
posLineCol (Pn _ l c) = (l,c)

-- | Convert a token into "position token" form.
mkPosToken :: Token -> ((Int, Int), String)
mkPosToken t = (tokenLineCol t, tokenText t)

-- | Convert a token to its text.
tokenText :: Token -> String
tokenText t = case t of
  PT _ (TS s _) -> s
  PT _ (TL s)   -> show s
  PT _ (TI s)   -> s
  PT _ (TV s)   -> s
  PT _ (TD s)   -> s
  PT _ (TC s)   -> s
  Err _         -> "#error"
  PT _ (T_AMPERAMPER s) -> s
  PT _ (T_AMPERSAND s) -> s
  PT _ (T_BANG s) -> s
  PT _ (T_BARBAR s) -> s
  PT _ (T_COLONEQUAL s) -> s
  PT _ (T_EQUAL s) -> s
  PT _ (T_BANGEQUAL s) -> s
  PT _ (T_GREATER s) -> s
  PT _ (T_LESS s) -> s
  PT _ (T_MINUS s) -> s
  PT _ (T_MINUSDOT s) -> s
  PT _ (T_OR s) -> s
  PT _ (T_PERCENT s) -> s
  PT _ (T_PLUS s) -> s
  PT _ (T_PLUSDOT s) -> s
  PT _ (T_PLUSEQ s) -> s
  PT _ (T_STAR s) -> s
  PT _ (T_RELOP s) -> s
  PT _ (T_CONCATOP s) -> s
  PT _ (T_PLUSMINUSOP s) -> s
  PT _ (T_MULTDIVOP s) -> s
  PT _ (T_POWOP s) -> s
  PT _ (T_DOTOP s) -> s
  PT _ (T_LETOP s) -> s
  PT _ (T_ANDOP s) -> s
  PT _ (T_HASHOP s) -> s
  PT _ (T_PREFIXOP s) -> s
  PT _ (T_DecimalLiteral s) -> s
  PT _ (T_DecimalLiteralModifier s) -> s
  PT _ (T_HexLiteral s) -> s
  PT _ (T_HexLiteralModifier s) -> s
  PT _ (T_OctLiteral s) -> s
  PT _ (T_OctLiteralModifier s) -> s
  PT _ (T_BinLiteral s) -> s
  PT _ (T_BinLiteralModifier s) -> s
  PT _ (T_FLOAT s) -> s
  PT _ (T_CHAR s) -> s
  PT _ (T_STRING s) -> s
  PT _ (T_QUOTED_STRING_EXPR s) -> s
  PT _ (T_QUOTED_STRING_ITEM s) -> s
  PT _ (T_LIDENT s) -> s
  PT _ (T_UIDENT s) -> s
  PT _ (T_LABEL s) -> s
  PT _ (T_OPTLABEL s) -> s

-- | Convert a token to a string.
prToken :: Token -> String
prToken t = tokenText t

-- | Finite map from text to token organized as binary search tree.
data BTree
  = N -- ^ Nil (leaf).
  | B String Tok BTree BTree
      -- ^ Binary node.
  deriving (Show)

-- | Convert potential keyword into token or use fallback conversion.
eitherResIdent :: (String -> Tok) -> String -> Tok
eitherResIdent tv s = treeFind resWords
  where
  treeFind N = tv s
  treeFind (B a t left right) =
    case compare s a of
      LT -> treeFind left
      GT -> treeFind right
      EQ -> t

-- | The keywords and symbols of the language organized as binary search tree.
resWords :: BTree
resWords =
  b "exception" 44
    (b "[%" 22
       (b "." 11
          (b ")" 6
             (b "#" 3 (b "!-" 2 (b "!+" 1 N N) N) (b "(" 5 (b "'" 4 N N) N))
             (b "-!" 9 (b "," 8 (b "+!" 7 N N) N) (b "->" 10 N N)))
          (b ";;" 17
             (b "::" 14
                (b ":" 13 (b ".." 12 N N) N) (b ";" 16 (b ":>" 15 N N) N))
             (b "?" 20 (b ">}" 19 (b "<-" 18 N N) N) (b "[" 21 N N))))
       (b "and" 33
          (b "[@@@" 28
             (b "[>" 25
                (b "[<" 24 (b "[%%" 23 N N) N) (b "[@@" 27 (b "[@" 26 N N) N))
             (b "_" 31 (b "]" 30 (b "[|" 29 N N) N) (b "`" 32 N N)))
          (b "do" 39
             (b "begin" 36
                (b "assert" 35 (b "as" 34 N N) N)
                (b "constraint" 38 (b "class" 37 N N) N))
             (b "else" 42
                (b "downto" 41 (b "done" 40 N N) N) (b "end" 43 N N)))))
    (b "open" 66
       (b "initializer" 55
          (b "functor" 50
             (b "for" 47
                (b "false" 46 (b "external" 45 N N) N)
                (b "function" 49 (b "fun" 48 N N) N))
             (b "include" 53
                (b "in" 52 (b "if" 51 N N) N) (b "inherit" 54 N N)))
          (b "mutable" 61
             (b "match" 58
                (b "let" 57 (b "lazy" 56 N N) N)
                (b "module" 60 (b "method" 59 N N) N))
             (b "object" 64
                (b "nonrec" 63 (b "new" 62 N N) N) (b "of" 65 N N))))
       (b "virtual" 77
          (b "to" 72
             (b "sig" 69
                (b "rec" 68 (b "private" 67 N N) N)
                (b "then" 71 (b "struct" 70 N N) N))
             (b "type" 75 (b "try" 74 (b "true" 73 N N) N) (b "val" 76 N N)))
          (b "{<" 82
             (b "with" 80 (b "while" 79 (b "when" 78 N N) N) (b "{" 81 N N))
             (b "}" 85 (b "|]" 84 (b "|" 83 N N) N) (b "~" 86 N N)))))
  where
  b s n = B bs (TS bs n)
    where
    bs = s

-- | Unquote string literal.
unescapeInitTail :: String -> String
unescapeInitTail = id . unesc . tail . id
  where
  unesc s = case s of
    '\\':c:cs | elem c ['\"', '\\', '\''] -> c : unesc cs
    '\\':'n':cs  -> '\n' : unesc cs
    '\\':'t':cs  -> '\t' : unesc cs
    '\\':'r':cs  -> '\r' : unesc cs
    '\\':'f':cs  -> '\f' : unesc cs
    '"':[]       -> []
    c:cs         -> c : unesc cs
    _            -> []

-------------------------------------------------------------------
-- Alex wrapper code.
-- A modified "posn" wrapper.
-------------------------------------------------------------------

data Posn = Pn !Int !Int !Int
  deriving (Eq, Show, Ord)

alexStartPos :: Posn
alexStartPos = Pn 0 1 1

alexMove :: Posn -> Char -> Posn
alexMove (Pn a l c) '\t' = Pn (a+1)  l     (((c+7) `div` 8)*8+1)
alexMove (Pn a l c) '\n' = Pn (a+1) (l+1)   1
alexMove (Pn a l c) _    = Pn (a+1)  l     (c+1)

type Byte = Word8

type AlexInput = (Posn,     -- current position,
                  Char,     -- previous char
                  [Byte],   -- pending bytes on the current char
                  String)   -- current input string

tokens :: String -> [Token]
tokens str = go (alexStartPos, '\n', [], str)
    where
      go :: AlexInput -> [Token]
      go inp@(pos, _, _, str) =
               case alexScan inp 0 of
                AlexEOF                   -> []
                AlexError (pos, _, _, _)  -> [Err pos]
                AlexSkip  inp' len        -> go inp'
                AlexToken inp' len act    -> act pos (take len str) : (go inp')

alexGetByte :: AlexInput -> Maybe (Byte,AlexInput)
alexGetByte (p, c, (b:bs), s) = Just (b, (p, c, bs, s))
alexGetByte (p, _, [], s) =
  case s of
    []  -> Nothing
    (c:s) ->
             let p'     = alexMove p c
                 (b:bs) = utf8Encode c
              in p' `seq` Just (b, (p', c, bs, s))

alexInputPrevChar :: AlexInput -> Char
alexInputPrevChar (p, c, bs, s) = c

-- | Encode a Haskell String to a list of Word8 values, in UTF8 format.
utf8Encode :: Char -> [Word8]
utf8Encode = map fromIntegral . go . ord
  where
  go oc
   | oc <= 0x7f       = [oc]

   | oc <= 0x7ff      = [ 0xc0 + (oc `Data.Bits.shiftR` 6)
                        , 0x80 + oc Data.Bits..&. 0x3f
                        ]

   | oc <= 0xffff     = [ 0xe0 + (oc `Data.Bits.shiftR` 12)
                        , 0x80 + ((oc `Data.Bits.shiftR` 6) Data.Bits..&. 0x3f)
                        , 0x80 + oc Data.Bits..&. 0x3f
                        ]
   | otherwise        = [ 0xf0 + (oc `Data.Bits.shiftR` 18)
                        , 0x80 + ((oc `Data.Bits.shiftR` 12) Data.Bits..&. 0x3f)
                        , 0x80 + ((oc `Data.Bits.shiftR` 6) Data.Bits..&. 0x3f)
                        , 0x80 + oc Data.Bits..&. 0x3f
                        ]
}
