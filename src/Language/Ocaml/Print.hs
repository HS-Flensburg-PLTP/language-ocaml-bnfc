-- File generated by the BNF Converter (bnfc 2.9.6).

{-# LANGUAGE CPP #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE LambdaCase #-}
#if __GLASGOW_HASKELL__ <= 708
{-# LANGUAGE OverlappingInstances #-}
#endif

-- | Pretty-printer for Language.

module Language.Ocaml.Print where

import Prelude
  ( ($), (.)
  , Bool(..), (==), (<)
  , Int, Integer, Double, (+), (-), (*)
  , String, (++)
  , ShowS, showChar, showString
  , all, elem, foldr, id, map, null, replicate, shows, span
  )
import Data.Char ( Char, isSpace )
import qualified Language.Ocaml.Abs

-- | The top-level printing method.

printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 False (map ($ "") $ d []) ""
  where
  rend
    :: Int        -- ^ Indentation level.
    -> Bool       -- ^ Pending indentation to be output before next character?
    -> [String]
    -> ShowS
  rend i p = \case
      "["      :ts -> char '[' . rend i False ts
      "("      :ts -> char '(' . rend i False ts
      "{"      :ts -> onNewLine i     p . showChar   '{'  . new (i+1) ts
      "}" : ";":ts -> onNewLine (i-1) p . showString "};" . new (i-1) ts
      "}"      :ts -> onNewLine (i-1) p . showChar   '}'  . new (i-1) ts
      [";"]        -> char ';'
      ";"      :ts -> char ';' . new i ts
      t  : ts@(s:_) | closingOrPunctuation s
                   -> pending . showString t . rend i False ts
      t        :ts -> pending . space t      . rend i False ts
      []           -> id
    where
    -- Output character after pending indentation.
    char :: Char -> ShowS
    char c = pending . showChar c

    -- Output pending indentation.
    pending :: ShowS
    pending = if p then indent i else id

  -- Indentation (spaces) for given indentation level.
  indent :: Int -> ShowS
  indent i = replicateS (2*i) (showChar ' ')

  -- Continue rendering in new line with new indentation.
  new :: Int -> [String] -> ShowS
  new j ts = showChar '\n' . rend j True ts

  -- Make sure we are on a fresh line.
  onNewLine :: Int -> Bool -> ShowS
  onNewLine i p = (if p then id else showChar '\n') . indent i

  -- Separate given string from following text by a space (if needed).
  space :: String -> ShowS
  space t s =
    case (all isSpace t, null spc, null rest) of
      (True , _   , True ) -> []             -- remove trailing space
      (False, _   , True ) -> t              -- remove trailing space
      (False, True, False) -> t ++ ' ' : s   -- add space if none
      _                    -> t ++ s
    where
      (spc, rest) = span isSpace s

  closingOrPunctuation :: String -> Bool
  closingOrPunctuation [c] = c `elem` closerOrPunct
  closingOrPunctuation _   = False

  closerOrPunct :: String
  closerOrPunct = ")],;"

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- | The printer class does the job.

class Print a where
  prt :: Int -> a -> Doc

instance {-# OVERLAPPABLE #-} Print a => Print [a] where
  prt i = concatD . map (prt i)

instance Print Char where
  prt _ c = doc (showChar '\'' . mkEsc '\'' c . showChar '\'')

instance Print String where
  prt _ = printString

printString :: String -> Doc
printString s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q = \case
  s | s == q -> showChar '\\' . showChar s
  '\\' -> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  s -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id

instance Print Integer where
  prt _ x = doc (shows x)

instance Print Double where
  prt _ x = doc (shows x)

instance Print Language.Ocaml.Abs.AMPERAMPER where
  prt _ (Language.Ocaml.Abs.AMPERAMPER (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.AMPERSAND where
  prt _ (Language.Ocaml.Abs.AMPERSAND (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.BANG where
  prt _ (Language.Ocaml.Abs.BANG (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.BARBAR where
  prt _ (Language.Ocaml.Abs.BARBAR (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.COLONEQUAL where
  prt _ (Language.Ocaml.Abs.COLONEQUAL (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.EQUAL where
  prt _ (Language.Ocaml.Abs.EQUAL (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.GREATER where
  prt _ (Language.Ocaml.Abs.GREATER (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.LESS where
  prt _ (Language.Ocaml.Abs.LESS (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.MINUS where
  prt _ (Language.Ocaml.Abs.MINUS (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.OR where
  prt _ (Language.Ocaml.Abs.OR (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.PERCENT where
  prt _ (Language.Ocaml.Abs.PERCENT (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.PLUS where
  prt _ (Language.Ocaml.Abs.PLUS (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.STAR where
  prt _ (Language.Ocaml.Abs.STAR (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.RELOP where
  prt _ (Language.Ocaml.Abs.RELOP (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.CONCATOP where
  prt _ (Language.Ocaml.Abs.CONCATOP (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.PLUSMINUSOP where
  prt _ (Language.Ocaml.Abs.PLUSMINUSOP (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.MULTDIVOP where
  prt _ (Language.Ocaml.Abs.MULTDIVOP (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.POWOP where
  prt _ (Language.Ocaml.Abs.POWOP (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.DOTOP where
  prt _ (Language.Ocaml.Abs.DOTOP (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.LETOP where
  prt _ (Language.Ocaml.Abs.LETOP (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.ANDOP where
  prt _ (Language.Ocaml.Abs.ANDOP (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.HASHOP where
  prt _ (Language.Ocaml.Abs.HASHOP (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.PREFIXOP where
  prt _ (Language.Ocaml.Abs.PREFIXOP (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.DecimalLiteral where
  prt _ (Language.Ocaml.Abs.DecimalLiteral i) = doc $ showString i
instance Print Language.Ocaml.Abs.DecimalLiteralModifier where
  prt _ (Language.Ocaml.Abs.DecimalLiteralModifier i) = doc $ showString i
instance Print Language.Ocaml.Abs.HexLiteral where
  prt _ (Language.Ocaml.Abs.HexLiteral i) = doc $ showString i
instance Print Language.Ocaml.Abs.HexLiteralModifier where
  prt _ (Language.Ocaml.Abs.HexLiteralModifier i) = doc $ showString i
instance Print Language.Ocaml.Abs.OctLiteral where
  prt _ (Language.Ocaml.Abs.OctLiteral i) = doc $ showString i
instance Print Language.Ocaml.Abs.OctLiteralModifier where
  prt _ (Language.Ocaml.Abs.OctLiteralModifier i) = doc $ showString i
instance Print Language.Ocaml.Abs.BinLiteral where
  prt _ (Language.Ocaml.Abs.BinLiteral i) = doc $ showString i
instance Print Language.Ocaml.Abs.BinLiteralModifier where
  prt _ (Language.Ocaml.Abs.BinLiteralModifier i) = doc $ showString i
instance Print Language.Ocaml.Abs.FLOAT where
  prt _ (Language.Ocaml.Abs.FLOAT i) = doc $ showString i
instance Print Language.Ocaml.Abs.CHAR where
  prt _ (Language.Ocaml.Abs.CHAR i) = doc $ showString i
instance Print Language.Ocaml.Abs.STRING where
  prt _ (Language.Ocaml.Abs.STRING i) = doc $ showString i
instance Print Language.Ocaml.Abs.QUOTED_STRING_EXPR where
  prt _ (Language.Ocaml.Abs.QUOTED_STRING_EXPR i) = doc $ showString i
instance Print Language.Ocaml.Abs.QUOTED_STRING_ITEM where
  prt _ (Language.Ocaml.Abs.QUOTED_STRING_ITEM i) = doc $ showString i
instance Print Language.Ocaml.Abs.LIDENT where
  prt _ (Language.Ocaml.Abs.LIDENT (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.UIDENT where
  prt _ (Language.Ocaml.Abs.UIDENT i) = doc $ showString i
instance Print Language.Ocaml.Abs.LABEL where
  prt _ (Language.Ocaml.Abs.LABEL (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.OPTLABEL where
  prt _ (Language.Ocaml.Abs.OPTLABEL (_,i)) = doc $ showString i
instance Print Language.Ocaml.Abs.INT where
  prt i = \case
    Language.Ocaml.Abs.ModifiedDecimal decimalliteralmodifier -> prPrec i 0 (concatD [prt 0 decimalliteralmodifier])
    Language.Ocaml.Abs.Decimal decimalliteral -> prPrec i 0 (concatD [prt 0 decimalliteral])
    Language.Ocaml.Abs.ModifiedHex hexliteralmodifier -> prPrec i 0 (concatD [prt 0 hexliteralmodifier])
    Language.Ocaml.Abs.Hex hexliteral -> prPrec i 0 (concatD [prt 0 hexliteral])
    Language.Ocaml.Abs.ModifiedOct octliteralmodifier -> prPrec i 0 (concatD [prt 0 octliteralmodifier])
    Language.Ocaml.Abs.Oct octliteral -> prPrec i 0 (concatD [prt 0 octliteral])
    Language.Ocaml.Abs.ModifiedBin binliteralmodifier -> prPrec i 0 (concatD [prt 0 binliteralmodifier])
    Language.Ocaml.Abs.Bin binliteral -> prPrec i 0 (concatD [prt 0 binliteral])

instance Print Language.Ocaml.Abs.Implementation where
  prt i = \case
    Language.Ocaml.Abs.Implementation structure -> prPrec i 0 (concatD [prt 0 structure])

instance Print Language.Ocaml.Abs.Interface where
  prt i = \case
    Language.Ocaml.Abs.Interface signature -> prPrec i 0 (concatD [prt 0 signature])

instance Print [Language.Ocaml.Abs.StructureItem] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.ToplevelPhrase where
  prt i = \case
    Language.Ocaml.Abs.StrExpr seqexpr postitemattributes -> prPrec i 0 (concatD [prt 0 seqexpr, prt 0 postitemattributes, doc (showString ";;")])
    Language.Ocaml.Abs.StructureItems structureitems -> prPrec i 0 (concatD [prt 0 structureitems, doc (showString ";;")])
    Language.Ocaml.Abs.ToplevelDirective topleveldirective -> prPrec i 0 (concatD [prt 0 topleveldirective, doc (showString ";;")])

instance Print Language.Ocaml.Abs.UseFile where
  prt i = \case
    Language.Ocaml.Abs.UseFile usefileelements -> prPrec i 0 (concatD [prt 0 usefileelements])
    Language.Ocaml.Abs.UseFileWithStrExp seqexpr postitemattributes usefileelements -> prPrec i 0 (concatD [prt 0 seqexpr, prt 0 postitemattributes, prt 0 usefileelements])

instance Print [Language.Ocaml.Abs.UseFileElement] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.UseFileElement where
  prt i = \case
    Language.Ocaml.Abs.NoUseFileElement -> prPrec i 0 (concatD [doc (showString ";;")])
    Language.Ocaml.Abs.UseFileStrExp seqexpr postitemattributes -> prPrec i 0 (concatD [doc (showString ";;"), prt 0 seqexpr, prt 0 postitemattributes])
    Language.Ocaml.Abs.UseFileStructureItem structureitem -> prPrec i 0 (concatD [prt 0 structureitem])
    Language.Ocaml.Abs.UseFileToplevelDirective topleveldirective -> prPrec i 0 (concatD [prt 0 topleveldirective])

instance Print [Language.Ocaml.Abs.FunctorArg] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.FunctorArg where
  prt i = \case
    Language.Ocaml.Abs.NoFunctorArg -> prPrec i 0 (concatD [doc (showString "("), doc (showString ")")])
    Language.Ocaml.Abs.FunctorArg modulename moduletype -> prPrec i 0 (concatD [doc (showString "("), prt 0 modulename, doc (showString ":"), prt 0 moduletype, doc (showString ")")])

instance Print Language.Ocaml.Abs.ModuleName where
  prt i = \case
    Language.Ocaml.Abs.ModuleNameIdent uident -> prPrec i 0 (concatD [prt 0 uident])
    Language.Ocaml.Abs.ModuleNameUnderscore -> prPrec i 0 (concatD [doc (showString "_")])

instance Print Language.Ocaml.Abs.ModuleExpr where
  prt i = \case
    Language.Ocaml.Abs.ModuleExprStruct attributes structure -> prPrec i 0 (concatD [doc (showString "struct"), prt 0 attributes, prt 0 structure, doc (showString "end")])
    Language.Ocaml.Abs.ModuleExprFunctor attributes functorargs moduleexpr -> prPrec i 0 (concatD [doc (showString "functor"), prt 0 attributes, prt 0 functorargs, doc (showString "->"), prt 0 moduleexpr])
    Language.Ocaml.Abs.ModuleExprParen parenmoduleexpr -> prPrec i 0 (concatD [prt 0 parenmoduleexpr])
    Language.Ocaml.Abs.ModuleExprWithAttribute moduleexpr attribute -> prPrec i 0 (concatD [prt 0 moduleexpr, prt 0 attribute])
    Language.Ocaml.Abs.ModuleExprIdent modlongident -> prPrec i 0 (concatD [prt 0 modlongident])
    Language.Ocaml.Abs.ModuleExprFunctorApp moduleexpr parenmoduleexpr -> prPrec i 0 (concatD [prt 0 moduleexpr, prt 0 parenmoduleexpr])
    Language.Ocaml.Abs.FunctorAppUnit moduleexpr -> prPrec i 0 (concatD [prt 0 moduleexpr, doc (showString "("), doc (showString ")")])
    Language.Ocaml.Abs.ModuleExprExtension extension -> prPrec i 0 (concatD [prt 0 extension])

instance Print Language.Ocaml.Abs.ParenModuleExpr where
  prt i = \case
    Language.Ocaml.Abs.ModuleExprWithType moduleexpr moduletype -> prPrec i 0 (concatD [doc (showString "("), prt 0 moduleexpr, doc (showString ":"), prt 0 moduletype, doc (showString ")")])
    Language.Ocaml.Abs.ModuleExpr moduleexpr -> prPrec i 0 (concatD [doc (showString "("), prt 0 moduleexpr, doc (showString ")")])
    Language.Ocaml.Abs.ValParenModuleExpr attributes exprcolonpackagetype -> prPrec i 0 (concatD [doc (showString "("), doc (showString "val"), prt 0 attributes, prt 0 exprcolonpackagetype, doc (showString ")")])

instance Print Language.Ocaml.Abs.ExprColonPackageType where
  prt i = \case
    Language.Ocaml.Abs.Expr expr -> prPrec i 0 (concatD [prt 0 expr])
    Language.Ocaml.Abs.ExprWithType expr moduletype -> prPrec i 0 (concatD [prt 0 expr, doc (showString ":"), prt 0 moduletype])
    Language.Ocaml.Abs.ExprWithCoercionFromTo expr moduletype1 moduletype2 -> prPrec i 0 (concatD [prt 0 expr, doc (showString ":"), prt 0 moduletype1, doc (showString ":>"), prt 0 moduletype2])
    Language.Ocaml.Abs.ExprWithCoercionTo expr moduletype -> prPrec i 0 (concatD [prt 0 expr, doc (showString ":>"), prt 0 moduletype])

instance Print [Language.Ocaml.Abs.StructureElement] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.Structure where
  prt i = \case
    Language.Ocaml.Abs.NoStructure -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.StandaloneExpression seqexpr postitemattributes -> prPrec i 0 (concatD [prt 0 seqexpr, prt 0 postitemattributes])
    Language.Ocaml.Abs.StandaloneExpressionAndStructureElements seqexpr postitemattributes structureelements -> prPrec i 0 (concatD [prt 0 seqexpr, prt 0 postitemattributes, prt 0 structureelements])
    Language.Ocaml.Abs.StructureElements structureelements -> prPrec i 0 (concatD [prt 0 structureelements])

instance Print Language.Ocaml.Abs.StructureElement where
  prt i = \case
    Language.Ocaml.Abs.StructureSemiSemi -> prPrec i 0 (concatD [doc (showString ";;")])
    Language.Ocaml.Abs.StructureStrExpr seqexpr postitemattributes -> prPrec i 0 (concatD [doc (showString ";;"), prt 0 seqexpr, prt 0 postitemattributes])
    Language.Ocaml.Abs.StructureItem structureitem -> prPrec i 0 (concatD [prt 0 structureitem])

instance Print Language.Ocaml.Abs.StructureItem where
  prt i = \case
    Language.Ocaml.Abs.StrLetBindings letbindingsext -> prPrec i 0 (concatD [prt 0 letbindingsext])
    Language.Ocaml.Abs.StrItemExtension itemextension postitemattributes -> prPrec i 0 (concatD [prt 0 itemextension, prt 0 postitemattributes])
    Language.Ocaml.Abs.StrFloatingAttribute floatingattribute -> prPrec i 0 (concatD [prt 0 floatingattribute])
    Language.Ocaml.Abs.StrPrimitiveDeclaration primitivedeclaration -> prPrec i 0 (concatD [prt 0 primitivedeclaration])
    Language.Ocaml.Abs.StrValueDescription valuedescription -> prPrec i 0 (concatD [prt 0 valuedescription])
    Language.Ocaml.Abs.StrTypeDeclarations typedeclaration andtypedeclarations -> prPrec i 0 (concatD [prt 0 typedeclaration, prt 0 andtypedeclarations])
    Language.Ocaml.Abs.StrTypeExtension ext attributes typeparameters typelongident privateflag barllistextensionconstructor postitemattributes -> prPrec i 0 (concatD [doc (showString "type"), prt 0 ext, prt 0 attributes, prt 0 typeparameters, prt 0 typelongident, doc (showString "+="), prt 0 privateflag, prt 0 barllistextensionconstructor, prt 0 postitemattributes])
    Language.Ocaml.Abs.StrExceptionDeclaration strexceptiondeclaration -> prPrec i 0 (concatD [prt 0 strexceptiondeclaration])
    Language.Ocaml.Abs.StrModuleBinding ext attributes modulename modulebindingbody postitemattributes -> prPrec i 0 (concatD [doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, prt 0 postitemattributes])
    Language.Ocaml.Abs.StrRecModuleBindings ext attributes modulename modulebindingbody postitemattributes andmodulebindings -> prPrec i 0 (concatD [doc (showString "module"), prt 0 ext, prt 0 attributes, doc (showString "rec"), prt 0 modulename, prt 0 modulebindingbody, prt 0 postitemattributes, prt 0 andmodulebindings])
    Language.Ocaml.Abs.StrModuleTypeDeclaration moduletypedeclaration -> prPrec i 0 (concatD [prt 0 moduletypedeclaration])
    Language.Ocaml.Abs.StrOpenDeclaration opendeclaration -> prPrec i 0 (concatD [prt 0 opendeclaration])
    Language.Ocaml.Abs.StrClassDeclarations ext attributes virtualflag formalclassparameters lident classfunbinding postitemattributes andclassdeclarations -> prPrec i 0 (concatD [doc (showString "class"), prt 0 ext, prt 0 attributes, prt 0 virtualflag, prt 0 formalclassparameters, prt 0 lident, prt 0 classfunbinding, prt 0 postitemattributes, prt 0 andclassdeclarations])
    Language.Ocaml.Abs.StrClassTypeDeclarations classtypedeclarations -> prPrec i 0 (concatD [prt 0 classtypedeclarations])
    Language.Ocaml.Abs.StrIncludeStatement ext attributes moduleexpr postitemattributes -> prPrec i 0 (concatD [doc (showString "include"), prt 0 ext, prt 0 attributes, prt 0 moduleexpr, prt 0 postitemattributes])

instance Print Language.Ocaml.Abs.ModuleBindingBody where
  prt i = \case
    Language.Ocaml.Abs.ModuleBinding equal moduleexpr -> prPrec i 0 (concatD [prt 0 equal, prt 0 moduleexpr])
    Language.Ocaml.Abs.ModuleBindingWitgType moduletype equal moduleexpr -> prPrec i 0 (concatD [doc (showString ":"), prt 0 moduletype, prt 0 equal, prt 0 moduleexpr])
    Language.Ocaml.Abs.FunctorBinding functorarg modulebindingbody -> prPrec i 0 (concatD [prt 0 functorarg, prt 0 modulebindingbody])

instance Print [Language.Ocaml.Abs.AndModuleBinding] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [doc (showString "and"), prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.AndModuleBinding where
  prt i = \case
    Language.Ocaml.Abs.AndModuleBinding attributes modulename modulebindingbody postitemattributes -> prPrec i 0 (concatD [prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, prt 0 postitemattributes])

instance Print Language.Ocaml.Abs.OptionalModuleType where
  prt i = \case
    Language.Ocaml.Abs.NoModuleType -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.AModuleType equal moduletype -> prPrec i 0 (concatD [prt 0 equal, prt 0 moduletype])

instance Print Language.Ocaml.Abs.ModuleTypeDeclaration where
  prt i = \case
    Language.Ocaml.Abs.ModuleTypeDeclaration ext attributes ocamlident optionalmoduletype postitemattributes -> prPrec i 0 (concatD [doc (showString "module"), doc (showString "type"), prt 0 ext, prt 0 attributes, prt 0 ocamlident, prt 0 optionalmoduletype, prt 0 postitemattributes])

instance Print Language.Ocaml.Abs.OpenDeclaration where
  prt i = \case
    Language.Ocaml.Abs.OpenDeclaration overrideflag ext attributes moduleexpr postitemattributes -> prPrec i 0 (concatD [doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, prt 0 postitemattributes])

instance Print Language.Ocaml.Abs.OpenDescription where
  prt i = \case
    Language.Ocaml.Abs.OpenDescription overrideflag ext attributes modextlongident postitemattributes -> prPrec i 0 (concatD [doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 modextlongident, prt 0 postitemattributes])

instance Print [Language.Ocaml.Abs.WithConstraint] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "and"), prt 0 xs]

instance Print Language.Ocaml.Abs.ModuleType where
  prt i = \case
    Language.Ocaml.Abs.ModuleTypeSignature attributes signature -> prPrec i 0 (concatD [doc (showString "sig"), prt 0 attributes, prt 0 signature, doc (showString "end")])
    Language.Ocaml.Abs.ModuleTypeFunctor attributes functorargs moduletype -> prPrec i 0 (concatD [doc (showString "functor"), prt 0 attributes, prt 0 functorargs, doc (showString "->"), prt 0 moduletype])
    Language.Ocaml.Abs.ModuleTypeOf attributes moduleexpr -> prPrec i 0 (concatD [doc (showString "module"), doc (showString "type"), doc (showString "of"), prt 0 attributes, prt 0 moduleexpr])
    Language.Ocaml.Abs.ModuleType moduletype -> prPrec i 0 (concatD [doc (showString "("), prt 0 moduletype, doc (showString ")")])
    Language.Ocaml.Abs.ModuleTypeWithAttribute moduletype attribute -> prPrec i 0 (concatD [prt 0 moduletype, prt 0 attribute])
    Language.Ocaml.Abs.ModuleTypeModuleIdent modlongident -> prPrec i 0 (concatD [prt 0 modlongident])
    Language.Ocaml.Abs.ModuleTypeNoArgFunctorApp moduletype -> prPrec i 0 (concatD [doc (showString "("), doc (showString ")"), doc (showString "->"), prt 0 moduletype])
    Language.Ocaml.Abs.ModuleTypeFunctorApp moduletype1 moduletype2 -> prPrec i 0 (concatD [prt 0 moduletype1, doc (showString "->"), prt 0 moduletype2])
    Language.Ocaml.Abs.ModuleTypeWith moduletype withconstraints -> prPrec i 0 (concatD [prt 0 moduletype, doc (showString "with"), prt 0 withconstraints])
    Language.Ocaml.Abs.ModuleTypeExtension extension -> prPrec i 0 (concatD [prt 0 extension])

instance Print Language.Ocaml.Abs.Signature where
  prt i = \case
    Language.Ocaml.Abs.Signature signatureelements -> prPrec i 0 (concatD [prt 0 signatureelements])

instance Print [Language.Ocaml.Abs.SignatureElement] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.SignatureElement where
  prt i = \case
    Language.Ocaml.Abs.SigSemiSemi -> prPrec i 0 (concatD [doc (showString ";;")])
    Language.Ocaml.Abs.SigItem signatureitem -> prPrec i 0 (concatD [prt 0 signatureitem])

instance Print Language.Ocaml.Abs.SignatureItem where
  prt i = \case
    Language.Ocaml.Abs.SigItemExtension itemextension postitemattributes -> prPrec i 0 (concatD [prt 0 itemextension, prt 0 postitemattributes])
    Language.Ocaml.Abs.SigFloatingAttribute floatingattribute -> prPrec i 0 (concatD [prt 0 floatingattribute])
    Language.Ocaml.Abs.SigValueDescription valuedescription -> prPrec i 0 (concatD [prt 0 valuedescription])
    Language.Ocaml.Abs.SigPrimitiveDeclaration primitivedeclaration -> prPrec i 0 (concatD [prt 0 primitivedeclaration])
    Language.Ocaml.Abs.SigTypeDeclarations typedeclaration andtypedeclarations -> prPrec i 0 (concatD [prt 0 typedeclaration, prt 0 andtypedeclarations])
    Language.Ocaml.Abs.SigTypeSubstDeclarations typesubstdeclarations -> prPrec i 0 (concatD [prt 0 typesubstdeclarations])
    Language.Ocaml.Abs.SigTypeExtension ext attributes typeparameters typelongident privateflag barllistextensionconstructordeclaration postitemattributes -> prPrec i 0 (concatD [doc (showString "type"), prt 0 ext, prt 0 attributes, prt 0 typeparameters, prt 0 typelongident, doc (showString "+="), prt 0 privateflag, prt 0 barllistextensionconstructordeclaration, prt 0 postitemattributes])
    Language.Ocaml.Abs.SigSigExceptionDeclaration sigexceptiondeclaration -> prPrec i 0 (concatD [prt 0 sigexceptiondeclaration])
    Language.Ocaml.Abs.SigModuleDeclaration ext attributes modulename moduledeclarationbody postitemattributes -> prPrec i 0 (concatD [doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 moduledeclarationbody, prt 0 postitemattributes])
    Language.Ocaml.Abs.SigModuleAlias ext attributes modulename equal modlongident postitemattributes -> prPrec i 0 (concatD [doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 equal, prt 0 modlongident, prt 0 postitemattributes])
    Language.Ocaml.Abs.SigModuleSubst modulesubst -> prPrec i 0 (concatD [prt 0 modulesubst])
    Language.Ocaml.Abs.SigRecModuleDeclarations ext attributes modulename moduletype postitemattributes andmoduledeclarations -> prPrec i 0 (concatD [doc (showString "module"), prt 0 ext, prt 0 attributes, doc (showString "rec"), prt 0 modulename, doc (showString ":"), prt 0 moduletype, prt 0 postitemattributes, prt 0 andmoduledeclarations])
    Language.Ocaml.Abs.SigModuleTypeDeclaration moduletypedeclaration -> prPrec i 0 (concatD [prt 0 moduletypedeclaration])
    Language.Ocaml.Abs.SigModuleTypeSubst moduletypesubst -> prPrec i 0 (concatD [prt 0 moduletypesubst])
    Language.Ocaml.Abs.SigOpenDescription opendescription -> prPrec i 0 (concatD [prt 0 opendescription])
    Language.Ocaml.Abs.SigIncludeStatement ext attributes moduletype postitemattributes -> prPrec i 0 (concatD [doc (showString "include"), prt 0 ext, prt 0 attributes, prt 0 moduletype, prt 0 postitemattributes])
    Language.Ocaml.Abs.SigClassDescription ext attributes virtualflag formalclassparameters lident classtype postitemattributes andclassdescriptions -> prPrec i 0 (concatD [doc (showString "class"), prt 0 ext, prt 0 attributes, prt 0 virtualflag, prt 0 formalclassparameters, prt 0 lident, doc (showString ":"), prt 0 classtype, prt 0 postitemattributes, prt 0 andclassdescriptions])
    Language.Ocaml.Abs.SigClassTypeDeclarations classtypedeclarations -> prPrec i 0 (concatD [prt 0 classtypedeclarations])

instance Print Language.Ocaml.Abs.ModuleDeclarationBody where
  prt i = \case
    Language.Ocaml.Abs.ModuleBody moduletype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 moduletype])
    Language.Ocaml.Abs.FunctorBody functorarg moduledeclarationbody -> prPrec i 0 (concatD [prt 0 functorarg, prt 0 moduledeclarationbody])

instance Print Language.Ocaml.Abs.ModuleSubst where
  prt i = \case
    Language.Ocaml.Abs.ModuleSubst ext attributes uident colonequal modextlongident postitemattributes -> prPrec i 0 (concatD [doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 uident, prt 0 colonequal, prt 0 modextlongident, prt 0 postitemattributes])

instance Print Language.Ocaml.Abs.AndModuleDeclaration where
  prt i = \case
    Language.Ocaml.Abs.AndModuleDeclaration attributes modulename moduletype postitemattributes -> prPrec i 0 (concatD [prt 0 attributes, prt 0 modulename, doc (showString ":"), prt 0 moduletype, prt 0 postitemattributes])

instance Print [Language.Ocaml.Abs.AndModuleDeclaration] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "and"), prt 0 xs]

instance Print Language.Ocaml.Abs.ModuleTypeSubst where
  prt i = \case
    Language.Ocaml.Abs.ModuleTypeSubst ext attributes ocamlident colonequal moduletype postitemattributes -> prPrec i 0 (concatD [doc (showString "module"), doc (showString "type"), prt 0 ext, prt 0 attributes, prt 0 ocamlident, prt 0 colonequal, prt 0 moduletype, prt 0 postitemattributes])

instance Print Language.Ocaml.Abs.AndClassDeclaration where
  prt i = \case
    Language.Ocaml.Abs.AndClassDeclaration attributes virtualflag formalclassparameters lident classfunbinding postitemattributes -> prPrec i 0 (concatD [doc (showString "and"), prt 0 attributes, prt 0 virtualflag, prt 0 formalclassparameters, prt 0 lident, prt 0 classfunbinding, prt 0 postitemattributes])

instance Print [Language.Ocaml.Abs.AndClassDeclaration] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.ClassFunBinding where
  prt i = \case
    Language.Ocaml.Abs.ClassFunBinding equal classexpr -> prPrec i 0 (concatD [prt 0 equal, prt 0 classexpr])
    Language.Ocaml.Abs.ClassFunBindingWithType classtype equal classexpr -> prPrec i 0 (concatD [doc (showString ":"), prt 0 classtype, prt 0 equal, prt 0 classexpr])
    Language.Ocaml.Abs.LabeledClassFunBinding labeledsimplepattern classfunbinding -> prPrec i 0 (concatD [prt 0 labeledsimplepattern, prt 0 classfunbinding])

instance Print Language.Ocaml.Abs.FormalClassParameters where
  prt i = \case
    Language.Ocaml.Abs.NoFormalClassParamters -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.FormalClassParameters typeparameters -> prPrec i 0 (concatD [doc (showString "["), prt 0 typeparameters, doc (showString "]")])

instance Print Language.Ocaml.Abs.ClassExpr where
  prt i = \case
    Language.Ocaml.Abs.ClassSimpleExpr classsimpleexpr -> prPrec i 0 (concatD [prt 0 classsimpleexpr])
    Language.Ocaml.Abs.ClassExprFunctor attributes classfundef -> prPrec i 0 (concatD [doc (showString "fun"), prt 0 attributes, prt 0 classfundef])
    Language.Ocaml.Abs.ClassExprLetBindings letbindingsnoext classexpr -> prPrec i 0 (concatD [prt 0 letbindingsnoext, doc (showString "in"), prt 0 classexpr])
    Language.Ocaml.Abs.ClassExprLetOpen overrideflag attributes modlongident classexpr -> prPrec i 0 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 attributes, prt 0 modlongident, doc (showString "in"), prt 0 classexpr])
    Language.Ocaml.Abs.ClassExprWithAttribute classexpr attribute -> prPrec i 0 (concatD [prt 0 classexpr, prt 0 attribute])
    Language.Ocaml.Abs.LabeledClassSimpleExpr classsimpleexpr labeledsimpleexprs -> prPrec i 0 (concatD [prt 0 classsimpleexpr, prt 0 labeledsimpleexprs])
    Language.Ocaml.Abs.ClassExprExtension extension -> prPrec i 0 (concatD [prt 0 extension])

instance Print Language.Ocaml.Abs.ClassSimpleExpr where
  prt i = \case
    Language.Ocaml.Abs.ClassExpr classexpr -> prPrec i 0 (concatD [doc (showString "("), prt 0 classexpr, doc (showString ")")])
    Language.Ocaml.Abs.ClassName classlongident -> prPrec i 0 (concatD [prt 0 classlongident])
    Language.Ocaml.Abs.ClassNameWithParamters coretypes classlongident -> prPrec i 0 (concatD [doc (showString "["), prt 0 coretypes, doc (showString "]"), prt 0 classlongident])
    Language.Ocaml.Abs.ClassExprWithType classexpr classtype -> prPrec i 0 (concatD [doc (showString "("), prt 0 classexpr, doc (showString ":"), prt 0 classtype, doc (showString ")")])
    Language.Ocaml.Abs.ClassSimplExprObject attributes classselfpattern classfields -> prPrec i 0 (concatD [doc (showString "object"), prt 0 attributes, prt 0 classselfpattern, prt 0 classfields, doc (showString "end")])

instance Print Language.Ocaml.Abs.ClassFunDef where
  prt i = \case
    Language.Ocaml.Abs.ClassFun labeledsimplepattern classexpr -> prPrec i 0 (concatD [prt 0 labeledsimplepattern, doc (showString "->"), prt 0 classexpr])
    Language.Ocaml.Abs.LabeledClassFunDef labeledsimplepattern classfundef -> prPrec i 0 (concatD [prt 0 labeledsimplepattern, prt 0 classfundef])

instance Print Language.Ocaml.Abs.ClassSelfPattern where
  prt i = \case
    Language.Ocaml.Abs.ClassPattern pattern_ -> prPrec i 0 (concatD [doc (showString "("), prt 0 pattern_, doc (showString ")")])
    Language.Ocaml.Abs.ClassPatternWithType pattern_ coretype -> prPrec i 0 (concatD [doc (showString "("), prt 0 pattern_, doc (showString ":"), prt 0 coretype, doc (showString ")")])
    Language.Ocaml.Abs.NoClassSelfPattern -> prPrec i 0 (concatD [])

instance Print [Language.Ocaml.Abs.ClassField] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.OptionalAs where
  prt i = \case
    Language.Ocaml.Abs.NoAs -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.AAs lident -> prPrec i 0 (concatD [doc (showString "as"), prt 0 lident])

instance Print Language.Ocaml.Abs.ClassField where
  prt i = \case
    Language.Ocaml.Abs.ClassFieldInherit overrideflag attributes classexpr optionalas postitemattributes -> prPrec i 0 (concatD [doc (showString "inherit"), prt 0 overrideflag, prt 0 attributes, prt 0 classexpr, prt 0 optionalas, prt 0 postitemattributes])
    Language.Ocaml.Abs.ClassFieldVal value postitemattributes -> prPrec i 0 (concatD [doc (showString "val"), prt 0 value, prt 0 postitemattributes])
    Language.Ocaml.Abs.ClassFieldMethod method postitemattributes -> prPrec i 0 (concatD [doc (showString "method"), prt 0 method, prt 0 postitemattributes])
    Language.Ocaml.Abs.ClassFieldConstraint attributes coretype1 equal coretype2 postitemattributes -> prPrec i 0 (concatD [doc (showString "constraint"), prt 0 attributes, prt 0 coretype1, prt 0 equal, prt 0 coretype2, prt 0 postitemattributes])
    Language.Ocaml.Abs.ClassFieldInitializer attributes seqexpr postitemattributes -> prPrec i 0 (concatD [doc (showString "initializer"), prt 0 attributes, prt 0 seqexpr, prt 0 postitemattributes])
    Language.Ocaml.Abs.ClassFieldItemExtension itemextension postitemattributes -> prPrec i 0 (concatD [prt 0 itemextension, prt 0 postitemattributes])
    Language.Ocaml.Abs.ClassFieldFloatingAttribute floatingattribute -> prPrec i 0 (concatD [prt 0 floatingattribute])

instance Print Language.Ocaml.Abs.Value where
  prt i = \case
    Language.Ocaml.Abs.Value1 nooverrideflag attributes virtualwithmutableflag lident coretype -> prPrec i 0 (concatD [prt 0 nooverrideflag, prt 0 attributes, prt 0 virtualwithmutableflag, prt 0 lident, doc (showString ":"), prt 0 coretype])
    Language.Ocaml.Abs.Value2 overrideflag attributes mutableflag lident equal seqexpr -> prPrec i 0 (concatD [prt 0 overrideflag, prt 0 attributes, prt 0 mutableflag, prt 0 lident, prt 0 equal, prt 0 seqexpr])
    Language.Ocaml.Abs.Value3 overrideflag attributes mutableflag lident typeconstraint equal seqexpr -> prPrec i 0 (concatD [prt 0 overrideflag, prt 0 attributes, prt 0 mutableflag, prt 0 lident, prt 0 typeconstraint, prt 0 equal, prt 0 seqexpr])

instance Print Language.Ocaml.Abs.Method_ where
  prt i = \case
    Language.Ocaml.Abs.VirtualMethod nooverrideflag attributes virtualwithprivateflag lident polytype -> prPrec i 0 (concatD [prt 0 nooverrideflag, prt 0 attributes, prt 0 virtualwithprivateflag, prt 0 lident, doc (showString ":"), prt 0 polytype])
    Language.Ocaml.Abs.Method overrideflag attributes privateflag lident strictbinding -> prPrec i 0 (concatD [prt 0 overrideflag, prt 0 attributes, prt 0 privateflag, prt 0 lident, prt 0 strictbinding])
    Language.Ocaml.Abs.MethodWithType overrideflag attributes privateflag lident polytype equal seqexpr -> prPrec i 0 (concatD [prt 0 overrideflag, prt 0 attributes, prt 0 privateflag, prt 0 lident, doc (showString ":"), prt 0 polytype, prt 0 equal, prt 0 seqexpr])
    Language.Ocaml.Abs.MethodWithLocallyAbstractType overrideflag attributes privateflag lident lidents coretype equal seqexpr -> prPrec i 0 (concatD [prt 0 overrideflag, prt 0 attributes, prt 0 privateflag, prt 0 lident, doc (showString ":"), doc (showString "type"), prt 0 lidents, doc (showString "."), prt 0 coretype, prt 0 equal, prt 0 seqexpr])

instance Print Language.Ocaml.Abs.ClassType where
  prt i = \case
    Language.Ocaml.Abs.ClassSignature classsignature -> prPrec i 0 (concatD [prt 0 classsignature])
    Language.Ocaml.Abs.ClassTypeWithOptLabel optlabel tupletype classtype -> prPrec i 0 (concatD [prt 0 optlabel, prt 0 tupletype, doc (showString "->"), prt 0 classtype])
    Language.Ocaml.Abs.ClassTypeWithOptionalLabel lident tupletype classtype -> prPrec i 0 (concatD [doc (showString "?"), prt 0 lident, doc (showString ":"), prt 0 tupletype, doc (showString "->"), prt 0 classtype])
    Language.Ocaml.Abs.ClassTypeWithtLabel lident tupletype classtype -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 tupletype, doc (showString "->"), prt 0 classtype])
    Language.Ocaml.Abs.ClassTypeWithoutLabel tupletype classtype -> prPrec i 0 (concatD [prt 0 tupletype, doc (showString "->"), prt 0 classtype])

instance Print Language.Ocaml.Abs.ClassSignature where
  prt i = \case
    Language.Ocaml.Abs.ClassSignatureName cltylongident -> prPrec i 0 (concatD [prt 0 cltylongident])
    Language.Ocaml.Abs.ClassSignatureNameWithParamters coretypes cltylongident -> prPrec i 0 (concatD [doc (showString "["), prt 0 coretypes, doc (showString "]"), prt 0 cltylongident])
    Language.Ocaml.Abs.ClassSignatureExtension extension -> prPrec i 0 (concatD [prt 0 extension])
    Language.Ocaml.Abs.ClassSignatureObject attributes classselftype classsigfields -> prPrec i 0 (concatD [doc (showString "object"), prt 0 attributes, prt 0 classselftype, prt 0 classsigfields, doc (showString "end")])
    Language.Ocaml.Abs.WithAttribute classsignature attribute -> prPrec i 0 (concatD [prt 0 classsignature, prt 0 attribute])
    Language.Ocaml.Abs.ClassSignatureLetOpen overrideflag attributes modlongident classsignature -> prPrec i 0 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 attributes, prt 0 modlongident, doc (showString "in"), prt 0 classsignature])

instance Print Language.Ocaml.Abs.ClassSelfType where
  prt i = \case
    Language.Ocaml.Abs.ClassSelfType coretype -> prPrec i 0 (concatD [doc (showString "("), prt 0 coretype, doc (showString ")")])
    Language.Ocaml.Abs.NoClassSelfType -> prPrec i 0 (concatD [])

instance Print Language.Ocaml.Abs.ClassSigField where
  prt i = \case
    Language.Ocaml.Abs.ClassSigFieldInherit attributes classsignature postitemattributes -> prPrec i 0 (concatD [doc (showString "inherit"), prt 0 attributes, prt 0 classsignature, prt 0 postitemattributes])
    Language.Ocaml.Abs.ClassSigFieldVal attributes mutablevirtualflags lident coretype postitemattributes -> prPrec i 0 (concatD [doc (showString "val"), prt 0 attributes, prt 0 mutablevirtualflags, prt 0 lident, doc (showString ":"), prt 0 coretype, prt 0 postitemattributes])
    Language.Ocaml.Abs.ClassSigFieldMethod attributes privatevirtualflags lident polytype postitemattributes -> prPrec i 0 (concatD [doc (showString "method"), prt 0 attributes, prt 0 privatevirtualflags, prt 0 lident, doc (showString ":"), prt 0 polytype, prt 0 postitemattributes])
    Language.Ocaml.Abs.ClassSigFieldConstraint attributes constrainfield postitemattributes -> prPrec i 0 (concatD [doc (showString "constraint"), prt 0 attributes, prt 0 constrainfield, prt 0 postitemattributes])
    Language.Ocaml.Abs.ClassSigFieldItemExtension itemextension postitemattributes -> prPrec i 0 (concatD [prt 0 itemextension, prt 0 postitemattributes])
    Language.Ocaml.Abs.ClassSigFieldFloatingAttribute floatingattribute -> prPrec i 0 (concatD [prt 0 floatingattribute])

instance Print Language.Ocaml.Abs.ConstrainField where
  prt i = \case
    Language.Ocaml.Abs.ConstrainField coretype1 equal coretype2 -> prPrec i 0 (concatD [prt 0 coretype1, prt 0 equal, prt 0 coretype2])

instance Print [Language.Ocaml.Abs.ClassSigField] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.AndClassDescription where
  prt i = \case
    Language.Ocaml.Abs.AndClassDescription attributes virtualflag formalclassparameters lident classtype postitemattributes -> prPrec i 0 (concatD [doc (showString "and"), prt 0 attributes, prt 0 virtualflag, prt 0 formalclassparameters, prt 0 lident, doc (showString ":"), prt 0 classtype, prt 0 postitemattributes])

instance Print [Language.Ocaml.Abs.AndClassDescription] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.ClassTypeDeclarations where
  prt i = \case
    Language.Ocaml.Abs.ClassTypeDeclarations ext attributes virtualflag formalclassparameters lident equal classsignature postitemattributes andclasstypedeclarations -> prPrec i 0 (concatD [doc (showString "class"), doc (showString "type"), prt 0 ext, prt 0 attributes, prt 0 virtualflag, prt 0 formalclassparameters, prt 0 lident, prt 0 equal, prt 0 classsignature, prt 0 postitemattributes, prt 0 andclasstypedeclarations])

instance Print Language.Ocaml.Abs.AndClassTypeDeclaration where
  prt i = \case
    Language.Ocaml.Abs.AndClassTypeDeclaration attributes virtualflag formalclassparameters lident equal classsignature postitemattributes -> prPrec i 0 (concatD [prt 0 attributes, prt 0 virtualflag, prt 0 formalclassparameters, prt 0 lident, prt 0 equal, prt 0 classsignature, prt 0 postitemattributes])

instance Print [Language.Ocaml.Abs.AndClassTypeDeclaration] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "and"), prt 0 xs]

instance Print Language.Ocaml.Abs.SeqExpr where
  prt i = \case
    Language.Ocaml.Abs.FinalFunExpr funexpr -> prPrec i 0 (concatD [prt 1 funexpr])
    Language.Ocaml.Abs.FinalFunExprSemi funexpr -> prPrec i 0 (concatD [prt 1 funexpr, doc (showString ";")])
    Language.Ocaml.Abs.MoreFunExprs funexpr seqexpr -> prPrec i 0 (concatD [prt 1 funexpr, doc (showString ";"), prt 0 seqexpr])
    Language.Ocaml.Abs.MoreFunExprsAttr funexpr percent attrids seqexpr -> prPrec i 0 (concatD [prt 1 funexpr, doc (showString ";"), prt 0 percent, prt 0 attrids, prt 0 seqexpr])
    Language.Ocaml.Abs.SeqExprFunction ext attributes matchcases -> prPrec i 0 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])

instance Print Language.Ocaml.Abs.LabeledSimplePattern where
  prt i = \case
    Language.Ocaml.Abs.OptPattern labelletpattern -> prPrec i 0 (concatD [doc (showString "?"), doc (showString "("), prt 0 labelletpattern, doc (showString ")")])
    Language.Ocaml.Abs.OptPatternWithDefault labelletpattern equal seqexpr -> prPrec i 0 (concatD [doc (showString "?"), doc (showString "("), prt 0 labelletpattern, prt 0 equal, prt 0 seqexpr, doc (showString ")")])
    Language.Ocaml.Abs.OptLabel lident -> prPrec i 0 (concatD [doc (showString "?"), prt 0 lident])
    Language.Ocaml.Abs.OptLabeledPattern optlabel letpattern -> prPrec i 0 (concatD [prt 0 optlabel, doc (showString "("), prt 0 letpattern, doc (showString ")")])
    Language.Ocaml.Abs.OptLabeledPatternWithDefault optlabel letpattern equal seqexpr -> prPrec i 0 (concatD [prt 0 optlabel, doc (showString "("), prt 0 letpattern, prt 0 equal, prt 0 seqexpr, doc (showString ")")])
    Language.Ocaml.Abs.OptLabeledVar optlabel patternvar -> prPrec i 0 (concatD [prt 0 optlabel, prt 0 patternvar])
    Language.Ocaml.Abs.LabeledPattern labelletpattern -> prPrec i 0 (concatD [doc (showString "~"), doc (showString "("), prt 0 labelletpattern, doc (showString ")")])
    Language.Ocaml.Abs.Label lident -> prPrec i 0 (concatD [doc (showString "~"), prt 0 lident])
    Language.Ocaml.Abs.LabeledSimplePattern label simplepattern -> prPrec i 0 (concatD [prt 0 label, prt 0 simplepattern])
    Language.Ocaml.Abs.SimplePattern simplepattern -> prPrec i 0 (concatD [prt 0 simplepattern])

instance Print Language.Ocaml.Abs.PatternVar where
  prt i = \case
    Language.Ocaml.Abs.PatternVar lident -> prPrec i 0 (concatD [prt 0 lident])
    Language.Ocaml.Abs.UnderscorePatternVar -> prPrec i 0 (concatD [doc (showString "_")])

instance Print Language.Ocaml.Abs.LabelLetPattern where
  prt i = \case
    Language.Ocaml.Abs.LabelVar lident -> prPrec i 0 (concatD [prt 0 lident])
    Language.Ocaml.Abs.LabelVarWithType lident coretype -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 coretype])

instance Print Language.Ocaml.Abs.LetPattern where
  prt i = \case
    Language.Ocaml.Abs.LetPattern pattern_ -> prPrec i 0 (concatD [prt 0 pattern_])
    Language.Ocaml.Abs.LetPatternWithType pattern_ coretype -> prPrec i 0 (concatD [prt 0 pattern_, doc (showString ":"), prt 0 coretype])

instance Print Language.Ocaml.Abs.QualifiedDotop where
  prt i = \case
    Language.Ocaml.Abs.Unqualified dotop -> prPrec i 0 (concatD [prt 0 dotop])
    Language.Ocaml.Abs.Qualified modlongident dotop -> prPrec i 0 (concatD [doc (showString "."), prt 0 modlongident, prt 0 dotop])

instance Print Language.Ocaml.Abs.OptionalAtomicTypeAnnotation where
  prt i = \case
    Language.Ocaml.Abs.NoAtomicTypeAnnotation -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.AnAtomicTypeAnnotation atomictype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 atomictype])

instance Print Language.Ocaml.Abs.FunExpr where
  prt i = \case
    Language.Ocaml.Abs.SimpleExprApp simpleexpr labeledsimpleexprs -> prPrec i 15 (concatD [prt 16 simpleexpr, prt 0 labeledsimpleexprs])
    Language.Ocaml.Abs.ConstrApp constrlongident simpleexpr -> prPrec i 15 (concatD [prt 0 constrlongident, prt 16 simpleexpr])
    Language.Ocaml.Abs.NameTagApp nametag simpleexpr -> prPrec i 15 (concatD [prt 0 nametag, prt 16 simpleexpr])
    Language.Ocaml.Abs.Assert ext attributes simpleexpr -> prPrec i 15 (concatD [doc (showString "assert"), prt 0 ext, prt 0 attributes, prt 16 simpleexpr])
    Language.Ocaml.Abs.Lazy ext attributes simpleexpr -> prPrec i 15 (concatD [doc (showString "lazy"), prt 0 ext, prt 0 attributes, prt 16 simpleexpr])
    Language.Ocaml.Abs.SimpleExpr simpleexpr -> prPrec i 15 (concatD [prt 16 simpleexpr])
    Language.Ocaml.Abs.Subtractive subtractive expr -> prPrec i 14 (concatD [prt 0 subtractive, prt 15 expr])
    Language.Ocaml.Abs.Additive additive expr -> prPrec i 14 (concatD [prt 0 additive, prt 15 expr])
    Language.Ocaml.Abs.PowInfix funexpr powop expr -> prPrec i 13 (concatD [prt 14 funexpr, prt 0 powop, prt 13 expr])
    Language.Ocaml.Abs.MultDivInfix funexpr multdivop expr -> prPrec i 12 (concatD [prt 12 funexpr, prt 0 multdivop, prt 13 expr])
    Language.Ocaml.Abs.MultInfix funexpr star expr -> prPrec i 12 (concatD [prt 12 funexpr, prt 0 star, prt 13 expr])
    Language.Ocaml.Abs.ModInfix funexpr percent expr -> prPrec i 12 (concatD [prt 12 funexpr, prt 0 percent, prt 13 expr])
    Language.Ocaml.Abs.PlusMinusInfix funexpr plusminusop expr -> prPrec i 11 (concatD [prt 11 funexpr, prt 0 plusminusop, prt 12 expr])
    Language.Ocaml.Abs.PlusInfix funexpr plus expr -> prPrec i 11 (concatD [prt 11 funexpr, prt 0 plus, prt 12 expr])
    Language.Ocaml.Abs.PlusDotInfix funexpr expr -> prPrec i 11 (concatD [prt 11 funexpr, doc (showString "+."), prt 12 expr])
    Language.Ocaml.Abs.MinusInfix funexpr minus expr -> prPrec i 11 (concatD [prt 11 funexpr, prt 0 minus, prt 12 expr])
    Language.Ocaml.Abs.MinusDotInfix funexpr expr -> prPrec i 11 (concatD [prt 11 funexpr, doc (showString "-."), prt 12 expr])
    Language.Ocaml.Abs.Cons funexpr expr -> prPrec i 10 (concatD [prt 11 funexpr, doc (showString "::"), prt 10 expr])
    Language.Ocaml.Abs.ConcatInfix funexpr concatop expr -> prPrec i 9 (concatD [prt 10 funexpr, prt 0 concatop, prt 9 expr])
    Language.Ocaml.Abs.RelInfix funexpr relop expr -> prPrec i 8 (concatD [prt 8 funexpr, prt 0 relop, prt 9 expr])
    Language.Ocaml.Abs.EqualInfix funexpr equal expr -> prPrec i 8 (concatD [prt 8 funexpr, prt 0 equal, prt 9 expr])
    Language.Ocaml.Abs.LessInfix funexpr less expr -> prPrec i 8 (concatD [prt 8 funexpr, prt 0 less, prt 9 expr])
    Language.Ocaml.Abs.GreaterInfix funexpr greater expr -> prPrec i 8 (concatD [prt 8 funexpr, prt 0 greater, prt 9 expr])
    Language.Ocaml.Abs.AmpersandInfix funexpr ampersand expr -> prPrec i 7 (concatD [prt 8 funexpr, prt 0 ampersand, prt 7 expr])
    Language.Ocaml.Abs.AmperAmperInfix funexpr amperamper expr -> prPrec i 7 (concatD [prt 8 funexpr, prt 0 amperamper, prt 7 expr])
    Language.Ocaml.Abs.OrInfix funexpr or expr -> prPrec i 6 (concatD [prt 7 funexpr, prt 0 or, prt 6 expr])
    Language.Ocaml.Abs.BarBarInfix funexpr barbar expr -> prPrec i 6 (concatD [prt 7 funexpr, prt 0 barbar, prt 6 expr])
    Language.Ocaml.Abs.Comma expr exprcommas -> prPrec i 5 (concatD [prt 6 expr, doc (showString ","), prt 0 exprcommas])
    Language.Ocaml.Abs.UpdateExpr lident expr -> prPrec i 4 (concatD [prt 0 lident, doc (showString "<-"), prt 0 expr])
    Language.Ocaml.Abs.AssignInfix funexpr colonequal expr -> prPrec i 4 (concatD [prt 5 funexpr, prt 0 colonequal, prt 0 expr])
    Language.Ocaml.Abs.QualifiedDot simpleexpr labellongident expr -> prPrec i 4 (concatD [prt 17 simpleexpr, doc (showString "."), prt 0 labellongident, doc (showString "<-"), prt 0 expr])
    Language.Ocaml.Abs.ArrayUpdateExpr simpleexpr seqexpr expr -> prPrec i 4 (concatD [prt 17 simpleexpr, doc (showString "."), doc (showString "("), prt 0 seqexpr, doc (showString ")"), doc (showString "<-"), prt 0 expr])
    Language.Ocaml.Abs.StringUpdateExpr simpleexpr seqexpr expr -> prPrec i 4 (concatD [prt 17 simpleexpr, doc (showString "."), doc (showString "["), prt 0 seqexpr, doc (showString "]"), doc (showString "<-"), prt 0 expr])
    Language.Ocaml.Abs.BigArrayUpdateExpr simpleexpr seqexpr expr -> prPrec i 4 (concatD [prt 17 simpleexpr, doc (showString "."), doc (showString "{"), prt 0 seqexpr, doc (showString "}"), doc (showString "<-"), prt 0 expr])
    Language.Ocaml.Abs.ParenDotopUpdateExpr simpleexpr qualifieddotop exprs expr -> prPrec i 4 (concatD [prt 17 simpleexpr, prt 0 qualifieddotop, doc (showString "("), prt 0 exprs, doc (showString ")"), doc (showString "<-"), prt 0 expr])
    Language.Ocaml.Abs.BracketDotopUpdateExpr simpleexpr qualifieddotop exprs expr -> prPrec i 4 (concatD [prt 17 simpleexpr, prt 0 qualifieddotop, doc (showString "["), prt 0 exprs, doc (showString "]"), doc (showString "<-"), prt 0 expr])
    Language.Ocaml.Abs.BraceDotopUpdateExpr simpleexpr qualifieddotop exprs expr -> prPrec i 4 (concatD [prt 17 simpleexpr, prt 0 qualifieddotop, doc (showString "{"), prt 0 exprs, doc (showString "}"), doc (showString "<-"), prt 0 expr])
    Language.Ocaml.Abs.IfElse ext attributes seqexpr expr1 expr2 -> prPrec i 3 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Language.Ocaml.Abs.If ext attributes seqexpr expr -> prPrec i 3 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Language.Ocaml.Abs.Let letbindingsext seqexpr -> prPrec i 1 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpBinding letop letopbindings seqexpr -> prPrec i 1 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetModule ext attributes modulename modulebindingbody seqexpr -> prPrec i 1 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetException ext attributes1 constrident generalizedconstructorarguments attributes2 seqexpr -> prPrec i 1 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes1, prt 0 constrident, prt 0 generalizedconstructorarguments, prt 0 attributes2, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpen overrideflag ext attributes moduleexpr seqexpr -> prPrec i 1 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.Fun ext attributes funparams optionalatomictypeannotation funbody -> prPrec i 1 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparams, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Language.Ocaml.Abs.Match ext attributes seqexpr matchcases -> prPrec i 1 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.Try ext attributes seqexpr matchcases -> prPrec i 1 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.While ext attributes seqexpr1 seqexpr2 -> prPrec i 1 (concatD [doc (showString "while"), prt 0 ext, prt 0 attributes, prt 0 seqexpr1, doc (showString "do"), prt 0 seqexpr2, doc (showString "done")])
    Language.Ocaml.Abs.For ext attributes pattern_ equal seqexpr1 directionflag seqexpr2 seqexpr3 -> prPrec i 1 (concatD [doc (showString "for"), prt 0 ext, prt 0 attributes, prt 0 pattern_, prt 0 equal, prt 0 seqexpr1, prt 0 directionflag, prt 0 seqexpr2, doc (showString "do"), prt 0 seqexpr3, doc (showString "done")])
    Language.Ocaml.Abs.FunExprWithAttribute funexpr attribute -> prPrec i 1 (concatD [prt 2 funexpr, prt 0 attribute])

instance Print Language.Ocaml.Abs.Expr where
  prt i = \case
    Language.Ocaml.Abs.Function15 ext attributes matchcases -> prPrec i 15 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Language.Ocaml.Abs.Let15 letbindingsext seqexpr -> prPrec i 15 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpBinding15 letop letopbindings seqexpr -> prPrec i 15 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetModule15 ext attributes modulename modulebindingbody seqexpr -> prPrec i 15 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetException15 ext attributes1 constrident generalizedconstructorarguments attributes2 seqexpr -> prPrec i 15 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes1, prt 0 constrident, prt 0 generalizedconstructorarguments, prt 0 attributes2, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpen15 overrideflag ext attributes moduleexpr seqexpr -> prPrec i 15 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.Fun15 ext attributes funparams optionalatomictypeannotation funbody -> prPrec i 15 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparams, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Language.Ocaml.Abs.Match15 ext attributes seqexpr matchcases -> prPrec i 15 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.Try15 ext attributes seqexpr matchcases -> prPrec i 15 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.IfElse15 ext attributes seqexpr expr1 expr2 -> prPrec i 15 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Language.Ocaml.Abs.If15 ext attributes seqexpr expr -> prPrec i 15 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Language.Ocaml.Abs.FunExpr15 funexpr -> prPrec i 15 (concatD [prt 15 funexpr])
    Language.Ocaml.Abs.Function13 ext attributes matchcases -> prPrec i 13 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Language.Ocaml.Abs.Let13 letbindingsext seqexpr -> prPrec i 13 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpBinding13 letop letopbindings seqexpr -> prPrec i 13 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetModule13 ext attributes modulename modulebindingbody seqexpr -> prPrec i 13 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetException13 ext attributes1 constrident generalizedconstructorarguments attributes2 seqexpr -> prPrec i 13 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes1, prt 0 constrident, prt 0 generalizedconstructorarguments, prt 0 attributes2, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpen13 overrideflag ext attributes moduleexpr seqexpr -> prPrec i 13 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.Fun13 ext attributes funparams optionalatomictypeannotation funbody -> prPrec i 13 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparams, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Language.Ocaml.Abs.Match13 ext attributes seqexpr matchcases -> prPrec i 13 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.Try13 ext attributes seqexpr matchcases -> prPrec i 13 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.IfElse13 ext attributes seqexpr expr1 expr2 -> prPrec i 13 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Language.Ocaml.Abs.If13 ext attributes seqexpr expr -> prPrec i 13 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Language.Ocaml.Abs.FunExpr13 funexpr -> prPrec i 13 (concatD [prt 13 funexpr])
    Language.Ocaml.Abs.Function12 ext attributes matchcases -> prPrec i 12 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Language.Ocaml.Abs.Let12 letbindingsext seqexpr -> prPrec i 12 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpBinding12 letop letopbindings seqexpr -> prPrec i 12 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetModule12 ext attributes modulename modulebindingbody seqexpr -> prPrec i 12 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetException12 ext attributes1 constrident generalizedconstructorarguments attributes2 seqexpr -> prPrec i 12 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes1, prt 0 constrident, prt 0 generalizedconstructorarguments, prt 0 attributes2, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpen12 overrideflag ext attributes moduleexpr seqexpr -> prPrec i 12 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.Fun12 ext attributes funparams optionalatomictypeannotation funbody -> prPrec i 12 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparams, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Language.Ocaml.Abs.Match12 ext attributes seqexpr matchcases -> prPrec i 12 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.Try12 ext attributes seqexpr matchcases -> prPrec i 12 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.IfElse12 ext attributes seqexpr expr1 expr2 -> prPrec i 12 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Language.Ocaml.Abs.If12 ext attributes seqexpr expr -> prPrec i 12 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Language.Ocaml.Abs.FunExpr12 funexpr -> prPrec i 12 (concatD [prt 12 funexpr])
    Language.Ocaml.Abs.Function11 ext attributes matchcases -> prPrec i 11 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Language.Ocaml.Abs.Let11 letbindingsext seqexpr -> prPrec i 11 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpBinding11 letop letopbindings seqexpr -> prPrec i 11 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetModule11 ext attributes modulename modulebindingbody seqexpr -> prPrec i 11 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetException11 ext attributes1 constrident generalizedconstructorarguments attributes2 seqexpr -> prPrec i 11 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes1, prt 0 constrident, prt 0 generalizedconstructorarguments, prt 0 attributes2, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpen11 overrideflag ext attributes moduleexpr seqexpr -> prPrec i 11 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.Fun11 ext attributes funparams optionalatomictypeannotation funbody -> prPrec i 11 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparams, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Language.Ocaml.Abs.Match11 ext attributes seqexpr matchcases -> prPrec i 11 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.Try11 ext attributes seqexpr matchcases -> prPrec i 11 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.IfElse11 ext attributes seqexpr expr1 expr2 -> prPrec i 11 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Language.Ocaml.Abs.If11 ext attributes seqexpr expr -> prPrec i 11 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Language.Ocaml.Abs.FunExpr11 funexpr -> prPrec i 11 (concatD [prt 11 funexpr])
    Language.Ocaml.Abs.Function10 ext attributes matchcases -> prPrec i 10 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Language.Ocaml.Abs.Let10 letbindingsext seqexpr -> prPrec i 10 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpBinding10 letop letopbindings seqexpr -> prPrec i 10 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetModule10 ext attributes modulename modulebindingbody seqexpr -> prPrec i 10 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetException10 ext attributes1 constrident generalizedconstructorarguments attributes2 seqexpr -> prPrec i 10 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes1, prt 0 constrident, prt 0 generalizedconstructorarguments, prt 0 attributes2, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpen10 overrideflag ext attributes moduleexpr seqexpr -> prPrec i 10 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.Fun10 ext attributes funparams optionalatomictypeannotation funbody -> prPrec i 10 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparams, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Language.Ocaml.Abs.Match10 ext attributes seqexpr matchcases -> prPrec i 10 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.Try10 ext attributes seqexpr matchcases -> prPrec i 10 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.IfElse10 ext attributes seqexpr expr1 expr2 -> prPrec i 10 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Language.Ocaml.Abs.If10 ext attributes seqexpr expr -> prPrec i 10 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Language.Ocaml.Abs.FunExpr10 funexpr -> prPrec i 10 (concatD [prt 10 funexpr])
    Language.Ocaml.Abs.Function9 ext attributes matchcases -> prPrec i 9 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Language.Ocaml.Abs.Let9 letbindingsext seqexpr -> prPrec i 9 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpBinding9 letop letopbindings seqexpr -> prPrec i 9 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetModule9 ext attributes modulename modulebindingbody seqexpr -> prPrec i 9 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetException9 ext attributes1 constrident generalizedconstructorarguments attributes2 seqexpr -> prPrec i 9 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes1, prt 0 constrident, prt 0 generalizedconstructorarguments, prt 0 attributes2, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpen9 overrideflag ext attributes moduleexpr seqexpr -> prPrec i 9 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.Fun9 ext attributes funparams optionalatomictypeannotation funbody -> prPrec i 9 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparams, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Language.Ocaml.Abs.Match9 ext attributes seqexpr matchcases -> prPrec i 9 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.Try9 ext attributes seqexpr matchcases -> prPrec i 9 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.IfElse9 ext attributes seqexpr expr1 expr2 -> prPrec i 9 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Language.Ocaml.Abs.If9 ext attributes seqexpr expr -> prPrec i 9 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Language.Ocaml.Abs.FunExpr9 funexpr -> prPrec i 9 (concatD [prt 9 funexpr])
    Language.Ocaml.Abs.Function7 ext attributes matchcases -> prPrec i 7 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Language.Ocaml.Abs.Let7 letbindingsext seqexpr -> prPrec i 7 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpBinding7 letop letopbindings seqexpr -> prPrec i 7 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetModule7 ext attributes modulename modulebindingbody seqexpr -> prPrec i 7 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetException7 ext attributes1 constrident generalizedconstructorarguments attributes2 seqexpr -> prPrec i 7 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes1, prt 0 constrident, prt 0 generalizedconstructorarguments, prt 0 attributes2, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpen7 overrideflag ext attributes moduleexpr seqexpr -> prPrec i 7 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.Fun7 ext attributes funparams optionalatomictypeannotation funbody -> prPrec i 7 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparams, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Language.Ocaml.Abs.Match7 ext attributes seqexpr matchcases -> prPrec i 7 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.Try7 ext attributes seqexpr matchcases -> prPrec i 7 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.IfElse7 ext attributes seqexpr expr1 expr2 -> prPrec i 7 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Language.Ocaml.Abs.If7 ext attributes seqexpr expr -> prPrec i 7 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Language.Ocaml.Abs.FunExpr7 funexpr -> prPrec i 7 (concatD [prt 7 funexpr])
    Language.Ocaml.Abs.Function6 ext attributes matchcases -> prPrec i 6 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Language.Ocaml.Abs.Let6 letbindingsext seqexpr -> prPrec i 6 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpBinding6 letop letopbindings seqexpr -> prPrec i 6 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetModule6 ext attributes modulename modulebindingbody seqexpr -> prPrec i 6 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetException6 ext attributes1 constrident generalizedconstructorarguments attributes2 seqexpr -> prPrec i 6 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes1, prt 0 constrident, prt 0 generalizedconstructorarguments, prt 0 attributes2, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.LetOpen6 overrideflag ext attributes moduleexpr seqexpr -> prPrec i 6 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Language.Ocaml.Abs.Fun6 ext attributes funparams optionalatomictypeannotation funbody -> prPrec i 6 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparams, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Language.Ocaml.Abs.Match6 ext attributes seqexpr matchcases -> prPrec i 6 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.Try6 ext attributes seqexpr matchcases -> prPrec i 6 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Language.Ocaml.Abs.IfElse6 ext attributes seqexpr expr1 expr2 -> prPrec i 6 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Language.Ocaml.Abs.If6 ext attributes seqexpr expr -> prPrec i 6 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Language.Ocaml.Abs.FunExpr6 funexpr -> prPrec i 6 (concatD [prt 6 funexpr])
    Language.Ocaml.Abs.Function ext attributes matchcases -> prPrec i 0 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Language.Ocaml.Abs.FunExpr1 funexpr -> prPrec i 0 (concatD [prt 1 funexpr])

instance Print Language.Ocaml.Abs.SimpleExpr where
  prt i = \case
    Language.Ocaml.Abs.SeqExpr seqexpr -> prPrec i 19 (concatD [doc (showString "("), prt 0 seqexpr, doc (showString ")")])
    Language.Ocaml.Abs.SeqExprWithType seqexpr typeconstraint -> prPrec i 19 (concatD [doc (showString "("), prt 0 seqexpr, prt 0 typeconstraint, doc (showString ")")])
    Language.Ocaml.Abs.ValLongident vallongident -> prPrec i 19 (concatD [prt 0 vallongident])
    Language.Ocaml.Abs.Constant constant -> prPrec i 19 (concatD [prt 0 constant])
    Language.Ocaml.Abs.ConstrName constrlongident -> prPrec i 19 (concatD [prt 0 constrlongident])
    Language.Ocaml.Abs.NameTagExpr nametag -> prPrec i 19 (concatD [prt 0 nametag])
    Language.Ocaml.Abs.ListExpr exprs -> prPrec i 19 (concatD [doc (showString "["), prt 0 exprs, doc (showString "]")])
    Language.Ocaml.Abs.RecordExpr recordexprcontent -> prPrec i 19 (concatD [doc (showString "{"), prt 0 recordexprcontent, doc (showString "}")])
    Language.Ocaml.Abs.EmptyArrayExpr -> prPrec i 19 (concatD [doc (showString "[|"), doc (showString "|]")])
    Language.Ocaml.Abs.ArrayExpr exprs -> prPrec i 19 (concatD [doc (showString "[|"), prt 0 exprs, doc (showString "|]")])
    Language.Ocaml.Abs.EmptyObjectExpr -> prPrec i 19 (concatD [doc (showString "{<"), doc (showString ">}")])
    Language.Ocaml.Abs.ObjectExpr objectexprfields -> prPrec i 19 (concatD [doc (showString "{<"), prt 0 objectexprfields, doc (showString ">}")])
    Language.Ocaml.Abs.LocalOpenUnit modlongident -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "("), doc (showString ")")])
    Language.Ocaml.Abs.LocalOpenExpr modlongident seqexpr -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "("), prt 0 seqexpr, doc (showString ")")])
    Language.Ocaml.Abs.LocalOpenEmptyListExpr modlongident -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "["), doc (showString "]")])
    Language.Ocaml.Abs.LocalOpenListExpr modlongident exprs -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "["), prt 0 exprs, doc (showString "]")])
    Language.Ocaml.Abs.LocalOpenRecordExpr modlongident recordexprcontent -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "{"), prt 0 recordexprcontent, doc (showString "}")])
    Language.Ocaml.Abs.LocalOpenEmptyArrayExpr modlongident -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "[|"), doc (showString "|]")])
    Language.Ocaml.Abs.LocalOpenArrayExpr modlongident exprs -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "[|"), prt 0 exprs, doc (showString "|]")])
    Language.Ocaml.Abs.LocalOpenObjectExpr modlongident objectexprfields -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "{<"), prt 0 objectexprfields, doc (showString ">}")])
    Language.Ocaml.Abs.LocalOpenModule modlongident ext attributes moduleexpr moduletype -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "("), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString ":"), prt 0 moduletype, doc (showString ")")])
    Language.Ocaml.Abs.BeginEnd ext attributes seqexpr -> prPrec i 19 (concatD [doc (showString "begin"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "end")])
    Language.Ocaml.Abs.EmptyBeginEnd ext attributes -> prPrec i 19 (concatD [doc (showString "begin"), prt 0 ext, prt 0 attributes, doc (showString "end")])
    Language.Ocaml.Abs.New ext attributes classlongident -> prPrec i 19 (concatD [doc (showString "new"), prt 0 ext, prt 0 attributes, prt 0 classlongident])
    Language.Ocaml.Abs.Module ext attributes moduleexpr -> prPrec i 19 (concatD [doc (showString "("), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString ")")])
    Language.Ocaml.Abs.ModuleWithType ext attributes moduleexpr moduletype -> prPrec i 19 (concatD [doc (showString "("), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString ":"), prt 0 moduletype, doc (showString ")")])
    Language.Ocaml.Abs.Object ext attributes classselfpattern classfields -> prPrec i 19 (concatD [doc (showString "object"), prt 0 ext, prt 0 attributes, prt 0 classselfpattern, prt 0 classfields, doc (showString "end")])
    Language.Ocaml.Abs.Extension extension -> prPrec i 19 (concatD [prt 0 extension])
    Language.Ocaml.Abs.PrefixApp prefixop simpleexpr -> prPrec i 18 (concatD [prt 0 prefixop, prt 19 simpleexpr])
    Language.Ocaml.Abs.BangApp bang simpleexpr -> prPrec i 18 (concatD [prt 0 bang, prt 19 simpleexpr])
    Language.Ocaml.Abs.RecordAccessExpr simpleexpr labellongident -> prPrec i 17 (concatD [prt 17 simpleexpr, doc (showString "."), prt 0 labellongident])
    Language.Ocaml.Abs.ArrayAccessExpr simpleexpr seqexpr -> prPrec i 17 (concatD [prt 17 simpleexpr, doc (showString "."), doc (showString "("), prt 0 seqexpr, doc (showString ")")])
    Language.Ocaml.Abs.StringAccessExpr simpleexpr seqexpr -> prPrec i 17 (concatD [prt 17 simpleexpr, doc (showString "."), doc (showString "["), prt 0 seqexpr, doc (showString "]")])
    Language.Ocaml.Abs.BigArrayAccessExpr simpleexpr seqexpr -> prPrec i 17 (concatD [prt 17 simpleexpr, doc (showString "."), doc (showString "{"), prt 0 seqexpr, doc (showString "}")])
    Language.Ocaml.Abs.ParenDotopAccessExpr simpleexpr qualifieddotop exprs -> prPrec i 17 (concatD [prt 17 simpleexpr, prt 0 qualifieddotop, doc (showString "("), prt 0 exprs, doc (showString ")")])
    Language.Ocaml.Abs.BracketDotopAccessExpr simpleexpr qualifieddotop exprs -> prPrec i 17 (concatD [prt 17 simpleexpr, prt 0 qualifieddotop, doc (showString "["), prt 0 exprs, doc (showString "]")])
    Language.Ocaml.Abs.BraceDotopAccessExpr simpleexpr qualifieddotop exprs -> prPrec i 17 (concatD [prt 17 simpleexpr, prt 0 qualifieddotop, doc (showString "{"), prt 0 exprs, doc (showString "}")])
    Language.Ocaml.Abs.MethodInvocation simpleexpr lident -> prPrec i 16 (concatD [prt 16 simpleexpr, doc (showString "#"), prt 0 lident])
    Language.Ocaml.Abs.HashOp simpleexpr1 hashop simpleexpr2 -> prPrec i 16 (concatD [prt 16 simpleexpr1, prt 0 hashop, prt 17 simpleexpr2])

instance Print [Language.Ocaml.Abs.LabeledSimpleExpr] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.LabeledSimpleExpr where
  prt i = \case
    Language.Ocaml.Abs.ExprWithoutLabel simpleexpr -> prPrec i 0 (concatD [prt 16 simpleexpr])
    Language.Ocaml.Abs.LabeledExpr label simpleexpr -> prPrec i 0 (concatD [prt 0 label, prt 16 simpleexpr])
    Language.Ocaml.Abs.LabeExpr lident -> prPrec i 0 (concatD [doc (showString "~"), prt 0 lident])
    Language.Ocaml.Abs.LabelWithTypExpr lident typeconstraint -> prPrec i 0 (concatD [doc (showString "~"), doc (showString "("), prt 0 lident, prt 0 typeconstraint, doc (showString ")")])
    Language.Ocaml.Abs.OptLabelExpr lident -> prPrec i 0 (concatD [doc (showString "?"), prt 0 lident])
    Language.Ocaml.Abs.OptLabeledExpr optlabel simpleexpr -> prPrec i 0 (concatD [prt 0 optlabel, prt 16 simpleexpr])

instance Print Language.Ocaml.Abs.LetBindingBodyNoPunning where
  prt i = \case
    Language.Ocaml.Abs.StrictBinding valident strictbinding -> prPrec i 0 (concatD [prt 0 valident, prt 0 strictbinding])
    Language.Ocaml.Abs.BindingWithMonoType valident typeconstraint equal seqexpr -> prPrec i 0 (concatD [prt 0 valident, prt 0 typeconstraint, prt 0 equal, prt 0 seqexpr])
    Language.Ocaml.Abs.BindingWithPolyType valident typevars coretype equal seqexpr -> prPrec i 0 (concatD [prt 0 valident, doc (showString ":"), prt 0 typevars, doc (showString "."), prt 0 coretype, prt 0 equal, prt 0 seqexpr])
    Language.Ocaml.Abs.BindingWithLocallyAbstractType valident lidents coretype equal seqexpr -> prPrec i 0 (concatD [prt 0 valident, doc (showString ":"), doc (showString "type"), prt 0 lidents, doc (showString "."), prt 0 coretype, prt 0 equal, prt 0 seqexpr])
    Language.Ocaml.Abs.PatternBinding patternnoexn equal seqexpr -> prPrec i 0 (concatD [prt 0 patternnoexn, prt 0 equal, prt 0 seqexpr])
    Language.Ocaml.Abs.PatternBindingWithType simplepatternnotident coretype equal seqexpr -> prPrec i 0 (concatD [prt 0 simplepatternnotident, doc (showString ":"), prt 0 coretype, prt 0 equal, prt 0 seqexpr])

instance Print Language.Ocaml.Abs.LetBindingBody where
  prt i = \case
    Language.Ocaml.Abs.LetBindingBodyNoPunning letbindingbodynopunning -> prPrec i 0 (concatD [prt 0 letbindingbodynopunning])

instance Print Language.Ocaml.Abs.LetBindingsNoExt where
  prt i = \case
    Language.Ocaml.Abs.SingleLetBindingNoExt attributes recflag letbindingbody postitemattributes -> prPrec i 0 (concatD [doc (showString "let"), prt 0 attributes, prt 0 recflag, prt 0 letbindingbody, prt 0 postitemattributes])
    Language.Ocaml.Abs.MultipleLetBindingNoExt letbindingsnoext andletbinding -> prPrec i 0 (concatD [prt 0 letbindingsnoext, prt 0 andletbinding])

instance Print Language.Ocaml.Abs.LetBindingsExt where
  prt i = \case
    Language.Ocaml.Abs.SingleLetBindingExt ext attributes recflag letbindingbody postitemattributes -> prPrec i 0 (concatD [doc (showString "let"), prt 0 ext, prt 0 attributes, prt 0 recflag, prt 0 letbindingbody, prt 0 postitemattributes])
    Language.Ocaml.Abs.MultipleLetBindingExt letbindingsext andletbinding -> prPrec i 0 (concatD [prt 0 letbindingsext, prt 0 andletbinding])

instance Print Language.Ocaml.Abs.AndLetBinding where
  prt i = \case
    Language.Ocaml.Abs.AndLetBinding attributes letbindingbody postitemattributes -> prPrec i 0 (concatD [doc (showString "and"), prt 0 attributes, prt 0 letbindingbody, prt 0 postitemattributes])

instance Print Language.Ocaml.Abs.LetopBindingBody where
  prt i = \case
    Language.Ocaml.Abs.LetopStrictBinding valident strictbinding -> prPrec i 0 (concatD [prt 0 valident, prt 0 strictbinding])
    Language.Ocaml.Abs.LetopValIdent valident -> prPrec i 0 (concatD [prt 0 valident])
    Language.Ocaml.Abs.LetopPatternBindingWithType simplepattern coretype equal seqexpr -> prPrec i 0 (concatD [prt 0 simplepattern, doc (showString ":"), prt 0 coretype, prt 0 equal, prt 0 seqexpr])
    Language.Ocaml.Abs.LetopPatternBinding patternnoexn equal seqexpr -> prPrec i 0 (concatD [prt 0 patternnoexn, prt 0 equal, prt 0 seqexpr])

instance Print Language.Ocaml.Abs.LetopBindings where
  prt i = \case
    Language.Ocaml.Abs.BindingBody letopbindingbody -> prPrec i 0 (concatD [prt 0 letopbindingbody])
    Language.Ocaml.Abs.AndOpBinding letopbindings andop letopbindingbody -> prPrec i 0 (concatD [prt 0 letopbindings, prt 0 andop, prt 0 letopbindingbody])

instance Print Language.Ocaml.Abs.StrictBinding where
  prt i = \case
    Language.Ocaml.Abs.Binding equal seqexpr -> prPrec i 0 (concatD [prt 0 equal, prt 0 seqexpr])
    Language.Ocaml.Abs.FunParams funparams optionaltypeconstraint equal funbody -> prPrec i 0 (concatD [prt 0 funparams, prt 0 optionaltypeconstraint, prt 0 equal, prt 0 funbody])

instance Print Language.Ocaml.Abs.FunBody where
  prt i = \case
    Language.Ocaml.Abs.FunBodyFunction ext attributes matchcases -> prPrec i 0 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Language.Ocaml.Abs.FunBodyFinalFunExpr funexpr -> prPrec i 0 (concatD [prt 1 funexpr])
    Language.Ocaml.Abs.FunBodyFinalFunExprSemi funexpr -> prPrec i 0 (concatD [prt 1 funexpr, doc (showString ";")])
    Language.Ocaml.Abs.FunBodyMoreFunExprs funexpr seqexpr -> prPrec i 0 (concatD [prt 1 funexpr, doc (showString ";"), prt 0 seqexpr])
    Language.Ocaml.Abs.FunBodyMoreFunExprsAttr funexpr percent attrids seqexpr -> prPrec i 0 (concatD [prt 1 funexpr, doc (showString ";"), prt 0 percent, prt 0 attrids, prt 0 seqexpr])

instance Print [Language.Ocaml.Abs.MatchCase] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "|"), prt 0 xs]

instance Print Language.Ocaml.Abs.MatchCase where
  prt i = \case
    Language.Ocaml.Abs.MatchCase pattern_ seqexpr -> prPrec i 0 (concatD [prt 0 pattern_, doc (showString "->"), prt 0 seqexpr])
    Language.Ocaml.Abs.GuardedMatchCase pattern_ seqexpr1 seqexpr2 -> prPrec i 0 (concatD [prt 0 pattern_, doc (showString "when"), prt 0 seqexpr1, doc (showString "->"), prt 0 seqexpr2])
    Language.Ocaml.Abs.UnreachableMatchCase pattern_ -> prPrec i 0 (concatD [prt 0 pattern_, doc (showString "->"), doc (showString ".")])

instance Print Language.Ocaml.Abs.FunParam where
  prt i = \case
    Language.Ocaml.Abs.LocallyAbstractTypeParam lidents -> prPrec i 0 (concatD [doc (showString "("), doc (showString "type"), prt 0 lidents, doc (showString ")")])
    Language.Ocaml.Abs.Param labeledsimplepattern -> prPrec i 0 (concatD [prt 0 labeledsimplepattern])

instance Print [Language.Ocaml.Abs.FunParam] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.ExprComma where
  prt i = \case
    Language.Ocaml.Abs.ExprComma expr -> prPrec i 0 (concatD [prt 0 expr])

instance Print [Language.Ocaml.Abs.ExprComma] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Language.Ocaml.Abs.RecordExprFields where
  prt i = \case
    Language.Ocaml.Abs.FinalRecordExprField1 recordexprfield -> prPrec i 0 (concatD [prt 0 recordexprfield])
    Language.Ocaml.Abs.FinalRecordExprField2 recordexprfield -> prPrec i 0 (concatD [prt 0 recordexprfield, doc (showString ";")])
    Language.Ocaml.Abs.MoreRecordExprFields recordexprfield recordexprfields -> prPrec i 0 (concatD [prt 0 recordexprfield, doc (showString ";"), prt 0 recordexprfields])

instance Print Language.Ocaml.Abs.RecordExprContent where
  prt i = \case
    Language.Ocaml.Abs.RecordExprContent1 simpleexpr recordexprfields -> prPrec i 0 (concatD [prt 0 simpleexpr, doc (showString "with"), prt 0 recordexprfields])
    Language.Ocaml.Abs.RecordExprContent2 recordexprfields -> prPrec i 0 (concatD [prt 0 recordexprfields])

instance Print Language.Ocaml.Abs.OptionalTypeConstraint where
  prt i = \case
    Language.Ocaml.Abs.NoTypeConstraint -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.ATypeConstraint typeconstraint -> prPrec i 0 (concatD [prt 0 typeconstraint])

instance Print Language.Ocaml.Abs.RecordExprField where
  prt i = \case
    Language.Ocaml.Abs.RecordExprField labellongident optionaltypeconstraint optionalassignexpr -> prPrec i 0 (concatD [prt 0 labellongident, prt 0 optionaltypeconstraint, prt 0 optionalassignexpr])

instance Print [Language.Ocaml.Abs.ObjectExprField] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ [x] = concatD [prt 0 x, doc (showString ";")]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print Language.Ocaml.Abs.OptionalAssignExpr where
  prt i = \case
    Language.Ocaml.Abs.NoAssign -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.AnAssign equal expr -> prPrec i 0 (concatD [prt 0 equal, prt 0 expr])

instance Print Language.Ocaml.Abs.ObjectExprField where
  prt i = \case
    Language.Ocaml.Abs.ObjectExprField lident optionalassignexpr -> prPrec i 0 (concatD [prt 0 lident, prt 0 optionalassignexpr])

instance Print [Language.Ocaml.Abs.Expr] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ [x] = concatD [prt 0 x, doc (showString ";")]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print Language.Ocaml.Abs.TypeConstraint where
  prt i = \case
    Language.Ocaml.Abs.TypeConstraint coretype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 coretype])
    Language.Ocaml.Abs.CoercionFromTo coretype1 coretype2 -> prPrec i 0 (concatD [doc (showString ":"), prt 0 coretype1, doc (showString ":>"), prt 0 coretype2])
    Language.Ocaml.Abs.CoercionTo coretype -> prPrec i 0 (concatD [doc (showString ":>"), prt 0 coretype])

instance Print Language.Ocaml.Abs.Pattern where
  prt i = \case
    Language.Ocaml.Abs.ConsPattern pattern_1 pattern_2 -> prPrec i 0 (concatD [prt 0 pattern_1, doc (showString "::"), prt 0 pattern_2])
    Language.Ocaml.Abs.PatternWithAttribute pattern_ attribute -> prPrec i 0 (concatD [prt 0 pattern_, prt 0 attribute])
    Language.Ocaml.Abs.PatternGen patterngen -> prPrec i 0 (concatD [prt 0 patterngen])
    Language.Ocaml.Abs.AsPattern pattern_ valident -> prPrec i 0 (concatD [prt 0 pattern_, doc (showString "as"), prt 0 valident])
    Language.Ocaml.Abs.TuplePattern patterncommalistpattern -> prPrec i 0 (concatD [prt 0 patterncommalistpattern])
    Language.Ocaml.Abs.OrPattern pattern_1 pattern_2 -> prPrec i 0 (concatD [prt 0 pattern_1, doc (showString "|"), prt 0 pattern_2])
    Language.Ocaml.Abs.ExceptionPattern ext attributes pattern_ -> prPrec i 0 (concatD [doc (showString "exception"), prt 0 ext, prt 0 attributes, prt 0 pattern_])

instance Print Language.Ocaml.Abs.PatternNoExn where
  prt i = \case
    Language.Ocaml.Abs.ConsPatternNoExn patternnoexn pattern_ -> prPrec i 0 (concatD [prt 0 patternnoexn, doc (showString "::"), prt 0 pattern_])
    Language.Ocaml.Abs.PatternWithAttributeNoExn patternnoexn attribute -> prPrec i 0 (concatD [prt 0 patternnoexn, prt 0 attribute])
    Language.Ocaml.Abs.PatternGenNoExn patterngen -> prPrec i 0 (concatD [prt 0 patterngen])
    Language.Ocaml.Abs.AsPatternNoExn patternnoexn valident -> prPrec i 0 (concatD [prt 0 patternnoexn, doc (showString "as"), prt 0 valident])
    Language.Ocaml.Abs.TuplePatternNoExn patterncommalistpatternnoexn -> prPrec i 0 (concatD [prt 0 patterncommalistpatternnoexn])
    Language.Ocaml.Abs.OrPatternNoExn patternnoexn pattern_ -> prPrec i 0 (concatD [prt 0 patternnoexn, doc (showString "|"), prt 0 pattern_])

instance Print [Language.Ocaml.Abs.LIDENT] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.PatternGen where
  prt i = \case
    Language.Ocaml.Abs.SimplePatternGen simplepattern -> prPrec i 0 (concatD [prt 0 simplepattern])
    Language.Ocaml.Abs.ConstrPattern constrlongident pattern_ -> prPrec i 0 (concatD [prt 0 constrlongident, prt 0 pattern_])
    Language.Ocaml.Abs.ConstrPatternWithLocallyAbstractType constrlongident lidents simplepattern -> prPrec i 0 (concatD [prt 0 constrlongident, doc (showString "("), doc (showString "type"), prt 0 lidents, doc (showString ")"), prt 0 simplepattern])
    Language.Ocaml.Abs.TagPatternGen nametag pattern_ -> prPrec i 0 (concatD [prt 0 nametag, prt 0 pattern_])
    Language.Ocaml.Abs.LazyPattern ext attributes simplepattern -> prPrec i 0 (concatD [doc (showString "lazy"), prt 0 ext, prt 0 attributes, prt 0 simplepattern])

instance Print Language.Ocaml.Abs.SimplePattern where
  prt i = \case
    Language.Ocaml.Abs.ValIdent valident -> prPrec i 0 (concatD [prt 0 valident])
    Language.Ocaml.Abs.SimplePatternNotIdent simplepatternnotident -> prPrec i 0 (concatD [prt 0 simplepatternnotident])

instance Print Language.Ocaml.Abs.SimplePatternNotIdent where
  prt i = \case
    Language.Ocaml.Abs.Pattern pattern_ -> prPrec i 0 (concatD [doc (showString "("), prt 0 pattern_, doc (showString ")")])
    Language.Ocaml.Abs.SimpleDelimitedPattern simpledelimitedpattern -> prPrec i 0 (concatD [prt 0 simpledelimitedpattern])
    Language.Ocaml.Abs.ModulePattern ext attributes modulename -> prPrec i 0 (concatD [doc (showString "("), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, doc (showString ")")])
    Language.Ocaml.Abs.ModulePatternWithType ext attributes modulename packagetype -> prPrec i 0 (concatD [doc (showString "("), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, doc (showString ":"), prt 0 packagetype, doc (showString ")")])
    Language.Ocaml.Abs.UnderscorePattern -> prPrec i 0 (concatD [doc (showString "_")])
    Language.Ocaml.Abs.ConstantPattern signedconstant -> prPrec i 0 (concatD [prt 0 signedconstant])
    Language.Ocaml.Abs.RangePattern signedconstant1 signedconstant2 -> prPrec i 0 (concatD [prt 0 signedconstant1, doc (showString ".."), prt 0 signedconstant2])
    Language.Ocaml.Abs.ConstrNamePattern constrlongident -> prPrec i 0 (concatD [prt 0 constrlongident])
    Language.Ocaml.Abs.TagPattern nametag -> prPrec i 0 (concatD [prt 0 nametag])
    Language.Ocaml.Abs.TypeConstrPattern typelongident -> prPrec i 0 (concatD [doc (showString "#"), prt 0 typelongident])
    Language.Ocaml.Abs.DotPattern modlongident simpledelimitedpattern -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), prt 0 simpledelimitedpattern])
    Language.Ocaml.Abs.EmptyStringPattern modlongident -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "["), doc (showString "]")])
    Language.Ocaml.Abs.EmptyArrayPattern_ modlongident -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "("), doc (showString ")")])
    Language.Ocaml.Abs.ArrayPattern_ modlongident pattern_ -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "("), prt 0 pattern_, doc (showString ")")])
    Language.Ocaml.Abs.PatternWithType pattern_ coretype -> prPrec i 0 (concatD [doc (showString "("), prt 0 pattern_, doc (showString ":"), prt 0 coretype, doc (showString ")")])
    Language.Ocaml.Abs.ExtensionPattern extension -> prPrec i 0 (concatD [prt 0 extension])

instance Print Language.Ocaml.Abs.SimpleDelimitedPattern where
  prt i = \case
    Language.Ocaml.Abs.RecordPattern recordpatcontent -> prPrec i 0 (concatD [doc (showString "{"), prt 0 recordpatcontent, doc (showString "}")])
    Language.Ocaml.Abs.ListPattern patterns -> prPrec i 0 (concatD [doc (showString "["), prt 0 patterns, doc (showString "]")])
    Language.Ocaml.Abs.ArrayPattern patterns -> prPrec i 0 (concatD [doc (showString "[|"), prt 0 patterns, doc (showString "|]")])
    Language.Ocaml.Abs.EmptyArrayPattern -> prPrec i 0 (concatD [doc (showString "[|"), doc (showString "|]")])

instance Print Language.Ocaml.Abs.PatternCommaListPattern where
  prt i = \case
    Language.Ocaml.Abs.MorePattern patterncommalistpattern pattern_ -> prPrec i 0 (concatD [prt 0 patterncommalistpattern, doc (showString ","), prt 0 pattern_])
    Language.Ocaml.Abs.TwoPattern pattern_1 pattern_2 -> prPrec i 0 (concatD [prt 0 pattern_1, doc (showString ","), prt 0 pattern_2])

instance Print Language.Ocaml.Abs.PatternCommaListPatternNoExn where
  prt i = \case
    Language.Ocaml.Abs.MorePatternNoExn patterncommalistpatternnoexn pattern_ -> prPrec i 0 (concatD [prt 0 patterncommalistpatternnoexn, doc (showString ","), prt 0 pattern_])
    Language.Ocaml.Abs.TwoPatternNoExn patternnoexn pattern_ -> prPrec i 0 (concatD [prt 0 patternnoexn, doc (showString ","), prt 0 pattern_])

instance Print [Language.Ocaml.Abs.Pattern] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ [x] = concatD [prt 0 x, doc (showString ";")]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print Language.Ocaml.Abs.OptionalSemi where
  prt i = \case
    Language.Ocaml.Abs.NoSemi -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.ASemi -> prPrec i 0 (concatD [doc (showString ";")])

instance Print Language.Ocaml.Abs.RecordPatContent where
  prt i = \case
    Language.Ocaml.Abs.FinalRecordPattern recordpatfield optionalsemi -> prPrec i 0 (concatD [prt 0 recordpatfield, prt 0 optionalsemi])
    Language.Ocaml.Abs.UnderscoreRecordPattern recordpatfield optionalsemi -> prPrec i 0 (concatD [prt 0 recordpatfield, doc (showString ";"), doc (showString "_"), prt 0 optionalsemi])
    Language.Ocaml.Abs.MoreRecordPatterns recordpatfield recordpatcontent -> prPrec i 0 (concatD [prt 0 recordpatfield, doc (showString ";"), prt 0 recordpatcontent])

instance Print Language.Ocaml.Abs.OptionalCoreType where
  prt i = \case
    Language.Ocaml.Abs.NoCoreType -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.ACoreType coretype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 coretype])

instance Print Language.Ocaml.Abs.OptionalAssignPattern where
  prt i = \case
    Language.Ocaml.Abs.NoAssignPattern -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.AnAssignPattern equal pattern_ -> prPrec i 0 (concatD [prt 0 equal, prt 0 pattern_])

instance Print Language.Ocaml.Abs.RecordPatField where
  prt i = \case
    Language.Ocaml.Abs.RecordPatField labellongident optionalcoretype optionalassignpattern -> prPrec i 0 (concatD [prt 0 labellongident, prt 0 optionalcoretype, prt 0 optionalassignpattern])

instance Print Language.Ocaml.Abs.ValueDescription where
  prt i = \case
    Language.Ocaml.Abs.ValueDescription ext attributes valident polytype postitemattributes -> prPrec i 0 (concatD [doc (showString "val"), prt 0 ext, prt 0 attributes, prt 0 valident, doc (showString ":"), prt 0 polytype, prt 0 postitemattributes])

instance Print [Language.Ocaml.Abs.STRING] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.PrimitiveDeclaration where
  prt i = \case
    Language.Ocaml.Abs.PrimitiveDeclaration ext attributes valident polytype equal strings postitemattributes -> prPrec i 0 (concatD [doc (showString "external"), prt 0 ext, prt 0 attributes, prt 0 valident, doc (showString ":"), prt 0 polytype, prt 0 equal, prt 0 strings, prt 0 postitemattributes])

instance Print Language.Ocaml.Abs.AndTypeDeclaration where
  prt i = \case
    Language.Ocaml.Abs.AndTypeDeclaration attributes typeparameters lident typekind constraints postitemattributes -> prPrec i 0 (concatD [doc (showString "and"), prt 0 attributes, prt 0 typeparameters, prt 0 lident, prt 0 typekind, prt 0 constraints, prt 0 postitemattributes])

instance Print [Language.Ocaml.Abs.AndTypeDeclaration] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.TypeSubstDeclarations where
  prt i = \case
    Language.Ocaml.Abs.TypeSubstDeclarations typesubstdeclaration andtypesubstdeclarations -> prPrec i 0 (concatD [prt 0 typesubstdeclaration, prt 0 andtypesubstdeclarations])

instance Print Language.Ocaml.Abs.AndTypeSubstDeclaration where
  prt i = \case
    Language.Ocaml.Abs.AndTypeSubstDeclaration attributes typeparameters lident typesubstkind constraints postitemattributes -> prPrec i 0 (concatD [doc (showString "and"), prt 0 attributes, prt 0 typeparameters, prt 0 lident, prt 0 typesubstkind, prt 0 constraints, prt 0 postitemattributes])

instance Print [Language.Ocaml.Abs.AndTypeSubstDeclaration] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "and"), prt 0 xs]

instance Print Language.Ocaml.Abs.TypeDeclaration where
  prt i = \case
    Language.Ocaml.Abs.NonrecTypeDeclaration ext attributes typeparameters lident typekind constraints postitemattributes -> prPrec i 0 (concatD [doc (showString "type"), prt 0 ext, prt 0 attributes, doc (showString "nonrec"), prt 0 typeparameters, prt 0 lident, prt 0 typekind, prt 0 constraints, prt 0 postitemattributes])
    Language.Ocaml.Abs.TypeDeclaration ext attributes typeparameters lident typekind constraints postitemattributes -> prPrec i 0 (concatD [doc (showString "type"), prt 0 ext, prt 0 attributes, prt 0 typeparameters, prt 0 lident, prt 0 typekind, prt 0 constraints, prt 0 postitemattributes])

instance Print Language.Ocaml.Abs.TypeSubstDeclaration where
  prt i = \case
    Language.Ocaml.Abs.TypeSubstDeclaration ext attributes typeparameters lident typesubstkind constraints postitemattributes -> prPrec i 0 (concatD [doc (showString "type"), prt 0 ext, prt 0 attributes, prt 0 typeparameters, prt 0 lident, prt 0 typesubstkind, prt 0 constraints, prt 0 postitemattributes])

instance Print Language.Ocaml.Abs.Constraint where
  prt i = \case
    Language.Ocaml.Abs.Constraint coretype1 equal coretype2 -> prPrec i 0 (concatD [doc (showString "constraint"), prt 0 coretype1, prt 0 equal, prt 0 coretype2])

instance Print [Language.Ocaml.Abs.Constraint] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.NonemptyTypeKind where
  prt i = \case
    Language.Ocaml.Abs.AbstractType coretype -> prPrec i 0 (concatD [prt 0 coretype])
    Language.Ocaml.Abs.VariantType constructordeclarations -> prPrec i 0 (concatD [prt 0 constructordeclarations])
    Language.Ocaml.Abs.OpenType -> prPrec i 0 (concatD [doc (showString "..")])
    Language.Ocaml.Abs.RecordType labeldeclarations -> prPrec i 0 (concatD [doc (showString "{"), prt 0 labeldeclarations, doc (showString "}")])
    Language.Ocaml.Abs.PrivateAbstractType coretype -> prPrec i 0 (concatD [doc (showString "private"), prt 0 coretype])
    Language.Ocaml.Abs.PrivateVariantType constructordeclarations -> prPrec i 0 (concatD [doc (showString "private"), prt 0 constructordeclarations])
    Language.Ocaml.Abs.PrivateOpenType -> prPrec i 0 (concatD [doc (showString "private"), doc (showString "..")])
    Language.Ocaml.Abs.PrivateRecordType labeldeclarations -> prPrec i 0 (concatD [doc (showString "private"), doc (showString "{"), prt 0 labeldeclarations, doc (showString "}")])
    Language.Ocaml.Abs.TypeSynonymVariantType coretype equal constructordeclarations -> prPrec i 0 (concatD [prt 0 coretype, prt 0 equal, prt 0 constructordeclarations])
    Language.Ocaml.Abs.TypeSynonymPrivateVariantType coretype equal constructordeclarations -> prPrec i 0 (concatD [prt 0 coretype, prt 0 equal, doc (showString "private"), prt 0 constructordeclarations])
    Language.Ocaml.Abs.TypeSynonymOpenType coretype equal -> prPrec i 0 (concatD [prt 0 coretype, prt 0 equal, doc (showString "..")])
    Language.Ocaml.Abs.TypeSynonymPrivateOpenType coretype equal -> prPrec i 0 (concatD [prt 0 coretype, prt 0 equal, doc (showString "private"), doc (showString "..")])
    Language.Ocaml.Abs.TypeSynonymRecordType coretype equal labeldeclarations -> prPrec i 0 (concatD [prt 0 coretype, prt 0 equal, doc (showString "{"), prt 0 labeldeclarations, doc (showString "}")])
    Language.Ocaml.Abs.TypeSynonymPrivateRecordType coretype equal labeldeclarations -> prPrec i 0 (concatD [prt 0 coretype, prt 0 equal, doc (showString "private"), doc (showString "{"), prt 0 labeldeclarations, doc (showString "}")])

instance Print Language.Ocaml.Abs.TypeKind where
  prt i = \case
    Language.Ocaml.Abs.NoTypeKind -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.TypeKind equal nonemptytypekind -> prPrec i 0 (concatD [prt 0 equal, prt 0 nonemptytypekind])

instance Print Language.Ocaml.Abs.TypeSubstKind where
  prt i = \case
    Language.Ocaml.Abs.TypeSubstKind colonequal nonemptytypekind -> prPrec i 0 (concatD [prt 0 colonequal, prt 0 nonemptytypekind])

instance Print Language.Ocaml.Abs.TypeParameters where
  prt i = \case
    Language.Ocaml.Abs.NoTypeParameters -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.SingleTypeParameter typeparameter -> prPrec i 0 (concatD [prt 0 typeparameter])
    Language.Ocaml.Abs.TypeParameters typeparameters -> prPrec i 0 (concatD [doc (showString "("), prt 0 typeparameters, doc (showString ")")])

instance Print [Language.Ocaml.Abs.TypeParameter] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Language.Ocaml.Abs.TypeParameter where
  prt i = \case
    Language.Ocaml.Abs.TypeParameter typevariance typevariable -> prPrec i 0 (concatD [prt 0 typevariance, prt 0 typevariable])

instance Print Language.Ocaml.Abs.TypeVariable where
  prt i = \case
    Language.Ocaml.Abs.TypeVariable ocamlident -> prPrec i 0 (concatD [doc (showString "'"), prt 0 ocamlident])
    Language.Ocaml.Abs.Underscore -> prPrec i 0 (concatD [doc (showString "_")])

instance Print Language.Ocaml.Abs.TypeVariance where
  prt i = \case
    Language.Ocaml.Abs.NoVarianceNoInjectivity -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.CovariantNoInjectivity plus -> prPrec i 0 (concatD [prt 0 plus])
    Language.Ocaml.Abs.ContravariantNoInjectivity minus -> prPrec i 0 (concatD [prt 0 minus])
    Language.Ocaml.Abs.NoVarianceInjective bang -> prPrec i 0 (concatD [prt 0 bang])
    Language.Ocaml.Abs.CovariantInjective -> prPrec i 0 (concatD [doc (showString "+!")])
    Language.Ocaml.Abs.InjectiveCovariant -> prPrec i 0 (concatD [doc (showString "!+")])
    Language.Ocaml.Abs.ContravariantInjective -> prPrec i 0 (concatD [doc (showString "-!")])
    Language.Ocaml.Abs.InjectiveContravariant -> prPrec i 0 (concatD [doc (showString "!-")])
    Language.Ocaml.Abs.InfixOpVariance plusminusop -> prPrec i 0 (concatD [prt 0 plusminusop])
    Language.Ocaml.Abs.PrefixOpVariance prefixop -> prPrec i 0 (concatD [prt 0 prefixop])

instance Print [Language.Ocaml.Abs.ConstructorDeclaration] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "|"), prt 0 xs]

instance Print Language.Ocaml.Abs.ConstructorDeclarations where
  prt i = \case
    Language.Ocaml.Abs.EmptyConstructorDeclarations -> prPrec i 0 (concatD [doc (showString "|")])
    Language.Ocaml.Abs.BarConstructorDeclarations constructordeclarations -> prPrec i 0 (concatD [doc (showString "|"), prt 0 constructordeclarations])
    Language.Ocaml.Abs.ConstructorDeclarations constructordeclarations -> prPrec i 0 (concatD [prt 0 constructordeclarations])

instance Print Language.Ocaml.Abs.ConstructorDeclaration where
  prt i = \case
    Language.Ocaml.Abs.ConstructorDeclaration constrident generalizedconstructorarguments attributes -> prPrec i 0 (concatD [prt 0 constrident, prt 0 generalizedconstructorarguments, prt 0 attributes])

instance Print Language.Ocaml.Abs.StrExceptionDeclaration where
  prt i = \case
    Language.Ocaml.Abs.SigStrExceptionDeclaration sigexceptiondeclaration -> prPrec i 0 (concatD [prt 0 sigexceptiondeclaration])
    Language.Ocaml.Abs.Exception ext attributes1 constrident equal constrlongident attributes2 postitemattributes -> prPrec i 0 (concatD [doc (showString "exception"), prt 0 ext, prt 0 attributes1, prt 0 constrident, prt 0 equal, prt 0 constrlongident, prt 0 attributes2, prt 0 postitemattributes])

instance Print Language.Ocaml.Abs.SigExceptionDeclaration where
  prt i = \case
    Language.Ocaml.Abs.SigExceptionDeclaration ext attributes1 constrident generalizedconstructorarguments attributes2 postitemattributes -> prPrec i 0 (concatD [doc (showString "exception"), prt 0 ext, prt 0 attributes1, prt 0 constrident, prt 0 generalizedconstructorarguments, prt 0 attributes2, prt 0 postitemattributes])

instance Print Language.Ocaml.Abs.GeneralizedConstructorArguments where
  prt i = \case
    Language.Ocaml.Abs.NoGeneralizedConstructorArguments -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.GeneralizedConstructorArguments1 constructorarguments -> prPrec i 0 (concatD [doc (showString "of"), prt 0 constructorarguments])
    Language.Ocaml.Abs.GeneralizedConstructorArguments2 constructorarguments atomictype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 constructorarguments, doc (showString "->"), prt 0 atomictype])
    Language.Ocaml.Abs.GeneralizedConstructorArguments3 typevars constructorarguments atomictype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 typevars, doc (showString "."), prt 0 constructorarguments, doc (showString "->"), prt 0 atomictype])
    Language.Ocaml.Abs.GeneralizedConstructorArguments4 atomictype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 atomictype])
    Language.Ocaml.Abs.GeneralizedConstructorArguments5 typevars atomictype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 typevars, doc (showString "."), prt 0 atomictype])

instance Print Language.Ocaml.Abs.ConstructorArguments where
  prt i = \case
    Language.Ocaml.Abs.Arg1 tupletype -> prPrec i 0 (concatD [prt 0 tupletype])
    Language.Ocaml.Abs.Arg2 labeldeclarations -> prPrec i 0 (concatD [doc (showString "{"), prt 0 labeldeclarations, doc (showString "}")])

instance Print Language.Ocaml.Abs.LabelDeclarations where
  prt i = \case
    Language.Ocaml.Abs.FinalLabelDeclaration labeldeclaration -> prPrec i 0 (concatD [prt 0 labeldeclaration])
    Language.Ocaml.Abs.FinalLabelDeclarationSemi labeldeclarationsemi -> prPrec i 0 (concatD [prt 0 labeldeclarationsemi])
    Language.Ocaml.Abs.MoreLabelDeclarations labeldeclarationsemi labeldeclarations -> prPrec i 0 (concatD [prt 0 labeldeclarationsemi, prt 0 labeldeclarations])

instance Print Language.Ocaml.Abs.LabelDeclaration where
  prt i = \case
    Language.Ocaml.Abs.LabelDeclarationMonoType mutableflag lident aliastype attributes -> prPrec i 0 (concatD [prt 0 mutableflag, prt 0 lident, doc (showString ":"), prt 0 aliastype, prt 0 attributes])
    Language.Ocaml.Abs.LabelDeclarationPolyType mutableflag lident typevars aliastype attributes -> prPrec i 0 (concatD [prt 0 mutableflag, prt 0 lident, doc (showString ":"), prt 0 typevars, doc (showString "."), prt 0 aliastype, prt 0 attributes])

instance Print Language.Ocaml.Abs.LabelDeclarationSemi where
  prt i = \case
    Language.Ocaml.Abs.LabelDeclarationSemiMonoType mutableflag lident aliastype attributes1 attributes2 -> prPrec i 0 (concatD [prt 0 mutableflag, prt 0 lident, doc (showString ":"), prt 0 aliastype, prt 0 attributes1, doc (showString ";"), prt 0 attributes2])
    Language.Ocaml.Abs.LabelDeclarationSemiPolyType mutableflag lident typevars aliastype attributes1 attributes2 -> prPrec i 0 (concatD [prt 0 mutableflag, prt 0 lident, doc (showString ":"), prt 0 typevars, doc (showString "."), prt 0 aliastype, prt 0 attributes1, doc (showString ";"), prt 0 attributes2])

instance Print Language.Ocaml.Abs.BarLlistExtensionConstructor where
  prt i = \case
    Language.Ocaml.Abs.NoExtensionConstructors -> prPrec i 0 (concatD [doc (showString "|")])
    Language.Ocaml.Abs.BarExtensionConstructors extensionconstructors -> prPrec i 0 (concatD [doc (showString "|"), prt 0 extensionconstructors])
    Language.Ocaml.Abs.ExtensionConstructors extensionconstructors -> prPrec i 0 (concatD [prt 0 extensionconstructors])

instance Print [Language.Ocaml.Abs.ExtensionConstructor] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "|"), prt 0 xs]

instance Print Language.Ocaml.Abs.BarLlistExtensionConstructorDeclaration where
  prt i = \case
    Language.Ocaml.Abs.NoConstructor -> prPrec i 0 (concatD [doc (showString "|")])
    Language.Ocaml.Abs.Constructor extensionconstructordeclarations -> prPrec i 0 (concatD [doc (showString "|"), prt 0 extensionconstructordeclarations])

instance Print [Language.Ocaml.Abs.ExtensionConstructorDeclaration] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "|"), prt 0 xs]

instance Print Language.Ocaml.Abs.ExtensionConstructor where
  prt i = \case
    Language.Ocaml.Abs.Declaration extensionconstructordeclaration -> prPrec i 0 (concatD [prt 0 extensionconstructordeclaration])
    Language.Ocaml.Abs.Rebind extensionconstructorrebind -> prPrec i 0 (concatD [prt 0 extensionconstructorrebind])

instance Print Language.Ocaml.Abs.ExtensionConstructorDeclaration where
  prt i = \case
    Language.Ocaml.Abs.ExtensionConstructorDeclaration constrident generalizedconstructorarguments attributes -> prPrec i 0 (concatD [prt 0 constrident, prt 0 generalizedconstructorarguments, prt 0 attributes])

instance Print Language.Ocaml.Abs.ExtensionConstructorRebind where
  prt i = \case
    Language.Ocaml.Abs.ExtensionConstructorRebind constrident equal constrlongident attributes -> prPrec i 0 (concatD [prt 0 constrident, prt 0 equal, prt 0 constrlongident, prt 0 attributes])

instance Print Language.Ocaml.Abs.WithConstraint where
  prt i = \case
    Language.Ocaml.Abs.WithConstraint1 typeparameters labellongident withtypebinder aliastype constraints -> prPrec i 0 (concatD [doc (showString "type"), prt 0 typeparameters, prt 0 labellongident, prt 0 withtypebinder, prt 0 aliastype, prt 0 constraints])
    Language.Ocaml.Abs.WithConstraint2 typeparameters labellongident colonequal aliastype -> prPrec i 0 (concatD [doc (showString "type"), prt 0 typeparameters, prt 0 labellongident, prt 0 colonequal, prt 0 aliastype])
    Language.Ocaml.Abs.WithConstraint3 modlongident equal modextlongident -> prPrec i 0 (concatD [doc (showString "module"), prt 0 modlongident, prt 0 equal, prt 0 modextlongident])
    Language.Ocaml.Abs.WithConstraint4 modlongident colonequal modextlongident -> prPrec i 0 (concatD [doc (showString "module"), prt 0 modlongident, prt 0 colonequal, prt 0 modextlongident])
    Language.Ocaml.Abs.WithConstraint5 mtylongident equal moduletype -> prPrec i 0 (concatD [doc (showString "module"), doc (showString "type"), prt 0 mtylongident, prt 0 equal, prt 0 moduletype])
    Language.Ocaml.Abs.WithConstraint6 mtylongident colonequal moduletype -> prPrec i 0 (concatD [doc (showString "module"), doc (showString "type"), prt 0 mtylongident, prt 0 colonequal, prt 0 moduletype])

instance Print Language.Ocaml.Abs.WithTypeBinder where
  prt i = \case
    Language.Ocaml.Abs.WithTypeBinderEqual equal -> prPrec i 0 (concatD [prt 0 equal])
    Language.Ocaml.Abs.WithTypeBinderEqualPrivate equal -> prPrec i 0 (concatD [prt 0 equal, doc (showString "private")])

instance Print Language.Ocaml.Abs.TypeVar where
  prt i = \case
    Language.Ocaml.Abs.TypeVarIdent ocamlident -> prPrec i 0 (concatD [doc (showString "'"), prt 0 ocamlident])

instance Print [Language.Ocaml.Abs.TypeVar] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.PolyType where
  prt i = \case
    Language.Ocaml.Abs.MonoCoreType coretype -> prPrec i 0 (concatD [prt 0 coretype])
    Language.Ocaml.Abs.PolyCoreType typevars coretype -> prPrec i 0 (concatD [prt 0 typevars, doc (showString "."), prt 0 coretype])

instance Print Language.Ocaml.Abs.CoreType where
  prt i = \case
    Language.Ocaml.Abs.CoreTypeWithoutAttribute aliastype -> prPrec i 0 (concatD [prt 0 aliastype])
    Language.Ocaml.Abs.CoreTypeWithAttribute coretype attribute -> prPrec i 0 (concatD [prt 0 coretype, prt 0 attribute])

instance Print [Language.Ocaml.Abs.CoreType] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Language.Ocaml.Abs.AliasType where
  prt i = \case
    Language.Ocaml.Abs.FunctionType functiontype -> prPrec i 0 (concatD [prt 0 functiontype])
    Language.Ocaml.Abs.AliasType aliastype typevar -> prPrec i 0 (concatD [prt 0 aliastype, doc (showString "as"), prt 0 typevar])

instance Print Language.Ocaml.Abs.FunctionType where
  prt i = \case
    Language.Ocaml.Abs.TupleType tupletype -> prPrec i 0 (concatD [prt 0 tupletype])
    Language.Ocaml.Abs.ArgTypeWithOptLabel optlabel tupletype functiontype -> prPrec i 0 (concatD [prt 0 optlabel, prt 0 tupletype, doc (showString "->"), prt 0 functiontype])
    Language.Ocaml.Abs.ArgTypeWithLabel lident tupletype functiontype -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 tupletype, doc (showString "->"), prt 0 functiontype])
    Language.Ocaml.Abs.ArgTypeWithoutLabel tupletype functiontype -> prPrec i 0 (concatD [prt 0 tupletype, doc (showString "->"), prt 0 functiontype])

instance Print Language.Ocaml.Abs.TupleType where
  prt i = \case
    Language.Ocaml.Abs.AtomicType atomictype -> prPrec i 0 (concatD [prt 0 atomictype])
    Language.Ocaml.Abs.AtomicTypes atomictype star tupletype -> prPrec i 0 (concatD [prt 0 atomictype, prt 0 star, prt 0 tupletype])

instance Print Language.Ocaml.Abs.OptionalBar where
  prt i = \case
    Language.Ocaml.Abs.NoBar -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.ABar -> prPrec i 0 (concatD [doc (showString "|")])

instance Print Language.Ocaml.Abs.DelimitedTypeSupportingLocalOpen where
  prt i = \case
    Language.Ocaml.Abs.LocalOpen1 coretype -> prPrec i 0 (concatD [doc (showString "("), prt 0 coretype, doc (showString ")")])
    Language.Ocaml.Abs.LocalOpen2 ext attributes packagetype -> prPrec i 0 (concatD [doc (showString "("), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 packagetype, doc (showString ")")])
    Language.Ocaml.Abs.LocalOpen3 tagfield -> prPrec i 0 (concatD [doc (showString "["), prt 0 tagfield, doc (showString "]")])
    Language.Ocaml.Abs.LocalOpen4 rowfields -> prPrec i 0 (concatD [doc (showString "["), doc (showString "|"), prt 0 rowfields, doc (showString "]")])
    Language.Ocaml.Abs.LocalOpen5 rowfield rowfields -> prPrec i 0 (concatD [doc (showString "["), prt 0 rowfield, doc (showString "|"), prt 0 rowfields, doc (showString "]")])
    Language.Ocaml.Abs.LocalOpen6 optionalbar rowfields -> prPrec i 0 (concatD [doc (showString "[>"), prt 0 optionalbar, prt 0 rowfields, doc (showString "]")])
    Language.Ocaml.Abs.LocalOpen7 -> prPrec i 0 (concatD [doc (showString "[>"), doc (showString "]")])
    Language.Ocaml.Abs.LocalOpen8 optionalbar rowfields -> prPrec i 0 (concatD [doc (showString "[<"), prt 0 optionalbar, prt 0 rowfields, doc (showString "]")])
    Language.Ocaml.Abs.LocalOpen9 optionalbar rowfields greater nametags -> prPrec i 0 (concatD [doc (showString "[<"), prt 0 optionalbar, prt 0 rowfields, prt 0 greater, prt 0 nametags, doc (showString "]")])

instance Print Language.Ocaml.Abs.ObjectType where
  prt i = \case
    Language.Ocaml.Abs.MethList less methlist greater -> prPrec i 0 (concatD [prt 0 less, prt 0 methlist, prt 0 greater])
    Language.Ocaml.Abs.Empty less greater -> prPrec i 0 (concatD [prt 0 less, prt 0 greater])

instance Print Language.Ocaml.Abs.DelimitedType where
  prt i = \case
    Language.Ocaml.Abs.ObjectType objecttype -> prPrec i 0 (concatD [prt 0 objecttype])
    Language.Ocaml.Abs.DelimitedTypeExtension extension -> prPrec i 0 (concatD [prt 0 extension])
    Language.Ocaml.Abs.DelimitedTypeSupportingLocalOpen delimitedtypesupportinglocalopen -> prPrec i 0 (concatD [prt 0 delimitedtypesupportinglocalopen])

instance Print Language.Ocaml.Abs.AtomicType where
  prt i = \case
    Language.Ocaml.Abs.DelimitedType delimitedtype -> prPrec i 0 (concatD [prt 0 delimitedtype])
    Language.Ocaml.Abs.TypeConstr typelongident -> prPrec i 0 (concatD [prt 0 typelongident])
    Language.Ocaml.Abs.SimpleTypeApp atomictype typelongident -> prPrec i 0 (concatD [prt 0 atomictype, prt 0 typelongident])
    Language.Ocaml.Abs.ComplexTypeApp coretype coretypes typelongident -> prPrec i 0 (concatD [doc (showString "("), prt 0 coretype, doc (showString ","), prt 0 coretypes, doc (showString ")"), prt 0 typelongident])
    Language.Ocaml.Abs.ClassTypeConstr cltylongident -> prPrec i 0 (concatD [doc (showString "#"), prt 0 cltylongident])
    Language.Ocaml.Abs.SimpleSubTypeApp atomictype cltylongident -> prPrec i 0 (concatD [prt 0 atomictype, doc (showString "#"), prt 0 cltylongident])
    Language.Ocaml.Abs.ComplexSubTypeApp coretype coretypes cltylongident -> prPrec i 0 (concatD [doc (showString "("), prt 0 coretype, doc (showString ","), prt 0 coretypes, doc (showString ")"), doc (showString "#"), prt 0 cltylongident])
    Language.Ocaml.Abs.QualifiedDelimitedType modextlongident delimitedtypesupportinglocalopen -> prPrec i 0 (concatD [prt 0 modextlongident, doc (showString "."), prt 0 delimitedtypesupportinglocalopen])
    Language.Ocaml.Abs.TypeVar ocamlident -> prPrec i 0 (concatD [doc (showString "'"), prt 0 ocamlident])
    Language.Ocaml.Abs.UnderscoreType -> prPrec i 0 (concatD [doc (showString "_")])

instance Print Language.Ocaml.Abs.PackageType where
  prt i = \case
    Language.Ocaml.Abs.PackageType moduletype -> prPrec i 0 (concatD [prt 0 moduletype])

instance Print [Language.Ocaml.Abs.RowField] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "|"), prt 0 xs]

instance Print Language.Ocaml.Abs.RowField where
  prt i = \case
    Language.Ocaml.Abs.TagField tagfield -> prPrec i 0 (concatD [prt 0 tagfield])
    Language.Ocaml.Abs.CoreType coretype -> prPrec i 0 (concatD [prt 0 coretype])

instance Print Language.Ocaml.Abs.TagField where
  prt i = \case
    Language.Ocaml.Abs.Of nametag optampersand ampertypelist attributes -> prPrec i 0 (concatD [prt 0 nametag, doc (showString "of"), prt 0 optampersand, prt 0 ampertypelist, prt 0 attributes])
    Language.Ocaml.Abs.Tag nametag attributes -> prPrec i 0 (concatD [prt 0 nametag, prt 0 attributes])

instance Print Language.Ocaml.Abs.OptAmpersand where
  prt i = \case
    Language.Ocaml.Abs.Ampersand ampersand -> prPrec i 0 (concatD [prt 0 ampersand])
    Language.Ocaml.Abs.NoAmpersand -> prPrec i 0 (concatD [])

instance Print Language.Ocaml.Abs.AmperTypeList where
  prt i = \case
    Language.Ocaml.Abs.AmperTypeListNil aliastype -> prPrec i 0 (concatD [prt 0 aliastype])
    Language.Ocaml.Abs.AmperTypeListCons aliastype ampersand ampertypelist -> prPrec i 0 (concatD [prt 0 aliastype, prt 0 ampersand, prt 0 ampertypelist])

instance Print [Language.Ocaml.Abs.NameTag] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.MethList where
  prt i = \case
    Language.Ocaml.Abs.FieldSemiMethListMonoType lident aliastype attributes1 attributes2 methlist -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 aliastype, prt 0 attributes1, doc (showString ";"), prt 0 attributes2, prt 0 methlist])
    Language.Ocaml.Abs.FieldSemiMethListPolyType lident typevars aliastype attributes1 attributes2 methlist -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 typevars, doc (showString "."), prt 0 aliastype, prt 0 attributes1, doc (showString ";"), prt 0 attributes2, prt 0 methlist])
    Language.Ocaml.Abs.InheritSemiMethList atomictype methlist -> prPrec i 0 (concatD [prt 0 atomictype, doc (showString ";"), prt 0 methlist])
    Language.Ocaml.Abs.FieldSemiMonoType lident aliastype attributes -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 aliastype, prt 0 attributes, doc (showString ";")])
    Language.Ocaml.Abs.FieldSemiPolyType lident typevars aliastype attributes -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 typevars, doc (showString "."), prt 0 aliastype, prt 0 attributes, doc (showString ";")])
    Language.Ocaml.Abs.InheritSemi atomictype -> prPrec i 0 (concatD [prt 0 atomictype, doc (showString ";")])
    Language.Ocaml.Abs.FieldMonoType lident aliastype attributes -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 aliastype, prt 0 attributes])
    Language.Ocaml.Abs.FieldPolyType lident typevars aliastype attributes -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 typevars, doc (showString "."), prt 0 aliastype, prt 0 attributes])
    Language.Ocaml.Abs.Inherit atomictype -> prPrec i 0 (concatD [prt 0 atomictype])
    Language.Ocaml.Abs.DotDot -> prPrec i 0 (concatD [doc (showString "..")])

instance Print Language.Ocaml.Abs.Constant where
  prt i = \case
    Language.Ocaml.Abs.Int int -> prPrec i 0 (concatD [prt 0 int])
    Language.Ocaml.Abs.Char char -> prPrec i 0 (concatD [prt 0 char])
    Language.Ocaml.Abs.String string -> prPrec i 0 (concatD [prt 0 string])
    Language.Ocaml.Abs.Float float -> prPrec i 0 (concatD [prt 0 float])

instance Print Language.Ocaml.Abs.SignedConstant where
  prt i = \case
    Language.Ocaml.Abs.UnsignedConstant constant -> prPrec i 0 (concatD [prt 0 constant])
    Language.Ocaml.Abs.NegInt minus int -> prPrec i 0 (concatD [prt 0 minus, prt 0 int])
    Language.Ocaml.Abs.NegFloat minus float -> prPrec i 0 (concatD [prt 0 minus, prt 0 float])
    Language.Ocaml.Abs.PosInt plus int -> prPrec i 0 (concatD [prt 0 plus, prt 0 int])
    Language.Ocaml.Abs.PosFloat plus float -> prPrec i 0 (concatD [prt 0 plus, prt 0 float])

instance Print Language.Ocaml.Abs.OCamlIdent where
  prt i = \case
    Language.Ocaml.Abs.Uppercase uident -> prPrec i 0 (concatD [prt 0 uident])
    Language.Ocaml.Abs.Lowercase lident -> prPrec i 0 (concatD [prt 0 lident])

instance Print Language.Ocaml.Abs.ValExtraIdent where
  prt i = \case
    Language.Ocaml.Abs.Operator operator -> prPrec i 0 (concatD [doc (showString "("), prt 0 operator, doc (showString ")")])

instance Print Language.Ocaml.Abs.ValIdent where
  prt i = \case
    Language.Ocaml.Abs.LowercaseValIdent lident -> prPrec i 0 (concatD [prt 0 lident])
    Language.Ocaml.Abs.ValExtraIdent valextraident -> prPrec i 0 (concatD [prt 0 valextraident])

instance Print Language.Ocaml.Abs.Operator where
  prt i = \case
    Language.Ocaml.Abs.PrefixOp prefixop -> prPrec i 0 (concatD [prt 0 prefixop])
    Language.Ocaml.Abs.LetOp letop -> prPrec i 0 (concatD [prt 0 letop])
    Language.Ocaml.Abs.AndOp andop -> prPrec i 0 (concatD [prt 0 andop])
    Language.Ocaml.Abs.ParenAccessDotop dotop indexmod -> prPrec i 0 (concatD [prt 0 dotop, doc (showString "("), prt 0 indexmod, doc (showString ")")])
    Language.Ocaml.Abs.ParenUpdateDotop dotop indexmod -> prPrec i 0 (concatD [prt 0 dotop, doc (showString "("), prt 0 indexmod, doc (showString ")"), doc (showString "<-")])
    Language.Ocaml.Abs.BraceAccessDotop dotop indexmod -> prPrec i 0 (concatD [prt 0 dotop, doc (showString "["), prt 0 indexmod, doc (showString "]")])
    Language.Ocaml.Abs.BraceUpdateDotop dotop indexmod -> prPrec i 0 (concatD [prt 0 dotop, doc (showString "["), prt 0 indexmod, doc (showString "]"), doc (showString "<-")])
    Language.Ocaml.Abs.HashSymbolOp hashop -> prPrec i 0 (concatD [prt 0 hashop])
    Language.Ocaml.Abs.BangOp bang -> prPrec i 0 (concatD [prt 0 bang])
    Language.Ocaml.Abs.RelOp relop -> prPrec i 0 (concatD [prt 0 relop])
    Language.Ocaml.Abs.InfixEqual equal -> prPrec i 0 (concatD [prt 0 equal])
    Language.Ocaml.Abs.InfixLess less -> prPrec i 0 (concatD [prt 0 less])
    Language.Ocaml.Abs.InfixGreater greater -> prPrec i 0 (concatD [prt 0 greater])
    Language.Ocaml.Abs.InfixBarBar barbar -> prPrec i 0 (concatD [prt 0 barbar])
    Language.Ocaml.Abs.InfixAmpersand ampersand -> prPrec i 0 (concatD [prt 0 ampersand])
    Language.Ocaml.Abs.InfixAmperAmper amperamper -> prPrec i 0 (concatD [prt 0 amperamper])
    Language.Ocaml.Abs.ConcatOp concatop -> prPrec i 0 (concatD [prt 0 concatop])
    Language.Ocaml.Abs.PlusMinusOp plusminusop -> prPrec i 0 (concatD [prt 0 plusminusop])
    Language.Ocaml.Abs.InfixPlus plus -> prPrec i 0 (concatD [prt 0 plus])
    Language.Ocaml.Abs.InfixMinus minus -> prPrec i 0 (concatD [prt 0 minus])
    Language.Ocaml.Abs.MultDivOp multdivop -> prPrec i 0 (concatD [prt 0 multdivop])
    Language.Ocaml.Abs.InfixStar star -> prPrec i 0 (concatD [prt 0 star])
    Language.Ocaml.Abs.InfixPercent percent -> prPrec i 0 (concatD [prt 0 percent])
    Language.Ocaml.Abs.PowOp powop -> prPrec i 0 (concatD [prt 0 powop])
    Language.Ocaml.Abs.InfixOr or -> prPrec i 0 (concatD [prt 0 or])
    Language.Ocaml.Abs.InfixColonEqual colonequal -> prPrec i 0 (concatD [prt 0 colonequal])

instance Print Language.Ocaml.Abs.IndexMod where
  prt i = \case
    Language.Ocaml.Abs.NoIndexMod -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.SemiDotDot -> prPrec i 0 (concatD [doc (showString ";"), doc (showString "..")])

instance Print Language.Ocaml.Abs.ConstrExtraNonprefixIdent where
  prt i = \case
    Language.Ocaml.Abs.EmptyListConstr -> prPrec i 0 (concatD [doc (showString "["), doc (showString "]")])
    Language.Ocaml.Abs.UnitConstr -> prPrec i 0 (concatD [doc (showString "("), doc (showString ")")])
    Language.Ocaml.Abs.FalseConstr -> prPrec i 0 (concatD [doc (showString "false")])
    Language.Ocaml.Abs.TrueConstr -> prPrec i 0 (concatD [doc (showString "true")])

instance Print Language.Ocaml.Abs.ConstrIdent where
  prt i = \case
    Language.Ocaml.Abs.ConstrIdent uident -> prPrec i 0 (concatD [prt 0 uident])
    Language.Ocaml.Abs.ListConstr -> prPrec i 0 (concatD [doc (showString "("), doc (showString "::"), doc (showString ")")])
    Language.Ocaml.Abs.PrimitiveConstr constrextranonprefixident -> prPrec i 0 (concatD [prt 0 constrextranonprefixident])

instance Print Language.Ocaml.Abs.ConstrLongident where
  prt i = \case
    Language.Ocaml.Abs.QualifiedConstrIdent modlongident -> prPrec i 0 (concatD [prt 0 modlongident])
    Language.Ocaml.Abs.QualifiedListConstr modlongident -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "("), doc (showString "::"), doc (showString ")")])
    Language.Ocaml.Abs.UnqualifiedListConstr -> prPrec i 0 (concatD [doc (showString "("), doc (showString "::"), doc (showString ")")])
    Language.Ocaml.Abs.UnqualifiedPrimitiveConstr constrextranonprefixident -> prPrec i 0 (concatD [prt 0 constrextranonprefixident])

instance Print Language.Ocaml.Abs.ValLongident where
  prt i = \case
    Language.Ocaml.Abs.UnqualifiedValLongIdent valident -> prPrec i 0 (concatD [prt 0 valident])
    Language.Ocaml.Abs.QualifiedValIdent modlongident valident -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), prt 0 valident])

instance Print Language.Ocaml.Abs.LabelLongident where
  prt i = \case
    Language.Ocaml.Abs.LabelLongident lident -> prPrec i 0 (concatD [prt 0 lident])
    Language.Ocaml.Abs.QualifiedLabelLongident modlongident lident -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), prt 0 lident])

instance Print Language.Ocaml.Abs.TypeLongident where
  prt i = \case
    Language.Ocaml.Abs.TypeLongident lident -> prPrec i 0 (concatD [prt 0 lident])
    Language.Ocaml.Abs.QualifiedTypelLongident modextlongident lident -> prPrec i 0 (concatD [prt 0 modextlongident, doc (showString "."), prt 0 lident])

instance Print Language.Ocaml.Abs.ModLongident where
  prt i = \case
    Language.Ocaml.Abs.ModLongident uident -> prPrec i 0 (concatD [prt 0 uident])
    Language.Ocaml.Abs.QualifiedModLongident modlongident uident -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), prt 0 uident])

instance Print Language.Ocaml.Abs.ModExtLongident where
  prt i = \case
    Language.Ocaml.Abs.ModExtLongident uident -> prPrec i 0 (concatD [prt 0 uident])
    Language.Ocaml.Abs.QualifiedModExtLongident modextlongident uident -> prPrec i 0 (concatD [prt 0 modextlongident, doc (showString "."), prt 0 uident])
    Language.Ocaml.Abs.ParenModExtLongident modextlongident1 modextlongident2 -> prPrec i 0 (concatD [prt 0 modextlongident1, doc (showString "("), prt 0 modextlongident2, doc (showString ")")])

instance Print Language.Ocaml.Abs.MtyLongident where
  prt i = \case
    Language.Ocaml.Abs.MtyLongident ocamlident -> prPrec i 0 (concatD [prt 0 ocamlident])
    Language.Ocaml.Abs.QualifiedMtyLongident modextlongident ocamlident -> prPrec i 0 (concatD [prt 0 modextlongident, doc (showString "."), prt 0 ocamlident])

instance Print Language.Ocaml.Abs.CltyLongident where
  prt i = \case
    Language.Ocaml.Abs.CltyLongident lident -> prPrec i 0 (concatD [prt 0 lident])
    Language.Ocaml.Abs.QualifiedCltyLongident modextlongident lident -> prPrec i 0 (concatD [prt 0 modextlongident, doc (showString "."), prt 0 lident])

instance Print Language.Ocaml.Abs.ClassLongident where
  prt i = \case
    Language.Ocaml.Abs.ClassLongident lident -> prPrec i 0 (concatD [prt 0 lident])
    Language.Ocaml.Abs.QualifiedClassLongident modlongident lident -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), prt 0 lident])

instance Print Language.Ocaml.Abs.OptionalToplevelDirectiveArgument where
  prt i = \case
    Language.Ocaml.Abs.NoToplevelDirectiveArgument -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.AToplevelDirectiveArgument topleveldirectiveargument -> prPrec i 0 (concatD [prt 0 topleveldirectiveargument])

instance Print Language.Ocaml.Abs.ToplevelDirective where
  prt i = \case
    Language.Ocaml.Abs.ToplevelDirectiveApp ocamlident topleveldirectiveargument -> prPrec i 0 (concatD [doc (showString "#"), prt 0 ocamlident, prt 0 topleveldirectiveargument])

instance Print Language.Ocaml.Abs.ToplevelDirectiveArgument where
  prt i = \case
    Language.Ocaml.Abs.ToplevelString string -> prPrec i 0 (concatD [prt 0 string])
    Language.Ocaml.Abs.ToplevelInt int -> prPrec i 0 (concatD [prt 0 int])
    Language.Ocaml.Abs.ValueIdent vallongident -> prPrec i 0 (concatD [prt 0 vallongident])
    Language.Ocaml.Abs.ToplevelModuleIdent modlongident -> prPrec i 0 (concatD [prt 0 modlongident])
    Language.Ocaml.Abs.ToplevelFalse -> prPrec i 0 (concatD [doc (showString "false")])
    Language.Ocaml.Abs.ToplevelTrue -> prPrec i 0 (concatD [doc (showString "true")])

instance Print Language.Ocaml.Abs.NameTag where
  prt i = \case
    Language.Ocaml.Abs.NameTag ocamlident -> prPrec i 0 (concatD [doc (showString "`"), prt 0 ocamlident])

instance Print Language.Ocaml.Abs.RecFlag where
  prt i = \case
    Language.Ocaml.Abs.Nonrecursive -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.Recursive -> prPrec i 0 (concatD [doc (showString "rec")])

instance Print Language.Ocaml.Abs.DirectionFlag where
  prt i = \case
    Language.Ocaml.Abs.UpTo -> prPrec i 0 (concatD [doc (showString "to")])
    Language.Ocaml.Abs.DownTo -> prPrec i 0 (concatD [doc (showString "downto")])

instance Print Language.Ocaml.Abs.PrivateFlag where
  prt i = \case
    Language.Ocaml.Abs.Public -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.Private -> prPrec i 0 (concatD [doc (showString "private")])

instance Print Language.Ocaml.Abs.MutableFlag where
  prt i = \case
    Language.Ocaml.Abs.Immutable -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.Mutable -> prPrec i 0 (concatD [doc (showString "mutable")])

instance Print Language.Ocaml.Abs.VirtualFlag where
  prt i = \case
    Language.Ocaml.Abs.Concrete -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.Virtual -> prPrec i 0 (concatD [doc (showString "virtual")])

instance Print Language.Ocaml.Abs.MutableVirtualFlags where
  prt i = \case
    Language.Ocaml.Abs.ImmutableContrete -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.MutableConcrete -> prPrec i 0 (concatD [doc (showString "mutable")])
    Language.Ocaml.Abs.ImmutableVirtual -> prPrec i 0 (concatD [doc (showString "virtual")])
    Language.Ocaml.Abs.MutableVirtual -> prPrec i 0 (concatD [doc (showString "mutable"), doc (showString "virtual")])
    Language.Ocaml.Abs.VirtualMutable -> prPrec i 0 (concatD [doc (showString "virtual"), doc (showString "mutable")])

instance Print Language.Ocaml.Abs.PrivateVirtualFlags where
  prt i = \case
    Language.Ocaml.Abs.PublicConcrete -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.PrivateConcrete -> prPrec i 0 (concatD [doc (showString "private")])
    Language.Ocaml.Abs.PublicVirtual -> prPrec i 0 (concatD [doc (showString "virtual")])
    Language.Ocaml.Abs.PrivateVirtual -> prPrec i 0 (concatD [doc (showString "private"), doc (showString "virtual")])
    Language.Ocaml.Abs.VirtualPrivate -> prPrec i 0 (concatD [doc (showString "virtual"), doc (showString "private")])

instance Print Language.Ocaml.Abs.VirtualWithMutableFlag where
  prt i = \case
    Language.Ocaml.Abs.VirtualWithImmutable -> prPrec i 0 (concatD [doc (showString "virtual")])
    Language.Ocaml.Abs.MutableWithVirtual -> prPrec i 0 (concatD [doc (showString "mutable"), doc (showString "virtual")])
    Language.Ocaml.Abs.VirtualWithMutable -> prPrec i 0 (concatD [doc (showString "virtual"), doc (showString "mutable")])

instance Print Language.Ocaml.Abs.VirtualWithPrivateFlag where
  prt i = \case
    Language.Ocaml.Abs.VirtualWithPublic -> prPrec i 0 (concatD [doc (showString "virtual")])
    Language.Ocaml.Abs.PrivateWithVirtual -> prPrec i 0 (concatD [doc (showString "private"), doc (showString "virtual")])
    Language.Ocaml.Abs.VirtualWithPrivate -> prPrec i 0 (concatD [doc (showString "virtual"), doc (showString "private")])

instance Print Language.Ocaml.Abs.NoOverrideFlag where
  prt i = \case
    Language.Ocaml.Abs.NoFlag -> prPrec i 0 (concatD [])

instance Print Language.Ocaml.Abs.OverrideFlag where
  prt i = \case
    Language.Ocaml.Abs.Fresh -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.Override bang -> prPrec i 0 (concatD [prt 0 bang])

instance Print Language.Ocaml.Abs.Subtractive where
  prt i = \case
    Language.Ocaml.Abs.Minus minus -> prPrec i 0 (concatD [prt 0 minus])
    Language.Ocaml.Abs.MinusDot -> prPrec i 0 (concatD [doc (showString "-.")])

instance Print Language.Ocaml.Abs.Additive where
  prt i = \case
    Language.Ocaml.Abs.Plus plus -> prPrec i 0 (concatD [prt 0 plus])
    Language.Ocaml.Abs.PlusDot -> prPrec i 0 (concatD [doc (showString "+.")])

instance Print Language.Ocaml.Abs.AttrId where
  prt i = \case
    Language.Ocaml.Abs.LowercaseAttr lident -> prPrec i 0 (concatD [prt 0 lident])
    Language.Ocaml.Abs.UppercaseAttr uident -> prPrec i 0 (concatD [prt 0 uident])
    Language.Ocaml.Abs.AndAttr -> prPrec i 0 (concatD [doc (showString "and")])
    Language.Ocaml.Abs.AsAttr -> prPrec i 0 (concatD [doc (showString "as")])
    Language.Ocaml.Abs.AssertAttr -> prPrec i 0 (concatD [doc (showString "assert")])
    Language.Ocaml.Abs.BeginAttr -> prPrec i 0 (concatD [doc (showString "begin")])
    Language.Ocaml.Abs.ClassAttr -> prPrec i 0 (concatD [doc (showString "class")])
    Language.Ocaml.Abs.ConstraintAttr -> prPrec i 0 (concatD [doc (showString "constraint")])
    Language.Ocaml.Abs.DoAttr -> prPrec i 0 (concatD [doc (showString "do")])
    Language.Ocaml.Abs.DoneAttr -> prPrec i 0 (concatD [doc (showString "done")])
    Language.Ocaml.Abs.DowntoAttr -> prPrec i 0 (concatD [doc (showString "downto")])
    Language.Ocaml.Abs.ElseAttr -> prPrec i 0 (concatD [doc (showString "else")])
    Language.Ocaml.Abs.EndAttr -> prPrec i 0 (concatD [doc (showString "end")])
    Language.Ocaml.Abs.ExceptionAttr -> prPrec i 0 (concatD [doc (showString "exception")])
    Language.Ocaml.Abs.ExternalAttr -> prPrec i 0 (concatD [doc (showString "external")])
    Language.Ocaml.Abs.FalseAttr -> prPrec i 0 (concatD [doc (showString "false")])
    Language.Ocaml.Abs.ForAttr -> prPrec i 0 (concatD [doc (showString "for")])
    Language.Ocaml.Abs.FunAttr -> prPrec i 0 (concatD [doc (showString "fun")])
    Language.Ocaml.Abs.FunctionAttr -> prPrec i 0 (concatD [doc (showString "function")])
    Language.Ocaml.Abs.FunctorAttr -> prPrec i 0 (concatD [doc (showString "functor")])
    Language.Ocaml.Abs.IfAttr -> prPrec i 0 (concatD [doc (showString "if")])
    Language.Ocaml.Abs.InAttr -> prPrec i 0 (concatD [doc (showString "in")])
    Language.Ocaml.Abs.IncludeAttr -> prPrec i 0 (concatD [doc (showString "include")])
    Language.Ocaml.Abs.InheritAttr -> prPrec i 0 (concatD [doc (showString "inherit")])
    Language.Ocaml.Abs.InitializerAttr -> prPrec i 0 (concatD [doc (showString "initializer")])
    Language.Ocaml.Abs.LazyAttr -> prPrec i 0 (concatD [doc (showString "lazy")])
    Language.Ocaml.Abs.LetAttr -> prPrec i 0 (concatD [doc (showString "let")])
    Language.Ocaml.Abs.MatchAttr -> prPrec i 0 (concatD [doc (showString "match")])
    Language.Ocaml.Abs.MethodAttr -> prPrec i 0 (concatD [doc (showString "method")])
    Language.Ocaml.Abs.ModuleAttr -> prPrec i 0 (concatD [doc (showString "module")])
    Language.Ocaml.Abs.MutableAttr -> prPrec i 0 (concatD [doc (showString "mutable")])
    Language.Ocaml.Abs.NewAttr -> prPrec i 0 (concatD [doc (showString "new")])
    Language.Ocaml.Abs.NonrecAttr -> prPrec i 0 (concatD [doc (showString "nonrec")])
    Language.Ocaml.Abs.ObjectAttr -> prPrec i 0 (concatD [doc (showString "object")])
    Language.Ocaml.Abs.OfAttr -> prPrec i 0 (concatD [doc (showString "of")])
    Language.Ocaml.Abs.OpenAttr -> prPrec i 0 (concatD [doc (showString "open")])
    Language.Ocaml.Abs.OrAttr or -> prPrec i 0 (concatD [prt 0 or])
    Language.Ocaml.Abs.PrivateAttr -> prPrec i 0 (concatD [doc (showString "private")])
    Language.Ocaml.Abs.RecAttr -> prPrec i 0 (concatD [doc (showString "rec")])
    Language.Ocaml.Abs.SigAttr -> prPrec i 0 (concatD [doc (showString "sig")])
    Language.Ocaml.Abs.StructAttr -> prPrec i 0 (concatD [doc (showString "struct")])
    Language.Ocaml.Abs.ThenAttr -> prPrec i 0 (concatD [doc (showString "then")])
    Language.Ocaml.Abs.ToAttr -> prPrec i 0 (concatD [doc (showString "to")])
    Language.Ocaml.Abs.TrueAttr -> prPrec i 0 (concatD [doc (showString "true")])
    Language.Ocaml.Abs.TryAttr -> prPrec i 0 (concatD [doc (showString "try")])
    Language.Ocaml.Abs.TypeAttr -> prPrec i 0 (concatD [doc (showString "type")])
    Language.Ocaml.Abs.ValAttr -> prPrec i 0 (concatD [doc (showString "val")])
    Language.Ocaml.Abs.VirtualAttr -> prPrec i 0 (concatD [doc (showString "virtual")])
    Language.Ocaml.Abs.WhenAttr -> prPrec i 0 (concatD [doc (showString "when")])
    Language.Ocaml.Abs.WhileAttr -> prPrec i 0 (concatD [doc (showString "while")])
    Language.Ocaml.Abs.WithAttr -> prPrec i 0 (concatD [doc (showString "with")])

instance Print [Language.Ocaml.Abs.AttrId] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "."), prt 0 xs]

instance Print Language.Ocaml.Abs.Attribute where
  prt i = \case
    Language.Ocaml.Abs.Attribute attrids attrpayload -> prPrec i 0 (concatD [doc (showString "[@"), prt 0 attrids, prt 0 attrpayload, doc (showString "]")])

instance Print Language.Ocaml.Abs.PostItemAttribute where
  prt i = \case
    Language.Ocaml.Abs.PostItemAttribute attrids attrpayload -> prPrec i 0 (concatD [doc (showString "[@@"), prt 0 attrids, prt 0 attrpayload, doc (showString "]")])

instance Print Language.Ocaml.Abs.FloatingAttribute where
  prt i = \case
    Language.Ocaml.Abs.FloatingAttribute attrids attrpayload -> prPrec i 0 (concatD [doc (showString "[@@@"), prt 0 attrids, prt 0 attrpayload, doc (showString "]")])

instance Print [Language.Ocaml.Abs.PostItemAttribute] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print [Language.Ocaml.Abs.Attribute] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Language.Ocaml.Abs.Ext where
  prt i = \case
    Language.Ocaml.Abs.NoExt -> prPrec i 0 (concatD [])
    Language.Ocaml.Abs.Ext percent attrids -> prPrec i 0 (concatD [prt 0 percent, prt 0 attrids])

instance Print Language.Ocaml.Abs.Extension where
  prt i = \case
    Language.Ocaml.Abs.ExtensionPayload attrids payload -> prPrec i 0 (concatD [doc (showString "[%"), prt 0 attrids, prt 0 payload, doc (showString "]")])
    Language.Ocaml.Abs.QuotedStringExpr quotedstringexpr -> prPrec i 0 (concatD [prt 0 quotedstringexpr])

instance Print Language.Ocaml.Abs.ItemExtension where
  prt i = \case
    Language.Ocaml.Abs.ItemExtensionPayload attrids payload -> prPrec i 0 (concatD [doc (showString "[%%"), prt 0 attrids, prt 0 payload, doc (showString "]")])
    Language.Ocaml.Abs.QuotedStringItem quotedstringitem -> prPrec i 0 (concatD [prt 0 quotedstringitem])

instance Print Language.Ocaml.Abs.Payload where
  prt i = \case
    Language.Ocaml.Abs.PayloadStructure structure -> prPrec i 0 (concatD [prt 0 structure])
    Language.Ocaml.Abs.PayloadSignature signature -> prPrec i 0 (concatD [doc (showString ":"), prt 0 signature])
    Language.Ocaml.Abs.PayloadCoreType coretype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 coretype])
    Language.Ocaml.Abs.PayloadPattern pattern_ -> prPrec i 0 (concatD [doc (showString "?"), prt 0 pattern_])
    Language.Ocaml.Abs.PayloadGuardedPattern pattern_ seqexpr -> prPrec i 0 (concatD [doc (showString "?"), prt 0 pattern_, doc (showString "when"), prt 0 seqexpr])

instance Print Language.Ocaml.Abs.AttrPayload where
  prt i = \case
    Language.Ocaml.Abs.AttrPayload payload -> prPrec i 0 (concatD [prt 0 payload])
