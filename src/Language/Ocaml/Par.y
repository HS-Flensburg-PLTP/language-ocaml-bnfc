-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.6).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Language.Ocaml.Par
  ( happyError
  , myLexer
  , pImplementation
  , pInterface
  , pUseFile
  ) where

import Prelude

import qualified Language.Ocaml.Abs
import Language.Ocaml.Lex

}

%name pImplementation Implementation
%name pInterface Interface
%name pUseFile UseFile
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!+'                     { PT _ (TS _ 1)                      }
  '!-'                     { PT _ (TS _ 2)                      }
  '#'                      { PT _ (TS _ 3)                      }
  '\''                     { PT _ (TS _ 4)                      }
  '('                      { PT _ (TS _ 5)                      }
  ')'                      { PT _ (TS _ 6)                      }
  '+!'                     { PT _ (TS _ 7)                      }
  ','                      { PT _ (TS _ 8)                      }
  '-!'                     { PT _ (TS _ 9)                      }
  '->'                     { PT _ (TS _ 10)                     }
  '.'                      { PT _ (TS _ 11)                     }
  '..'                     { PT _ (TS _ 12)                     }
  ':'                      { PT _ (TS _ 13)                     }
  '::'                     { PT _ (TS _ 14)                     }
  ':>'                     { PT _ (TS _ 15)                     }
  ';'                      { PT _ (TS _ 16)                     }
  ';;'                     { PT _ (TS _ 17)                     }
  '<-'                     { PT _ (TS _ 18)                     }
  '>}'                     { PT _ (TS _ 19)                     }
  '?'                      { PT _ (TS _ 20)                     }
  '['                      { PT _ (TS _ 21)                     }
  '[%'                     { PT _ (TS _ 22)                     }
  '[%%'                    { PT _ (TS _ 23)                     }
  '[<'                     { PT _ (TS _ 24)                     }
  '[>'                     { PT _ (TS _ 25)                     }
  '[@'                     { PT _ (TS _ 26)                     }
  '[@@'                    { PT _ (TS _ 27)                     }
  '[@@@'                   { PT _ (TS _ 28)                     }
  '[|'                     { PT _ (TS _ 29)                     }
  ']'                      { PT _ (TS _ 30)                     }
  '_'                      { PT _ (TS _ 31)                     }
  '`'                      { PT _ (TS _ 32)                     }
  'and'                    { PT _ (TS _ 33)                     }
  'as'                     { PT _ (TS _ 34)                     }
  'assert'                 { PT _ (TS _ 35)                     }
  'begin'                  { PT _ (TS _ 36)                     }
  'class'                  { PT _ (TS _ 37)                     }
  'constraint'             { PT _ (TS _ 38)                     }
  'do'                     { PT _ (TS _ 39)                     }
  'done'                   { PT _ (TS _ 40)                     }
  'downto'                 { PT _ (TS _ 41)                     }
  'else'                   { PT _ (TS _ 42)                     }
  'end'                    { PT _ (TS _ 43)                     }
  'exception'              { PT _ (TS _ 44)                     }
  'external'               { PT _ (TS _ 45)                     }
  'false'                  { PT _ (TS _ 46)                     }
  'for'                    { PT _ (TS _ 47)                     }
  'fun'                    { PT _ (TS _ 48)                     }
  'function'               { PT _ (TS _ 49)                     }
  'functor'                { PT _ (TS _ 50)                     }
  'if'                     { PT _ (TS _ 51)                     }
  'in'                     { PT _ (TS _ 52)                     }
  'include'                { PT _ (TS _ 53)                     }
  'inherit'                { PT _ (TS _ 54)                     }
  'initializer'            { PT _ (TS _ 55)                     }
  'lazy'                   { PT _ (TS _ 56)                     }
  'let'                    { PT _ (TS _ 57)                     }
  'match'                  { PT _ (TS _ 58)                     }
  'method'                 { PT _ (TS _ 59)                     }
  'module'                 { PT _ (TS _ 60)                     }
  'mutable'                { PT _ (TS _ 61)                     }
  'new'                    { PT _ (TS _ 62)                     }
  'nonrec'                 { PT _ (TS _ 63)                     }
  'object'                 { PT _ (TS _ 64)                     }
  'of'                     { PT _ (TS _ 65)                     }
  'open'                   { PT _ (TS _ 66)                     }
  'private'                { PT _ (TS _ 67)                     }
  'rec'                    { PT _ (TS _ 68)                     }
  'sig'                    { PT _ (TS _ 69)                     }
  'struct'                 { PT _ (TS _ 70)                     }
  'then'                   { PT _ (TS _ 71)                     }
  'to'                     { PT _ (TS _ 72)                     }
  'true'                   { PT _ (TS _ 73)                     }
  'try'                    { PT _ (TS _ 74)                     }
  'type'                   { PT _ (TS _ 75)                     }
  'val'                    { PT _ (TS _ 76)                     }
  'virtual'                { PT _ (TS _ 77)                     }
  'when'                   { PT _ (TS _ 78)                     }
  'while'                  { PT _ (TS _ 79)                     }
  'with'                   { PT _ (TS _ 80)                     }
  '{'                      { PT _ (TS _ 81)                     }
  '{<'                     { PT _ (TS _ 82)                     }
  '|'                      { PT _ (TS _ 83)                     }
  '|]'                     { PT _ (TS _ 84)                     }
  '}'                      { PT _ (TS _ 85)                     }
  '~'                      { PT _ (TS _ 86)                     }
  L_AMPERAMPER             { PT _ (T_AMPERAMPER _)              }
  L_AMPERSAND              { PT _ (T_AMPERSAND _)               }
  L_BANG                   { PT _ (T_BANG _)                    }
  L_BARBAR                 { PT _ (T_BARBAR _)                  }
  L_COLONEQUAL             { PT _ (T_COLONEQUAL _)              }
  L_EQUAL                  { PT _ (T_EQUAL _)                   }
  L_BANGEQUAL              { PT _ (T_BANGEQUAL _)               }
  L_GREATER                { PT _ (T_GREATER _)                 }
  L_LESS                   { PT _ (T_LESS _)                    }
  L_MINUS                  { PT _ (T_MINUS _)                   }
  L_MINUSDOT               { PT _ (T_MINUSDOT _)                }
  L_OR                     { PT _ (T_OR _)                      }
  L_PERCENT                { PT _ (T_PERCENT _)                 }
  L_PLUS                   { PT _ (T_PLUS _)                    }
  L_PLUSDOT                { PT _ (T_PLUSDOT _)                 }
  L_PLUSEQ                 { PT _ (T_PLUSEQ _)                  }
  L_STAR                   { PT _ (T_STAR _)                    }
  L_RELOP                  { PT _ (T_RELOP _)                   }
  L_CONCATOP               { PT _ (T_CONCATOP _)                }
  L_PLUSMINUSOP            { PT _ (T_PLUSMINUSOP _)             }
  L_MULTDIVOP              { PT _ (T_MULTDIVOP _)               }
  L_POWOP                  { PT _ (T_POWOP _)                   }
  L_DOTOP                  { PT _ (T_DOTOP _)                   }
  L_LETOP                  { PT _ (T_LETOP _)                   }
  L_ANDOP                  { PT _ (T_ANDOP _)                   }
  L_HASHOP                 { PT _ (T_HASHOP _)                  }
  L_PREFIXOP               { PT _ (T_PREFIXOP _)                }
  L_DecimalLiteral         { PT _ (T_DecimalLiteral $$)         }
  L_DecimalLiteralModifier { PT _ (T_DecimalLiteralModifier $$) }
  L_HexLiteral             { PT _ (T_HexLiteral $$)             }
  L_HexLiteralModifier     { PT _ (T_HexLiteralModifier $$)     }
  L_OctLiteral             { PT _ (T_OctLiteral $$)             }
  L_OctLiteralModifier     { PT _ (T_OctLiteralModifier $$)     }
  L_BinLiteral             { PT _ (T_BinLiteral $$)             }
  L_BinLiteralModifier     { PT _ (T_BinLiteralModifier $$)     }
  L_FLOAT                  { PT _ (T_FLOAT $$)                  }
  L_CHAR                   { PT _ (T_CHAR $$)                   }
  L_STRING                 { PT _ (T_STRING $$)                 }
  L_QUOTED_STRING_EXPR     { PT _ (T_QUOTED_STRING_EXPR $$)     }
  L_QUOTED_STRING_ITEM     { PT _ (T_QUOTED_STRING_ITEM $$)     }
  L_LIDENT                 { PT _ (T_LIDENT _)                  }
  L_UIDENT                 { PT _ (T_UIDENT $$)                 }
  L_LABEL                  { PT _ (T_LABEL _)                   }
  L_OPTLABEL               { PT _ (T_OPTLABEL _)                }

%%

AMPERAMPER :: { Language.Ocaml.Abs.AMPERAMPER }
AMPERAMPER  : L_AMPERAMPER { Language.Ocaml.Abs.AMPERAMPER (mkPosToken $1) }

AMPERSAND :: { Language.Ocaml.Abs.AMPERSAND }
AMPERSAND  : L_AMPERSAND { Language.Ocaml.Abs.AMPERSAND (mkPosToken $1) }

BANG :: { Language.Ocaml.Abs.BANG }
BANG  : L_BANG { Language.Ocaml.Abs.BANG (mkPosToken $1) }

BARBAR :: { Language.Ocaml.Abs.BARBAR }
BARBAR  : L_BARBAR { Language.Ocaml.Abs.BARBAR (mkPosToken $1) }

COLONEQUAL :: { Language.Ocaml.Abs.COLONEQUAL }
COLONEQUAL  : L_COLONEQUAL { Language.Ocaml.Abs.COLONEQUAL (mkPosToken $1) }

EQUAL :: { Language.Ocaml.Abs.EQUAL }
EQUAL  : L_EQUAL { Language.Ocaml.Abs.EQUAL (mkPosToken $1) }

BANGEQUAL :: { Language.Ocaml.Abs.BANGEQUAL }
BANGEQUAL  : L_BANGEQUAL { Language.Ocaml.Abs.BANGEQUAL (mkPosToken $1) }

GREATER :: { Language.Ocaml.Abs.GREATER }
GREATER  : L_GREATER { Language.Ocaml.Abs.GREATER (mkPosToken $1) }

LESS :: { Language.Ocaml.Abs.LESS }
LESS  : L_LESS { Language.Ocaml.Abs.LESS (mkPosToken $1) }

MINUS :: { Language.Ocaml.Abs.MINUS }
MINUS  : L_MINUS { Language.Ocaml.Abs.MINUS (mkPosToken $1) }

MINUSDOT :: { Language.Ocaml.Abs.MINUSDOT }
MINUSDOT  : L_MINUSDOT { Language.Ocaml.Abs.MINUSDOT (mkPosToken $1) }

OR :: { Language.Ocaml.Abs.OR }
OR  : L_OR { Language.Ocaml.Abs.OR (mkPosToken $1) }

PERCENT :: { Language.Ocaml.Abs.PERCENT }
PERCENT  : L_PERCENT { Language.Ocaml.Abs.PERCENT (mkPosToken $1) }

PLUS :: { Language.Ocaml.Abs.PLUS }
PLUS  : L_PLUS { Language.Ocaml.Abs.PLUS (mkPosToken $1) }

PLUSDOT :: { Language.Ocaml.Abs.PLUSDOT }
PLUSDOT  : L_PLUSDOT { Language.Ocaml.Abs.PLUSDOT (mkPosToken $1) }

PLUSEQ :: { Language.Ocaml.Abs.PLUSEQ }
PLUSEQ  : L_PLUSEQ { Language.Ocaml.Abs.PLUSEQ (mkPosToken $1) }

STAR :: { Language.Ocaml.Abs.STAR }
STAR  : L_STAR { Language.Ocaml.Abs.STAR (mkPosToken $1) }

RELOP :: { Language.Ocaml.Abs.RELOP }
RELOP  : L_RELOP { Language.Ocaml.Abs.RELOP (mkPosToken $1) }

CONCATOP :: { Language.Ocaml.Abs.CONCATOP }
CONCATOP  : L_CONCATOP { Language.Ocaml.Abs.CONCATOP (mkPosToken $1) }

PLUSMINUSOP :: { Language.Ocaml.Abs.PLUSMINUSOP }
PLUSMINUSOP  : L_PLUSMINUSOP { Language.Ocaml.Abs.PLUSMINUSOP (mkPosToken $1) }

MULTDIVOP :: { Language.Ocaml.Abs.MULTDIVOP }
MULTDIVOP  : L_MULTDIVOP { Language.Ocaml.Abs.MULTDIVOP (mkPosToken $1) }

POWOP :: { Language.Ocaml.Abs.POWOP }
POWOP  : L_POWOP { Language.Ocaml.Abs.POWOP (mkPosToken $1) }

DOTOP :: { Language.Ocaml.Abs.DOTOP }
DOTOP  : L_DOTOP { Language.Ocaml.Abs.DOTOP (mkPosToken $1) }

LETOP :: { Language.Ocaml.Abs.LETOP }
LETOP  : L_LETOP { Language.Ocaml.Abs.LETOP (mkPosToken $1) }

ANDOP :: { Language.Ocaml.Abs.ANDOP }
ANDOP  : L_ANDOP { Language.Ocaml.Abs.ANDOP (mkPosToken $1) }

HASHOP :: { Language.Ocaml.Abs.HASHOP }
HASHOP  : L_HASHOP { Language.Ocaml.Abs.HASHOP (mkPosToken $1) }

PREFIXOP :: { Language.Ocaml.Abs.PREFIXOP }
PREFIXOP  : L_PREFIXOP { Language.Ocaml.Abs.PREFIXOP (mkPosToken $1) }

DecimalLiteral :: { Language.Ocaml.Abs.DecimalLiteral }
DecimalLiteral  : L_DecimalLiteral { Language.Ocaml.Abs.DecimalLiteral $1 }

DecimalLiteralModifier :: { Language.Ocaml.Abs.DecimalLiteralModifier }
DecimalLiteralModifier  : L_DecimalLiteralModifier { Language.Ocaml.Abs.DecimalLiteralModifier $1 }

HexLiteral :: { Language.Ocaml.Abs.HexLiteral }
HexLiteral  : L_HexLiteral { Language.Ocaml.Abs.HexLiteral $1 }

HexLiteralModifier :: { Language.Ocaml.Abs.HexLiteralModifier }
HexLiteralModifier  : L_HexLiteralModifier { Language.Ocaml.Abs.HexLiteralModifier $1 }

OctLiteral :: { Language.Ocaml.Abs.OctLiteral }
OctLiteral  : L_OctLiteral { Language.Ocaml.Abs.OctLiteral $1 }

OctLiteralModifier :: { Language.Ocaml.Abs.OctLiteralModifier }
OctLiteralModifier  : L_OctLiteralModifier { Language.Ocaml.Abs.OctLiteralModifier $1 }

BinLiteral :: { Language.Ocaml.Abs.BinLiteral }
BinLiteral  : L_BinLiteral { Language.Ocaml.Abs.BinLiteral $1 }

BinLiteralModifier :: { Language.Ocaml.Abs.BinLiteralModifier }
BinLiteralModifier  : L_BinLiteralModifier { Language.Ocaml.Abs.BinLiteralModifier $1 }

FLOAT :: { Language.Ocaml.Abs.FLOAT }
FLOAT  : L_FLOAT { Language.Ocaml.Abs.FLOAT $1 }

CHAR :: { Language.Ocaml.Abs.CHAR }
CHAR  : L_CHAR { Language.Ocaml.Abs.CHAR $1 }

STRING :: { Language.Ocaml.Abs.STRING }
STRING  : L_STRING { Language.Ocaml.Abs.STRING $1 }

QUOTED_STRING_EXPR :: { Language.Ocaml.Abs.QUOTED_STRING_EXPR }
QUOTED_STRING_EXPR  : L_QUOTED_STRING_EXPR { Language.Ocaml.Abs.QUOTED_STRING_EXPR $1 }

QUOTED_STRING_ITEM :: { Language.Ocaml.Abs.QUOTED_STRING_ITEM }
QUOTED_STRING_ITEM  : L_QUOTED_STRING_ITEM { Language.Ocaml.Abs.QUOTED_STRING_ITEM $1 }

LIDENT :: { Language.Ocaml.Abs.LIDENT }
LIDENT  : L_LIDENT { Language.Ocaml.Abs.LIDENT (mkPosToken $1) }

UIDENT :: { Language.Ocaml.Abs.UIDENT }
UIDENT  : L_UIDENT { Language.Ocaml.Abs.UIDENT $1 }

LABEL :: { Language.Ocaml.Abs.LABEL }
LABEL  : L_LABEL { Language.Ocaml.Abs.LABEL (mkPosToken $1) }

OPTLABEL :: { Language.Ocaml.Abs.OPTLABEL }
OPTLABEL  : L_OPTLABEL { Language.Ocaml.Abs.OPTLABEL (mkPosToken $1) }

INT :: { Language.Ocaml.Abs.INT }
INT
  : DecimalLiteralModifier { Language.Ocaml.Abs.ModifiedDecimal $1 }
  | DecimalLiteral { Language.Ocaml.Abs.Decimal $1 }
  | HexLiteralModifier { Language.Ocaml.Abs.ModifiedHex $1 }
  | HexLiteral { Language.Ocaml.Abs.Hex $1 }
  | OctLiteralModifier { Language.Ocaml.Abs.ModifiedOct $1 }
  | OctLiteral { Language.Ocaml.Abs.Oct $1 }
  | BinLiteralModifier { Language.Ocaml.Abs.ModifiedBin $1 }
  | BinLiteral { Language.Ocaml.Abs.Bin $1 }

Implementation :: { Language.Ocaml.Abs.Implementation }
Implementation
  : '#' DecimalLiteral STRING Structure { Language.Ocaml.Abs.ImplementationWithLineNumber $2 $3 $4 }
  | Structure { Language.Ocaml.Abs.Implementation $1 }

Interface :: { Language.Ocaml.Abs.Interface }
Interface : Signature { Language.Ocaml.Abs.Interface $1 }

ListStructureItem :: { [Language.Ocaml.Abs.StructureItem] }
ListStructureItem
  : {- empty -} { [] }
  | StructureItem ListStructureItem { (:) $1 $2 }

ToplevelPhrase :: { Language.Ocaml.Abs.ToplevelPhrase }
ToplevelPhrase
  : SeqExpr ListPostItemAttribute ';;' { Language.Ocaml.Abs.StrExpr $1 $2 }
  | ListStructureItem ';;' { Language.Ocaml.Abs.StructureItems $1 }
  | ToplevelDirective ';;' { Language.Ocaml.Abs.ToplevelDirective $1 }

UseFile :: { Language.Ocaml.Abs.UseFile }
UseFile
  : ListUseFileElement { Language.Ocaml.Abs.UseFile $1 }
  | SeqExpr ListPostItemAttribute ListUseFileElement { Language.Ocaml.Abs.UseFileWithStrExp $1 $2 $3 }

ListUseFileElement :: { [Language.Ocaml.Abs.UseFileElement] }
ListUseFileElement
  : {- empty -} { [] }
  | UseFileElement ListUseFileElement { (:) $1 $2 }

UseFileElement :: { Language.Ocaml.Abs.UseFileElement }
UseFileElement
  : ';;' { Language.Ocaml.Abs.NoUseFileElement }
  | ';;' SeqExpr ListPostItemAttribute { Language.Ocaml.Abs.UseFileStrExp $2 $3 }
  | StructureItem { Language.Ocaml.Abs.UseFileStructureItem $1 }
  | ToplevelDirective { Language.Ocaml.Abs.UseFileToplevelDirective $1 }

ListFunctorArg :: { [Language.Ocaml.Abs.FunctorArg] }
ListFunctorArg
  : FunctorArg { (:[]) $1 } | FunctorArg ListFunctorArg { (:) $1 $2 }

FunctorArg :: { Language.Ocaml.Abs.FunctorArg }
FunctorArg
  : '(' ')' { Language.Ocaml.Abs.NoFunctorArg }
  | '(' ModuleName ':' ModuleType ')' { Language.Ocaml.Abs.FunctorArg $2 $4 }

ModuleName :: { Language.Ocaml.Abs.ModuleName }
ModuleName
  : UIDENT { Language.Ocaml.Abs.ModuleNameIdent $1 }
  | '_' { Language.Ocaml.Abs.ModuleNameUnderscore }

ModuleExpr :: { Language.Ocaml.Abs.ModuleExpr }
ModuleExpr
  : 'struct' ListAttribute Structure 'end' { Language.Ocaml.Abs.ModuleExprStruct $2 $3 }
  | 'functor' ListAttribute ListFunctorArg '->' ModuleExpr { Language.Ocaml.Abs.ModuleExprFunctor $2 $3 $5 }
  | ParenModuleExpr { Language.Ocaml.Abs.ModuleExprParen $1 }
  | ModuleExpr Attribute { Language.Ocaml.Abs.ModuleExprWithAttribute $1 $2 }
  | ModLongident { Language.Ocaml.Abs.ModuleExprIdent $1 }
  | ModuleExpr ParenModuleExpr { Language.Ocaml.Abs.ModuleExprFunctorApp $1 $2 }
  | ModuleExpr '(' ')' { Language.Ocaml.Abs.FunctorAppUnit $1 }
  | Extension { Language.Ocaml.Abs.ModuleExprExtension $1 }

ParenModuleExpr :: { Language.Ocaml.Abs.ParenModuleExpr }
ParenModuleExpr
  : '(' ModuleExpr ':' ModuleType ')' { Language.Ocaml.Abs.ModuleExprWithType $2 $4 }
  | '(' ModuleExpr ')' { Language.Ocaml.Abs.ModuleExpr $2 }
  | '(' 'val' ListAttribute ExprColonPackageType ')' { Language.Ocaml.Abs.ValParenModuleExpr $3 $4 }

ExprColonPackageType :: { Language.Ocaml.Abs.ExprColonPackageType }
ExprColonPackageType
  : Expr { Language.Ocaml.Abs.Expr $1 }
  | Expr ':' ModuleType { Language.Ocaml.Abs.ExprWithType $1 $3 }
  | Expr ':' ModuleType ':>' ModuleType { Language.Ocaml.Abs.ExprWithCoercionFromTo $1 $3 $5 }
  | Expr ':>' ModuleType { Language.Ocaml.Abs.ExprWithCoercionTo $1 $3 }

Structure :: { Language.Ocaml.Abs.Structure }
Structure
  : SeqExpr ListPostItemAttribute ListStructureElement { Language.Ocaml.Abs.WithStandaloneExpression $1 $2 $3 }
  | ListStructureElement { Language.Ocaml.Abs.WithoutStandaloneExpression $1 }

ListStructureElement :: { [Language.Ocaml.Abs.StructureElement] }
ListStructureElement
  : {- empty -} { [] }
  | StructureElement ListStructureElement { (:) $1 $2 }
  | ';;' ListStructureElement { $2 }

StructureElement :: { Language.Ocaml.Abs.StructureElement }
StructureElement
  : ';;' SeqExpr ListPostItemAttribute { Language.Ocaml.Abs.StandaloneExpression $2 $3 }
  | StructureItem { Language.Ocaml.Abs.StructureItem $1 }

StructureItem :: { Language.Ocaml.Abs.StructureItem }
StructureItem
  : LetBindingsExt { Language.Ocaml.Abs.StrLetBindings $1 }
  | ItemExtension ListPostItemAttribute { Language.Ocaml.Abs.StrItemExtension $1 $2 }
  | FloatingAttribute { Language.Ocaml.Abs.StrFloatingAttribute $1 }
  | PrimitiveDeclaration { Language.Ocaml.Abs.StrPrimitiveDeclaration $1 }
  | ValueDescription { Language.Ocaml.Abs.StrValueDescription $1 }
  | TypeDeclaration ListAndTypeDeclaration { Language.Ocaml.Abs.StrTypeDeclarations $1 $2 }
  | 'type' Ext ListAttribute TypeParameters TypeLongident PLUSEQ PrivateFlag BarLlistExtensionConstructor ListPostItemAttribute { Language.Ocaml.Abs.StrTypeExtension $2 $3 $4 $5 $6 $7 $8 $9 }
  | StrExceptionDeclaration { Language.Ocaml.Abs.StrExceptionDeclaration $1 }
  | 'module' Ext ListAttribute ModuleName ModuleBindingBody ListPostItemAttribute { Language.Ocaml.Abs.StrModuleBinding $2 $3 $4 $5 $6 }
  | 'module' Ext ListAttribute 'rec' ModuleName ModuleBindingBody ListPostItemAttribute ListAndModuleBinding { Language.Ocaml.Abs.StrRecModuleBindings $2 $3 $5 $6 $7 $8 }
  | ModuleTypeDeclaration { Language.Ocaml.Abs.StrModuleTypeDeclaration $1 }
  | OpenDeclaration { Language.Ocaml.Abs.StrOpenDeclaration $1 }
  | 'class' Ext ListAttribute VirtualFlag FormalClassParameters LIDENT ClassFunBinding ListPostItemAttribute ListAndClassDeclaration { Language.Ocaml.Abs.StrClassDeclarations $2 $3 $4 $5 $6 $7 $8 $9 }
  | ClassTypeDeclarations { Language.Ocaml.Abs.StrClassTypeDeclarations $1 }
  | 'include' Ext ListAttribute ModuleExpr ListPostItemAttribute { Language.Ocaml.Abs.StrIncludeStatement $2 $3 $4 $5 }

ModuleBindingBody :: { Language.Ocaml.Abs.ModuleBindingBody }
ModuleBindingBody
  : EQUAL ModuleExpr { Language.Ocaml.Abs.ModuleBinding $1 $2 }
  | ':' ModuleType EQUAL ModuleExpr { Language.Ocaml.Abs.ModuleBindingWitgType $2 $3 $4 }
  | FunctorArg ModuleBindingBody { Language.Ocaml.Abs.FunctorBinding $1 $2 }

ListAndModuleBinding :: { [Language.Ocaml.Abs.AndModuleBinding] }
ListAndModuleBinding
  : {- empty -} { [] }
  | 'and' AndModuleBinding ListAndModuleBinding { (:) $2 $3 }

AndModuleBinding :: { Language.Ocaml.Abs.AndModuleBinding }
AndModuleBinding
  : ListAttribute ModuleName ModuleBindingBody ListPostItemAttribute { Language.Ocaml.Abs.AndModuleBinding $1 $2 $3 $4 }

OptionalModuleType :: { Language.Ocaml.Abs.OptionalModuleType }
OptionalModuleType
  : {- empty -} { Language.Ocaml.Abs.NoModuleType }
  | EQUAL ModuleType { Language.Ocaml.Abs.AModuleType $1 $2 }

ModuleTypeDeclaration :: { Language.Ocaml.Abs.ModuleTypeDeclaration }
ModuleTypeDeclaration
  : 'module' 'type' Ext ListAttribute OCamlIdent OptionalModuleType ListPostItemAttribute { Language.Ocaml.Abs.ModuleTypeDeclaration $3 $4 $5 $6 $7 }

OpenDeclaration :: { Language.Ocaml.Abs.OpenDeclaration }
OpenDeclaration
  : 'open' OverrideFlag Ext ListAttribute ModuleExpr ListPostItemAttribute { Language.Ocaml.Abs.OpenDeclaration $2 $3 $4 $5 $6 }

OpenDescription :: { Language.Ocaml.Abs.OpenDescription }
OpenDescription
  : 'open' OverrideFlag Ext ListAttribute ModExtLongident ListPostItemAttribute { Language.Ocaml.Abs.OpenDescription $2 $3 $4 $5 $6 }

ListWithConstraint :: { [Language.Ocaml.Abs.WithConstraint] }
ListWithConstraint
  : WithConstraint { (:[]) $1 }
  | WithConstraint 'and' ListWithConstraint { (:) $1 $3 }

ModuleType :: { Language.Ocaml.Abs.ModuleType }
ModuleType
  : 'sig' ListAttribute Signature 'end' { Language.Ocaml.Abs.ModuleTypeSignature $2 $3 }
  | 'functor' ListAttribute ListFunctorArg '->' ModuleType { Language.Ocaml.Abs.ModuleTypeFunctor $2 $3 $5 }
  | 'module' 'type' 'of' ListAttribute ModuleExpr { Language.Ocaml.Abs.ModuleTypeOf $4 $5 }
  | '(' ModuleType ')' { Language.Ocaml.Abs.ModuleType $2 }
  | ModuleType Attribute { Language.Ocaml.Abs.ModuleTypeWithAttribute $1 $2 }
  | ModLongident { Language.Ocaml.Abs.ModuleTypeModuleIdent $1 }
  | '(' ')' '->' ModuleType { Language.Ocaml.Abs.ModuleTypeNoArgFunctorApp $4 }
  | ModuleType '->' ModuleType { Language.Ocaml.Abs.ModuleTypeFunctorApp $1 $3 }
  | ModuleType 'with' ListWithConstraint { Language.Ocaml.Abs.ModuleTypeWith $1 $3 }
  | Extension { Language.Ocaml.Abs.ModuleTypeExtension $1 }

Signature :: { Language.Ocaml.Abs.Signature }
Signature
  : ListSignatureElement { Language.Ocaml.Abs.Signature $1 }

ListSignatureElement :: { [Language.Ocaml.Abs.SignatureElement] }
ListSignatureElement
  : {- empty -} { [] }
  | SignatureElement ListSignatureElement { (:) $1 $2 }

SignatureElement :: { Language.Ocaml.Abs.SignatureElement }
SignatureElement
  : ';;' { Language.Ocaml.Abs.SigSemiSemi }
  | SignatureItem { Language.Ocaml.Abs.SigItem $1 }

SignatureItem :: { Language.Ocaml.Abs.SignatureItem }
SignatureItem
  : ItemExtension ListPostItemAttribute { Language.Ocaml.Abs.SigItemExtension $1 $2 }
  | FloatingAttribute { Language.Ocaml.Abs.SigFloatingAttribute $1 }
  | ValueDescription { Language.Ocaml.Abs.SigValueDescription $1 }
  | PrimitiveDeclaration { Language.Ocaml.Abs.SigPrimitiveDeclaration $1 }
  | TypeDeclaration ListAndTypeDeclaration { Language.Ocaml.Abs.SigTypeDeclarations $1 $2 }
  | TypeSubstDeclarations { Language.Ocaml.Abs.SigTypeSubstDeclarations $1 }
  | 'type' Ext ListAttribute TypeParameters TypeLongident PLUSEQ PrivateFlag BarLlistExtensionConstructorDeclaration ListPostItemAttribute { Language.Ocaml.Abs.SigTypeExtension $2 $3 $4 $5 $6 $7 $8 $9 }
  | SigExceptionDeclaration { Language.Ocaml.Abs.SigSigExceptionDeclaration $1 }
  | 'module' Ext ListAttribute ModuleName ModuleDeclarationBody ListPostItemAttribute { Language.Ocaml.Abs.SigModuleDeclaration $2 $3 $4 $5 $6 }
  | 'module' Ext ListAttribute ModuleName EQUAL ModLongident ListPostItemAttribute { Language.Ocaml.Abs.SigModuleAlias $2 $3 $4 $5 $6 $7 }
  | ModuleSubst { Language.Ocaml.Abs.SigModuleSubst $1 }
  | 'module' Ext ListAttribute 'rec' ModuleName ':' ModuleType ListPostItemAttribute ListAndModuleDeclaration { Language.Ocaml.Abs.SigRecModuleDeclarations $2 $3 $5 $7 $8 $9 }
  | ModuleTypeDeclaration { Language.Ocaml.Abs.SigModuleTypeDeclaration $1 }
  | ModuleTypeSubst { Language.Ocaml.Abs.SigModuleTypeSubst $1 }
  | OpenDescription { Language.Ocaml.Abs.SigOpenDescription $1 }
  | 'include' Ext ListAttribute ModuleType ListPostItemAttribute { Language.Ocaml.Abs.SigIncludeStatement $2 $3 $4 $5 }
  | 'class' Ext ListAttribute VirtualFlag FormalClassParameters LIDENT ':' ClassType ListPostItemAttribute ListAndClassDescription { Language.Ocaml.Abs.SigClassDescription $2 $3 $4 $5 $6 $8 $9 $10 }
  | ClassTypeDeclarations { Language.Ocaml.Abs.SigClassTypeDeclarations $1 }

ModuleDeclarationBody :: { Language.Ocaml.Abs.ModuleDeclarationBody }
ModuleDeclarationBody
  : ':' ModuleType { Language.Ocaml.Abs.ModuleBody $2 }
  | FunctorArg ModuleDeclarationBody { Language.Ocaml.Abs.FunctorBody $1 $2 }

ModuleSubst :: { Language.Ocaml.Abs.ModuleSubst }
ModuleSubst
  : 'module' Ext ListAttribute UIDENT COLONEQUAL ModExtLongident ListPostItemAttribute { Language.Ocaml.Abs.ModuleSubst $2 $3 $4 $5 $6 $7 }

AndModuleDeclaration :: { Language.Ocaml.Abs.AndModuleDeclaration }
AndModuleDeclaration
  : ListAttribute ModuleName ':' ModuleType ListPostItemAttribute { Language.Ocaml.Abs.AndModuleDeclaration $1 $2 $4 $5 }

ListAndModuleDeclaration :: { [Language.Ocaml.Abs.AndModuleDeclaration] }
ListAndModuleDeclaration
  : {- empty -} { [] }
  | AndModuleDeclaration { (:[]) $1 }
  | AndModuleDeclaration 'and' ListAndModuleDeclaration { (:) $1 $3 }

ModuleTypeSubst :: { Language.Ocaml.Abs.ModuleTypeSubst }
ModuleTypeSubst
  : 'module' 'type' Ext ListAttribute OCamlIdent COLONEQUAL ModuleType ListPostItemAttribute { Language.Ocaml.Abs.ModuleTypeSubst $3 $4 $5 $6 $7 $8 }

AndClassDeclaration :: { Language.Ocaml.Abs.AndClassDeclaration }
AndClassDeclaration
  : 'and' ListAttribute VirtualFlag FormalClassParameters LIDENT ClassFunBinding ListPostItemAttribute { Language.Ocaml.Abs.AndClassDeclaration $2 $3 $4 $5 $6 $7 }

ListAndClassDeclaration :: { [Language.Ocaml.Abs.AndClassDeclaration] }
ListAndClassDeclaration
  : {- empty -} { [] }
  | AndClassDeclaration ListAndClassDeclaration { (:) $1 $2 }

ClassFunBinding :: { Language.Ocaml.Abs.ClassFunBinding }
ClassFunBinding
  : EQUAL ClassExpr { Language.Ocaml.Abs.ClassFunBinding $1 $2 }
  | ':' ClassType EQUAL ClassExpr { Language.Ocaml.Abs.ClassFunBindingWithType $2 $3 $4 }
  | LabeledSimplePattern ClassFunBinding { Language.Ocaml.Abs.LabeledClassFunBinding $1 $2 }

FormalClassParameters :: { Language.Ocaml.Abs.FormalClassParameters }
FormalClassParameters
  : {- empty -} { Language.Ocaml.Abs.NoFormalClassParamters }
  | '[' ListTypeParameter ']' { Language.Ocaml.Abs.FormalClassParameters $2 }

ClassExpr :: { Language.Ocaml.Abs.ClassExpr }
ClassExpr
  : ClassSimpleExpr { Language.Ocaml.Abs.ClassSimpleExpr $1 }
  | 'fun' ListAttribute ClassFunDef { Language.Ocaml.Abs.ClassExprFunctor $2 $3 }
  | LetBindingsNoExt 'in' ClassExpr { Language.Ocaml.Abs.ClassExprLetBindings $1 $3 }
  | 'let' 'open' OverrideFlag ListAttribute ModLongident 'in' ClassExpr { Language.Ocaml.Abs.ClassExprLetOpen $3 $4 $5 $7 }
  | ClassExpr Attribute { Language.Ocaml.Abs.ClassExprWithAttribute $1 $2 }
  | ClassSimpleExpr ListLabeledSimpleExpr { Language.Ocaml.Abs.LabeledClassSimpleExpr $1 $2 }
  | Extension { Language.Ocaml.Abs.ClassExprExtension $1 }

ClassSimpleExpr :: { Language.Ocaml.Abs.ClassSimpleExpr }
ClassSimpleExpr
  : '(' ClassExpr ')' { Language.Ocaml.Abs.ClassExpr $2 }
  | ClassLongident { Language.Ocaml.Abs.ClassName $1 }
  | '[' ListCoreType ']' ClassLongident { Language.Ocaml.Abs.ClassNameWithParamters $2 $4 }
  | '(' ClassExpr ':' ClassType ')' { Language.Ocaml.Abs.ClassExprWithType $2 $4 }
  | 'object' ListAttribute ClassSelfPattern ListClassField 'end' { Language.Ocaml.Abs.ClassSimplExprObject $2 $3 $4 }

ClassFunDef :: { Language.Ocaml.Abs.ClassFunDef }
ClassFunDef
  : LabeledSimplePattern '->' ClassExpr { Language.Ocaml.Abs.ClassFun $1 $3 }
  | LabeledSimplePattern ClassFunDef { Language.Ocaml.Abs.LabeledClassFunDef $1 $2 }

ClassSelfPattern :: { Language.Ocaml.Abs.ClassSelfPattern }
ClassSelfPattern
  : '(' Pattern ')' { Language.Ocaml.Abs.ClassPattern $2 }
  | '(' Pattern ':' CoreType ')' { Language.Ocaml.Abs.ClassPatternWithType $2 $4 }
  | {- empty -} { Language.Ocaml.Abs.NoClassSelfPattern }

ListClassField :: { [Language.Ocaml.Abs.ClassField] }
ListClassField
  : {- empty -} { [] } | ClassField ListClassField { (:) $1 $2 }

OptionalAs :: { Language.Ocaml.Abs.OptionalAs }
OptionalAs
  : {- empty -} { Language.Ocaml.Abs.NoAs }
  | 'as' LIDENT { Language.Ocaml.Abs.AAs $2 }

ClassField :: { Language.Ocaml.Abs.ClassField }
ClassField
  : 'inherit' OverrideFlag ListAttribute ClassExpr OptionalAs ListPostItemAttribute { Language.Ocaml.Abs.ClassFieldInherit $2 $3 $4 $5 $6 }
  | 'val' Value ListPostItemAttribute { Language.Ocaml.Abs.ClassFieldVal $2 $3 }
  | 'method' Method_ ListPostItemAttribute { Language.Ocaml.Abs.ClassFieldMethod $2 $3 }
  | 'constraint' ListAttribute CoreType EQUAL CoreType ListPostItemAttribute { Language.Ocaml.Abs.ClassFieldConstraint $2 $3 $4 $5 $6 }
  | 'initializer' ListAttribute SeqExpr ListPostItemAttribute { Language.Ocaml.Abs.ClassFieldInitializer $2 $3 $4 }
  | ItemExtension ListPostItemAttribute { Language.Ocaml.Abs.ClassFieldItemExtension $1 $2 }
  | FloatingAttribute { Language.Ocaml.Abs.ClassFieldFloatingAttribute $1 }

Value :: { Language.Ocaml.Abs.Value }
Value
  : NoOverrideFlag ListAttribute VirtualWithMutableFlag LIDENT ':' CoreType { Language.Ocaml.Abs.Value1 $1 $2 $3 $4 $6 }
  | OverrideFlag ListAttribute MutableFlag LIDENT EQUAL SeqExpr { Language.Ocaml.Abs.Value2 $1 $2 $3 $4 $5 $6 }
  | OverrideFlag ListAttribute MutableFlag LIDENT TypeConstraint EQUAL SeqExpr { Language.Ocaml.Abs.Value3 $1 $2 $3 $4 $5 $6 $7 }

Method_ :: { Language.Ocaml.Abs.Method_ }
Method_
  : NoOverrideFlag ListAttribute VirtualWithPrivateFlag LIDENT ':' PolyType { Language.Ocaml.Abs.VirtualMethod $1 $2 $3 $4 $6 }
  | OverrideFlag ListAttribute PrivateFlag LIDENT StrictBinding { Language.Ocaml.Abs.Method $1 $2 $3 $4 $5 }
  | OverrideFlag ListAttribute PrivateFlag LIDENT ':' PolyType EQUAL SeqExpr { Language.Ocaml.Abs.MethodWithType $1 $2 $3 $4 $6 $7 $8 }
  | OverrideFlag ListAttribute PrivateFlag LIDENT ':' 'type' ListLIDENT '.' CoreType EQUAL SeqExpr { Language.Ocaml.Abs.MethodWithLocallyAbstractType $1 $2 $3 $4 $7 $9 $10 $11 }

ClassType :: { Language.Ocaml.Abs.ClassType }
ClassType
  : ClassSignature { Language.Ocaml.Abs.ClassSignature $1 }
  | OptLabel TupleType '->' ClassType { Language.Ocaml.Abs.ClassTypeWithOptLabel $1 $2 $4 }
  | '?' LIDENT ':' TupleType '->' ClassType { Language.Ocaml.Abs.ClassTypeWithOptionalLabel $2 $4 $6 }
  | LIDENT ':' TupleType '->' ClassType { Language.Ocaml.Abs.ClassTypeWithtLabel $1 $3 $5 }
  | TupleType '->' ClassType { Language.Ocaml.Abs.ClassTypeWithoutLabel $1 $3 }

ClassSignature :: { Language.Ocaml.Abs.ClassSignature }
ClassSignature
  : CltyLongident { Language.Ocaml.Abs.ClassSignatureName $1 }
  | '[' ListCoreType ']' CltyLongident { Language.Ocaml.Abs.ClassSignatureNameWithParamters $2 $4 }
  | Extension { Language.Ocaml.Abs.ClassSignatureExtension $1 }
  | 'object' ListAttribute ClassSelfType ListClassSigField 'end' { Language.Ocaml.Abs.ClassSignatureObject $2 $3 $4 }
  | ClassSignature Attribute { Language.Ocaml.Abs.WithAttribute $1 $2 }
  | 'let' 'open' OverrideFlag ListAttribute ModLongident 'in' ClassSignature { Language.Ocaml.Abs.ClassSignatureLetOpen $3 $4 $5 $7 }

ClassSelfType :: { Language.Ocaml.Abs.ClassSelfType }
ClassSelfType
  : '(' CoreType ')' { Language.Ocaml.Abs.ClassSelfType $2 }
  | {- empty -} { Language.Ocaml.Abs.NoClassSelfType }

ClassSigField :: { Language.Ocaml.Abs.ClassSigField }
ClassSigField
  : 'inherit' ListAttribute ClassSignature ListPostItemAttribute { Language.Ocaml.Abs.ClassSigFieldInherit $2 $3 $4 }
  | 'val' ListAttribute MutableVirtualFlags LIDENT ':' CoreType ListPostItemAttribute { Language.Ocaml.Abs.ClassSigFieldVal $2 $3 $4 $6 $7 }
  | 'method' ListAttribute PrivateVirtualFlags LIDENT ':' PolyType ListPostItemAttribute { Language.Ocaml.Abs.ClassSigFieldMethod $2 $3 $4 $6 $7 }
  | 'constraint' ListAttribute ConstrainField ListPostItemAttribute { Language.Ocaml.Abs.ClassSigFieldConstraint $2 $3 $4 }
  | ItemExtension ListPostItemAttribute { Language.Ocaml.Abs.ClassSigFieldItemExtension $1 $2 }
  | FloatingAttribute { Language.Ocaml.Abs.ClassSigFieldFloatingAttribute $1 }

ConstrainField :: { Language.Ocaml.Abs.ConstrainField }
ConstrainField
  : CoreType EQUAL CoreType { Language.Ocaml.Abs.ConstrainField $1 $2 $3 }

ListClassSigField :: { [Language.Ocaml.Abs.ClassSigField] }
ListClassSigField
  : {- empty -} { [] }
  | ClassSigField ListClassSigField { (:) $1 $2 }

AndClassDescription :: { Language.Ocaml.Abs.AndClassDescription }
AndClassDescription
  : 'and' ListAttribute VirtualFlag FormalClassParameters LIDENT ':' ClassType ListPostItemAttribute { Language.Ocaml.Abs.AndClassDescription $2 $3 $4 $5 $7 $8 }

ListAndClassDescription :: { [Language.Ocaml.Abs.AndClassDescription] }
ListAndClassDescription
  : {- empty -} { [] }
  | AndClassDescription ListAndClassDescription { (:) $1 $2 }

ClassTypeDeclarations :: { Language.Ocaml.Abs.ClassTypeDeclarations }
ClassTypeDeclarations
  : 'class' 'type' Ext ListAttribute VirtualFlag FormalClassParameters LIDENT EQUAL ClassSignature ListPostItemAttribute ListAndClassTypeDeclaration { Language.Ocaml.Abs.ClassTypeDeclarations $3 $4 $5 $6 $7 $8 $9 $10 $11 }

AndClassTypeDeclaration :: { Language.Ocaml.Abs.AndClassTypeDeclaration }
AndClassTypeDeclaration
  : ListAttribute VirtualFlag FormalClassParameters LIDENT EQUAL ClassSignature ListPostItemAttribute { Language.Ocaml.Abs.AndClassTypeDeclaration $1 $2 $3 $4 $5 $6 $7 }

ListAndClassTypeDeclaration :: { [Language.Ocaml.Abs.AndClassTypeDeclaration] }
ListAndClassTypeDeclaration
  : {- empty -} { [] }
  | AndClassTypeDeclaration { (:[]) $1 }
  | AndClassTypeDeclaration 'and' ListAndClassTypeDeclaration { (:) $1 $3 }

SeqExpr :: { Language.Ocaml.Abs.SeqExpr }
SeqExpr
  : FunExpr1 { Language.Ocaml.Abs.FinalFunExpr $1 }
  | FunExpr1 ';' { Language.Ocaml.Abs.FinalFunExprSemi $1 }
  | FunExpr1 ';' SeqExpr { Language.Ocaml.Abs.MoreFunExprs $1 $3 }
  | FunExpr1 ';' PERCENT ListAttrId SeqExpr { Language.Ocaml.Abs.MoreFunExprsAttr $1 $3 $4 $5 }
  | 'function' Ext ListAttribute ListMatchCase { Language.Ocaml.Abs.SeqExprFunction $2 $3 $4 }

LabeledSimplePattern :: { Language.Ocaml.Abs.LabeledSimplePattern }
LabeledSimplePattern
  : '?' '(' LabelLetPattern ')' { Language.Ocaml.Abs.OptPattern $3 }
  | '?' '(' LabelLetPattern EQUAL SeqExpr ')' { Language.Ocaml.Abs.OptPatternWithDefault $3 $4 $5 }
  | '?' LIDENT { Language.Ocaml.Abs.OptLabelPattern $2 }
  | OPTLABEL '(' LetPattern ')' { Language.Ocaml.Abs.OptLabeledPattern $1 $3 }
  | OPTLABEL '(' LetPattern EQUAL SeqExpr ')' { Language.Ocaml.Abs.OptLabeledPatternWithDefault $1 $3 $4 $5 }
  | OPTLABEL PatternVar { Language.Ocaml.Abs.OptLabeledVar $1 $2 }
  | '~' '(' LabelLetPattern ')' { Language.Ocaml.Abs.LabeledPattern $3 }
  | '~' LIDENT { Language.Ocaml.Abs.Label $2 }
  | LABEL SimplePattern { Language.Ocaml.Abs.LabeledSimplePattern $1 $2 }
  | SimplePattern { Language.Ocaml.Abs.SimplePattern $1 }

PatternVar :: { Language.Ocaml.Abs.PatternVar }
PatternVar
  : LIDENT { Language.Ocaml.Abs.PatternVar $1 }
  | '_' { Language.Ocaml.Abs.UnderscorePatternVar }

LabelLetPattern :: { Language.Ocaml.Abs.LabelLetPattern }
LabelLetPattern
  : LIDENT { Language.Ocaml.Abs.LabelVar $1 }
  | LIDENT ':' CoreType { Language.Ocaml.Abs.LabelVarWithType $1 $3 }

LetPattern :: { Language.Ocaml.Abs.LetPattern }
LetPattern
  : Pattern { Language.Ocaml.Abs.LetPattern $1 }
  | Pattern ':' CoreType { Language.Ocaml.Abs.LetPatternWithType $1 $3 }

QualifiedDotop :: { Language.Ocaml.Abs.QualifiedDotop }
QualifiedDotop
  : DOTOP { Language.Ocaml.Abs.Unqualified $1 }
  | '.' ModLongident DOTOP { Language.Ocaml.Abs.Qualified $2 $3 }

OptionalAtomicTypeAnnotation :: { Language.Ocaml.Abs.OptionalAtomicTypeAnnotation }
OptionalAtomicTypeAnnotation
  : {- empty -} { Language.Ocaml.Abs.NoAtomicTypeAnnotation }
  | ':' AtomicType { Language.Ocaml.Abs.AnAtomicTypeAnnotation $2 }

FunExpr15 :: { Language.Ocaml.Abs.FunExpr }
FunExpr15
  : SimpleExpr16 ListLabeledSimpleExpr { Language.Ocaml.Abs.SimpleExprApp $1 $2 }
  | ConstrLongident SimpleExpr16 { Language.Ocaml.Abs.ConstrApp $1 $2 }
  | NameTag SimpleExpr16 { Language.Ocaml.Abs.NameTagApp $1 $2 }
  | 'assert' Ext ListAttribute SimpleExpr16 { Language.Ocaml.Abs.Assert $2 $3 $4 }
  | 'lazy' Ext ListAttribute SimpleExpr16 { Language.Ocaml.Abs.Lazy $2 $3 $4 }
  | SimpleExpr16 { Language.Ocaml.Abs.SimpleExpr $1 }

FunExpr14 :: { Language.Ocaml.Abs.FunExpr }
FunExpr14
  : Subtractive Expr15 { Language.Ocaml.Abs.Subtractive $1 $2 }
  | Additive Expr15 { Language.Ocaml.Abs.Additive $1 $2 }
  | FunExpr15 { $1 }

FunExpr13 :: { Language.Ocaml.Abs.FunExpr }
FunExpr13
  : FunExpr14 POWOP Expr13 { Language.Ocaml.Abs.PowInfix $1 $2 $3 }
  | FunExpr14 { $1 }

FunExpr12 :: { Language.Ocaml.Abs.FunExpr }
FunExpr12
  : FunExpr12 MULTDIVOP Expr13 { Language.Ocaml.Abs.MultDivInfix $1 $2 $3 }
  | FunExpr12 STAR Expr13 { Language.Ocaml.Abs.MultInfix $1 $2 $3 }
  | FunExpr12 PERCENT Expr13 { Language.Ocaml.Abs.ModInfix $1 $2 $3 }
  | FunExpr13 { $1 }

FunExpr11 :: { Language.Ocaml.Abs.FunExpr }
FunExpr11
  : FunExpr11 PLUSMINUSOP Expr12 { Language.Ocaml.Abs.PlusMinusInfix $1 $2 $3 }
  | FunExpr11 PLUS Expr12 { Language.Ocaml.Abs.PlusInfix $1 $2 $3 }
  | FunExpr11 PLUSDOT Expr12 { Language.Ocaml.Abs.PlusDotInfix $1 $2 $3 }
  | FunExpr11 PLUSEQ Expr12 { Language.Ocaml.Abs.PlusEqInfix $1 $2 $3 }
  | FunExpr11 MINUS Expr12 { Language.Ocaml.Abs.MinusInfix $1 $2 $3 }
  | FunExpr11 MINUSDOT Expr12 { Language.Ocaml.Abs.MinusDotInfix $1 $2 $3 }
  | FunExpr12 { $1 }

FunExpr10 :: { Language.Ocaml.Abs.FunExpr }
FunExpr10
  : FunExpr11 '::' Expr10 { Language.Ocaml.Abs.Cons $1 $3 }
  | FunExpr11 { $1 }

FunExpr9 :: { Language.Ocaml.Abs.FunExpr }
FunExpr9
  : FunExpr10 CONCATOP Expr9 { Language.Ocaml.Abs.ConcatInfix $1 $2 $3 }
  | FunExpr10 { $1 }

FunExpr8 :: { Language.Ocaml.Abs.FunExpr }
FunExpr8
  : FunExpr8 RELOP Expr9 { Language.Ocaml.Abs.RelInfix $1 $2 $3 }
  | FunExpr8 EQUAL Expr9 { Language.Ocaml.Abs.EqualInfix $1 $2 $3 }
  | FunExpr8 LESS Expr9 { Language.Ocaml.Abs.LessInfix $1 $2 $3 }
  | FunExpr8 GREATER Expr9 { Language.Ocaml.Abs.GreaterInfix $1 $2 $3 }
  | FunExpr8 BANGEQUAL Expr9 { Language.Ocaml.Abs.NotEqualInfix $1 $2 $3 }
  | FunExpr9 { $1 }

FunExpr7 :: { Language.Ocaml.Abs.FunExpr }
FunExpr7
  : FunExpr8 AMPERSAND Expr7 { Language.Ocaml.Abs.AmpersandInfix $1 $2 $3 }
  | FunExpr8 AMPERAMPER Expr7 { Language.Ocaml.Abs.AmperAmperInfix $1 $2 $3 }
  | FunExpr8 { $1 }

FunExpr6 :: { Language.Ocaml.Abs.FunExpr }
FunExpr6
  : FunExpr7 OR Expr6 { Language.Ocaml.Abs.OrInfix $1 $2 $3 }
  | FunExpr7 BARBAR Expr6 { Language.Ocaml.Abs.BarBarInfix $1 $2 $3 }
  | FunExpr7 { $1 }

FunExpr5 :: { Language.Ocaml.Abs.FunExpr }
FunExpr5
  : Expr6 ',' ListExprComma { Language.Ocaml.Abs.Comma $1 $3 }
  | FunExpr6 { $1 }

FunExpr4 :: { Language.Ocaml.Abs.FunExpr }
FunExpr4
  : LIDENT '<-' Expr { Language.Ocaml.Abs.UpdateExpr $1 $3 }
  | FunExpr5 COLONEQUAL Expr { Language.Ocaml.Abs.AssignInfix $1 $2 $3 }
  | SimpleExpr17 '.' LabelLongident '<-' Expr { Language.Ocaml.Abs.QualifiedDot $1 $3 $5 }
  | SimpleExpr17 '.' '(' SeqExpr ')' '<-' Expr { Language.Ocaml.Abs.ArrayUpdateExpr $1 $4 $7 }
  | SimpleExpr17 '.' '[' SeqExpr ']' '<-' Expr { Language.Ocaml.Abs.StringUpdateExpr $1 $4 $7 }
  | SimpleExpr17 '.' '{' SeqExpr '}' '<-' Expr { Language.Ocaml.Abs.BigArrayUpdateExpr $1 $4 $7 }
  | SimpleExpr17 QualifiedDotop '(' ListExpr ')' '<-' Expr { Language.Ocaml.Abs.ParenDotopUpdateExpr $1 $2 $4 $7 }
  | SimpleExpr17 QualifiedDotop '[' ListExpr ']' '<-' Expr { Language.Ocaml.Abs.BracketDotopUpdateExpr $1 $2 $4 $7 }
  | SimpleExpr17 QualifiedDotop '{' ListExpr '}' '<-' Expr { Language.Ocaml.Abs.BraceDotopUpdateExpr $1 $2 $4 $7 }
  | FunExpr5 { $1 }

FunExpr3 :: { Language.Ocaml.Abs.FunExpr }
FunExpr3
  : 'if' Ext ListAttribute SeqExpr 'then' Expr 'else' Expr { Language.Ocaml.Abs.IfElse $2 $3 $4 $6 $8 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr { Language.Ocaml.Abs.If $2 $3 $4 $6 }
  | FunExpr4 { $1 }

FunExpr1 :: { Language.Ocaml.Abs.FunExpr }
FunExpr1
  : LetBindingsExt 'in' SeqExpr { Language.Ocaml.Abs.Let $1 $3 }
  | LETOP LetopBindings 'in' SeqExpr { Language.Ocaml.Abs.LetOpBinding $1 $2 $4 }
  | 'let' 'module' Ext ListAttribute ModuleName ModuleBindingBody 'in' SeqExpr { Language.Ocaml.Abs.LetModule $3 $4 $5 $6 $8 }
  | 'let' 'exception' Ext ListAttribute ConstrIdent GeneralizedConstructorArguments ListAttribute 'in' SeqExpr { Language.Ocaml.Abs.LetException $3 $4 $5 $6 $7 $9 }
  | 'let' 'open' OverrideFlag Ext ListAttribute ModuleExpr 'in' SeqExpr { Language.Ocaml.Abs.LetOpen $3 $4 $5 $6 $8 }
  | 'fun' Ext ListAttribute ListFunParam OptionalAtomicTypeAnnotation '->' FunBody { Language.Ocaml.Abs.Fun $2 $3 $4 $5 $7 }
  | 'match' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Match $2 $3 $4 $6 }
  | 'try' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Try $2 $3 $4 $6 }
  | 'while' Ext ListAttribute SeqExpr 'do' SeqExpr 'done' { Language.Ocaml.Abs.While $2 $3 $4 $6 }
  | 'for' Ext ListAttribute Pattern EQUAL SeqExpr DirectionFlag SeqExpr 'do' SeqExpr 'done' { Language.Ocaml.Abs.For $2 $3 $4 $5 $6 $7 $8 $10 }
  | FunExpr2 { $1 }

FunExpr2 :: { Language.Ocaml.Abs.FunExpr }
FunExpr2 : FunExpr3 { $1 }

Expr15 :: { Language.Ocaml.Abs.Expr }
Expr15
  : 'function' Ext ListAttribute ListMatchCase { Language.Ocaml.Abs.Function15 $2 $3 $4 }
  | LetBindingsExt 'in' SeqExpr { Language.Ocaml.Abs.Let15 $1 $3 }
  | LETOP LetopBindings 'in' SeqExpr { Language.Ocaml.Abs.LetOpBinding15 $1 $2 $4 }
  | 'let' 'module' Ext ListAttribute ModuleName ModuleBindingBody 'in' SeqExpr { Language.Ocaml.Abs.LetModule15 $3 $4 $5 $6 $8 }
  | 'let' 'exception' Ext ListAttribute ConstrIdent GeneralizedConstructorArguments ListAttribute 'in' SeqExpr { Language.Ocaml.Abs.LetException15 $3 $4 $5 $6 $7 $9 }
  | 'let' 'open' OverrideFlag Ext ListAttribute ModuleExpr 'in' SeqExpr { Language.Ocaml.Abs.LetOpen15 $3 $4 $5 $6 $8 }
  | 'fun' Ext ListAttribute ListFunParam OptionalAtomicTypeAnnotation '->' FunBody { Language.Ocaml.Abs.Fun15 $2 $3 $4 $5 $7 }
  | 'match' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Match15 $2 $3 $4 $6 }
  | 'try' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Try15 $2 $3 $4 $6 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr 'else' Expr { Language.Ocaml.Abs.IfElse15 $2 $3 $4 $6 $8 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr { Language.Ocaml.Abs.If15 $2 $3 $4 $6 }
  | FunExpr15 { Language.Ocaml.Abs.FunExpr15 $1 }

Expr13 :: { Language.Ocaml.Abs.Expr }
Expr13
  : 'function' Ext ListAttribute ListMatchCase { Language.Ocaml.Abs.Function13 $2 $3 $4 }
  | LetBindingsExt 'in' SeqExpr { Language.Ocaml.Abs.Let13 $1 $3 }
  | LETOP LetopBindings 'in' SeqExpr { Language.Ocaml.Abs.LetOpBinding13 $1 $2 $4 }
  | 'let' 'module' Ext ListAttribute ModuleName ModuleBindingBody 'in' SeqExpr { Language.Ocaml.Abs.LetModule13 $3 $4 $5 $6 $8 }
  | 'let' 'exception' Ext ListAttribute ConstrIdent GeneralizedConstructorArguments ListAttribute 'in' SeqExpr { Language.Ocaml.Abs.LetException13 $3 $4 $5 $6 $7 $9 }
  | 'let' 'open' OverrideFlag Ext ListAttribute ModuleExpr 'in' SeqExpr { Language.Ocaml.Abs.LetOpen13 $3 $4 $5 $6 $8 }
  | 'fun' Ext ListAttribute ListFunParam OptionalAtomicTypeAnnotation '->' FunBody { Language.Ocaml.Abs.Fun13 $2 $3 $4 $5 $7 }
  | 'match' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Match13 $2 $3 $4 $6 }
  | 'try' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Try13 $2 $3 $4 $6 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr 'else' Expr { Language.Ocaml.Abs.IfElse13 $2 $3 $4 $6 $8 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr { Language.Ocaml.Abs.If13 $2 $3 $4 $6 }
  | FunExpr13 { Language.Ocaml.Abs.FunExpr13 $1 }

Expr12 :: { Language.Ocaml.Abs.Expr }
Expr12
  : 'function' Ext ListAttribute ListMatchCase { Language.Ocaml.Abs.Function12 $2 $3 $4 }
  | LetBindingsExt 'in' SeqExpr { Language.Ocaml.Abs.Let12 $1 $3 }
  | LETOP LetopBindings 'in' SeqExpr { Language.Ocaml.Abs.LetOpBinding12 $1 $2 $4 }
  | 'let' 'module' Ext ListAttribute ModuleName ModuleBindingBody 'in' SeqExpr { Language.Ocaml.Abs.LetModule12 $3 $4 $5 $6 $8 }
  | 'let' 'exception' Ext ListAttribute ConstrIdent GeneralizedConstructorArguments ListAttribute 'in' SeqExpr { Language.Ocaml.Abs.LetException12 $3 $4 $5 $6 $7 $9 }
  | 'let' 'open' OverrideFlag Ext ListAttribute ModuleExpr 'in' SeqExpr { Language.Ocaml.Abs.LetOpen12 $3 $4 $5 $6 $8 }
  | 'fun' Ext ListAttribute ListFunParam OptionalAtomicTypeAnnotation '->' FunBody { Language.Ocaml.Abs.Fun12 $2 $3 $4 $5 $7 }
  | 'match' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Match12 $2 $3 $4 $6 }
  | 'try' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Try12 $2 $3 $4 $6 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr 'else' Expr { Language.Ocaml.Abs.IfElse12 $2 $3 $4 $6 $8 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr { Language.Ocaml.Abs.If12 $2 $3 $4 $6 }
  | FunExpr12 { Language.Ocaml.Abs.FunExpr12 $1 }

Expr11 :: { Language.Ocaml.Abs.Expr }
Expr11
  : 'function' Ext ListAttribute ListMatchCase { Language.Ocaml.Abs.Function11 $2 $3 $4 }
  | LetBindingsExt 'in' SeqExpr { Language.Ocaml.Abs.Let11 $1 $3 }
  | LETOP LetopBindings 'in' SeqExpr { Language.Ocaml.Abs.LetOpBinding11 $1 $2 $4 }
  | 'let' 'module' Ext ListAttribute ModuleName ModuleBindingBody 'in' SeqExpr { Language.Ocaml.Abs.LetModule11 $3 $4 $5 $6 $8 }
  | 'let' 'exception' Ext ListAttribute ConstrIdent GeneralizedConstructorArguments ListAttribute 'in' SeqExpr { Language.Ocaml.Abs.LetException11 $3 $4 $5 $6 $7 $9 }
  | 'let' 'open' OverrideFlag Ext ListAttribute ModuleExpr 'in' SeqExpr { Language.Ocaml.Abs.LetOpen11 $3 $4 $5 $6 $8 }
  | 'fun' Ext ListAttribute ListFunParam OptionalAtomicTypeAnnotation '->' FunBody { Language.Ocaml.Abs.Fun11 $2 $3 $4 $5 $7 }
  | 'match' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Match11 $2 $3 $4 $6 }
  | 'try' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Try11 $2 $3 $4 $6 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr 'else' Expr { Language.Ocaml.Abs.IfElse11 $2 $3 $4 $6 $8 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr { Language.Ocaml.Abs.If11 $2 $3 $4 $6 }
  | FunExpr11 { Language.Ocaml.Abs.FunExpr11 $1 }

Expr10 :: { Language.Ocaml.Abs.Expr }
Expr10
  : 'function' Ext ListAttribute ListMatchCase { Language.Ocaml.Abs.Function10 $2 $3 $4 }
  | LetBindingsExt 'in' SeqExpr { Language.Ocaml.Abs.Let10 $1 $3 }
  | LETOP LetopBindings 'in' SeqExpr { Language.Ocaml.Abs.LetOpBinding10 $1 $2 $4 }
  | 'let' 'module' Ext ListAttribute ModuleName ModuleBindingBody 'in' SeqExpr { Language.Ocaml.Abs.LetModule10 $3 $4 $5 $6 $8 }
  | 'let' 'exception' Ext ListAttribute ConstrIdent GeneralizedConstructorArguments ListAttribute 'in' SeqExpr { Language.Ocaml.Abs.LetException10 $3 $4 $5 $6 $7 $9 }
  | 'let' 'open' OverrideFlag Ext ListAttribute ModuleExpr 'in' SeqExpr { Language.Ocaml.Abs.LetOpen10 $3 $4 $5 $6 $8 }
  | 'fun' Ext ListAttribute ListFunParam OptionalAtomicTypeAnnotation '->' FunBody { Language.Ocaml.Abs.Fun10 $2 $3 $4 $5 $7 }
  | 'match' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Match10 $2 $3 $4 $6 }
  | 'try' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Try10 $2 $3 $4 $6 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr 'else' Expr { Language.Ocaml.Abs.IfElse10 $2 $3 $4 $6 $8 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr { Language.Ocaml.Abs.If10 $2 $3 $4 $6 }
  | FunExpr10 { Language.Ocaml.Abs.FunExpr10 $1 }

Expr9 :: { Language.Ocaml.Abs.Expr }
Expr9
  : 'function' Ext ListAttribute ListMatchCase { Language.Ocaml.Abs.Function9 $2 $3 $4 }
  | LetBindingsExt 'in' SeqExpr { Language.Ocaml.Abs.Let9 $1 $3 }
  | LETOP LetopBindings 'in' SeqExpr { Language.Ocaml.Abs.LetOpBinding9 $1 $2 $4 }
  | 'let' 'module' Ext ListAttribute ModuleName ModuleBindingBody 'in' SeqExpr { Language.Ocaml.Abs.LetModule9 $3 $4 $5 $6 $8 }
  | 'let' 'exception' Ext ListAttribute ConstrIdent GeneralizedConstructorArguments ListAttribute 'in' SeqExpr { Language.Ocaml.Abs.LetException9 $3 $4 $5 $6 $7 $9 }
  | 'let' 'open' OverrideFlag Ext ListAttribute ModuleExpr 'in' SeqExpr { Language.Ocaml.Abs.LetOpen9 $3 $4 $5 $6 $8 }
  | 'fun' Ext ListAttribute ListFunParam OptionalAtomicTypeAnnotation '->' FunBody { Language.Ocaml.Abs.Fun9 $2 $3 $4 $5 $7 }
  | 'match' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Match9 $2 $3 $4 $6 }
  | 'try' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Try9 $2 $3 $4 $6 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr 'else' Expr { Language.Ocaml.Abs.IfElse9 $2 $3 $4 $6 $8 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr { Language.Ocaml.Abs.If9 $2 $3 $4 $6 }
  | FunExpr9 { Language.Ocaml.Abs.FunExpr9 $1 }

Expr7 :: { Language.Ocaml.Abs.Expr }
Expr7
  : 'function' Ext ListAttribute ListMatchCase { Language.Ocaml.Abs.Function7 $2 $3 $4 }
  | LetBindingsExt 'in' SeqExpr { Language.Ocaml.Abs.Let7 $1 $3 }
  | LETOP LetopBindings 'in' SeqExpr { Language.Ocaml.Abs.LetOpBinding7 $1 $2 $4 }
  | 'let' 'module' Ext ListAttribute ModuleName ModuleBindingBody 'in' SeqExpr { Language.Ocaml.Abs.LetModule7 $3 $4 $5 $6 $8 }
  | 'let' 'exception' Ext ListAttribute ConstrIdent GeneralizedConstructorArguments ListAttribute 'in' SeqExpr { Language.Ocaml.Abs.LetException7 $3 $4 $5 $6 $7 $9 }
  | 'let' 'open' OverrideFlag Ext ListAttribute ModuleExpr 'in' SeqExpr { Language.Ocaml.Abs.LetOpen7 $3 $4 $5 $6 $8 }
  | 'fun' Ext ListAttribute ListFunParam OptionalAtomicTypeAnnotation '->' FunBody { Language.Ocaml.Abs.Fun7 $2 $3 $4 $5 $7 }
  | 'match' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Match7 $2 $3 $4 $6 }
  | 'try' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Try7 $2 $3 $4 $6 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr 'else' Expr { Language.Ocaml.Abs.IfElse7 $2 $3 $4 $6 $8 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr { Language.Ocaml.Abs.If7 $2 $3 $4 $6 }
  | FunExpr7 { Language.Ocaml.Abs.FunExpr7 $1 }

Expr6 :: { Language.Ocaml.Abs.Expr }
Expr6
  : 'function' Ext ListAttribute ListMatchCase { Language.Ocaml.Abs.Function6 $2 $3 $4 }
  | LetBindingsExt 'in' SeqExpr { Language.Ocaml.Abs.Let6 $1 $3 }
  | LETOP LetopBindings 'in' SeqExpr { Language.Ocaml.Abs.LetOpBinding6 $1 $2 $4 }
  | 'let' 'module' Ext ListAttribute ModuleName ModuleBindingBody 'in' SeqExpr { Language.Ocaml.Abs.LetModule6 $3 $4 $5 $6 $8 }
  | 'let' 'exception' Ext ListAttribute ConstrIdent GeneralizedConstructorArguments ListAttribute 'in' SeqExpr { Language.Ocaml.Abs.LetException6 $3 $4 $5 $6 $7 $9 }
  | 'let' 'open' OverrideFlag Ext ListAttribute ModuleExpr 'in' SeqExpr { Language.Ocaml.Abs.LetOpen6 $3 $4 $5 $6 $8 }
  | 'fun' Ext ListAttribute ListFunParam OptionalAtomicTypeAnnotation '->' FunBody { Language.Ocaml.Abs.Fun6 $2 $3 $4 $5 $7 }
  | 'match' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Match6 $2 $3 $4 $6 }
  | 'try' Ext ListAttribute SeqExpr 'with' ListMatchCase { Language.Ocaml.Abs.Try6 $2 $3 $4 $6 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr 'else' Expr { Language.Ocaml.Abs.IfElse6 $2 $3 $4 $6 $8 }
  | 'if' Ext ListAttribute SeqExpr 'then' Expr { Language.Ocaml.Abs.If6 $2 $3 $4 $6 }
  | FunExpr6 { Language.Ocaml.Abs.FunExpr6 $1 }

Expr :: { Language.Ocaml.Abs.Expr }
Expr
  : 'function' Ext ListAttribute ListMatchCase { Language.Ocaml.Abs.Function $2 $3 $4 }
  | FunExpr1 { Language.Ocaml.Abs.FunExpr1 $1 }

SimpleExpr19 :: { Language.Ocaml.Abs.SimpleExpr }
SimpleExpr19
  : '(' SeqExpr ')' { Language.Ocaml.Abs.SeqExpr $2 }
  | '(' SeqExpr TypeConstraint ')' { Language.Ocaml.Abs.SeqExprWithType $2 $3 }
  | ValLongident { Language.Ocaml.Abs.ValLongident $1 }
  | Constant { Language.Ocaml.Abs.Constant $1 }
  | ConstrLongident { Language.Ocaml.Abs.ConstrName $1 }
  | NameTag { Language.Ocaml.Abs.NameTagExpr $1 }
  | '[' ListExpr ']' { Language.Ocaml.Abs.ListExpr $2 }
  | '{' RecordExprContent '}' { Language.Ocaml.Abs.RecordExpr $2 }
  | '[|' '|]' { Language.Ocaml.Abs.EmptyArrayExpr }
  | '[|' ListExpr '|]' { Language.Ocaml.Abs.ArrayExpr $2 }
  | '{<' '>}' { Language.Ocaml.Abs.EmptyObjectExpr }
  | '{<' ListObjectExprField '>}' { Language.Ocaml.Abs.ObjectExpr $2 }
  | ModLongident '.' '(' ')' { Language.Ocaml.Abs.LocalOpenUnit $1 }
  | ModLongident '.' '(' SeqExpr ')' { Language.Ocaml.Abs.LocalOpenExpr $1 $4 }
  | ModLongident '.' '[' ']' { Language.Ocaml.Abs.LocalOpenEmptyListExpr $1 }
  | ModLongident '.' '[' ListExpr ']' { Language.Ocaml.Abs.LocalOpenListExpr $1 $4 }
  | ModLongident '.' '{' RecordExprContent '}' { Language.Ocaml.Abs.LocalOpenRecordExpr $1 $4 }
  | ModLongident '.' '[|' '|]' { Language.Ocaml.Abs.LocalOpenEmptyArrayExpr $1 }
  | ModLongident '.' '[|' ListExpr '|]' { Language.Ocaml.Abs.LocalOpenArrayExpr $1 $4 }
  | ModLongident '.' '{<' ListObjectExprField '>}' { Language.Ocaml.Abs.LocalOpenObjectExpr $1 $4 }
  | ModLongident '.' '(' 'module' Ext ListAttribute ModuleExpr ':' ModuleType ')' { Language.Ocaml.Abs.LocalOpenModule $1 $5 $6 $7 $9 }
  | 'begin' Ext ListAttribute SeqExpr 'end' { Language.Ocaml.Abs.BeginEnd $2 $3 $4 }
  | 'begin' Ext ListAttribute 'end' { Language.Ocaml.Abs.EmptyBeginEnd $2 $3 }
  | 'new' Ext ListAttribute ClassLongident { Language.Ocaml.Abs.New $2 $3 $4 }
  | '(' 'module' Ext ListAttribute ModuleExpr ')' { Language.Ocaml.Abs.Module $3 $4 $5 }
  | '(' 'module' Ext ListAttribute ModuleExpr ':' ModuleType ')' { Language.Ocaml.Abs.ModuleWithType $3 $4 $5 $7 }
  | 'object' Ext ListAttribute ClassSelfPattern ListClassField 'end' { Language.Ocaml.Abs.Object $2 $3 $4 $5 }
  | Extension { Language.Ocaml.Abs.Extension $1 }

SimpleExpr18 :: { Language.Ocaml.Abs.SimpleExpr }
SimpleExpr18
  : PREFIXOP SimpleExpr19 { Language.Ocaml.Abs.PrefixApp $1 $2 }
  | BANG SimpleExpr19 { Language.Ocaml.Abs.BangApp $1 $2 }
  | SimpleExpr19 Attribute { Language.Ocaml.Abs.ExprWithAttribute $1 $2 }
  | SimpleExpr19 { $1 }

SimpleExpr17 :: { Language.Ocaml.Abs.SimpleExpr }
SimpleExpr17
  : SimpleExpr17 '.' LabelLongident { Language.Ocaml.Abs.RecordAccessExpr $1 $3 }
  | SimpleExpr17 '.' '(' SeqExpr ')' { Language.Ocaml.Abs.ArrayAccessExpr $1 $4 }
  | SimpleExpr17 '.' '[' SeqExpr ']' { Language.Ocaml.Abs.StringAccessExpr $1 $4 }
  | SimpleExpr17 '.' '{' SeqExpr '}' { Language.Ocaml.Abs.BigArrayAccessExpr $1 $4 }
  | SimpleExpr17 QualifiedDotop '(' ListExpr ')' { Language.Ocaml.Abs.ParenDotopAccessExpr $1 $2 $4 }
  | SimpleExpr17 QualifiedDotop '[' ListExpr ']' { Language.Ocaml.Abs.BracketDotopAccessExpr $1 $2 $4 }
  | SimpleExpr17 QualifiedDotop '{' ListExpr '}' { Language.Ocaml.Abs.BraceDotopAccessExpr $1 $2 $4 }
  | SimpleExpr18 { $1 }

SimpleExpr16 :: { Language.Ocaml.Abs.SimpleExpr }
SimpleExpr16
  : SimpleExpr16 '#' LIDENT { Language.Ocaml.Abs.MethodInvocation $1 $3 }
  | SimpleExpr16 HASHOP SimpleExpr17 { Language.Ocaml.Abs.HashOp $1 $2 $3 }
  | SimpleExpr17 { $1 }

SimpleExpr :: { Language.Ocaml.Abs.SimpleExpr }
SimpleExpr : SimpleExpr16 { $1 }

ListLabeledSimpleExpr :: { [Language.Ocaml.Abs.LabeledSimpleExpr] }
ListLabeledSimpleExpr
  : LabeledSimpleExpr { (:[]) $1 }
  | LabeledSimpleExpr ListLabeledSimpleExpr { (:) $1 $2 }

LabeledSimpleExpr :: { Language.Ocaml.Abs.LabeledSimpleExpr }
LabeledSimpleExpr
  : SimpleExpr16 { Language.Ocaml.Abs.ExprWithoutLabel $1 }
  | LABEL SimpleExpr16 { Language.Ocaml.Abs.LabeledExpr $1 $2 }
  | '~' LIDENT { Language.Ocaml.Abs.LabeExpr $2 }
  | '~' '(' LIDENT TypeConstraint ')' { Language.Ocaml.Abs.LabelWithTypExpr $3 $4 }
  | '?' LIDENT { Language.Ocaml.Abs.OptLabelExpr $2 }
  | OPTLABEL SimpleExpr16 { Language.Ocaml.Abs.OptLabeledExpr $1 $2 }

LetBindingBodyNoPunning :: { Language.Ocaml.Abs.LetBindingBodyNoPunning }
LetBindingBodyNoPunning
  : ValIdent StrictBinding { Language.Ocaml.Abs.StrictBinding $1 $2 }
  | ValIdent TypeConstraint EQUAL SeqExpr { Language.Ocaml.Abs.BindingWithMonoType $1 $2 $3 $4 }
  | ValIdent ':' ListTypeVar '.' CoreType EQUAL SeqExpr { Language.Ocaml.Abs.BindingWithPolyType $1 $3 $5 $6 $7 }
  | ValIdent ':' 'type' ListLIDENT '.' CoreType EQUAL SeqExpr { Language.Ocaml.Abs.BindingWithLocallyAbstractType $1 $4 $6 $7 $8 }
  | PatternNoExn EQUAL SeqExpr { Language.Ocaml.Abs.PatternBinding $1 $2 $3 }
  | SimplePatternNotIdent ':' CoreType EQUAL SeqExpr { Language.Ocaml.Abs.PatternBindingWithType $1 $3 $4 $5 }

LetBindingBody :: { Language.Ocaml.Abs.LetBindingBody }
LetBindingBody
  : LetBindingBodyNoPunning { Language.Ocaml.Abs.LetBindingBodyNoPunning $1 }

LetBindingsNoExt :: { Language.Ocaml.Abs.LetBindingsNoExt }
LetBindingsNoExt
  : 'let' ListAttribute RecFlag LetBindingBody ListPostItemAttribute { Language.Ocaml.Abs.SingleLetBindingNoExt $2 $3 $4 $5 }
  | LetBindingsNoExt AndLetBinding { Language.Ocaml.Abs.MultipleLetBindingNoExt $1 $2 }

LetBindingsExt :: { Language.Ocaml.Abs.LetBindingsExt }
LetBindingsExt
  : 'let' Ext ListAttribute RecFlag LetBindingBody ListPostItemAttribute { Language.Ocaml.Abs.SingleLetBindingExt $2 $3 $4 $5 $6 }
  | LetBindingsExt AndLetBinding { Language.Ocaml.Abs.MultipleLetBindingExt $1 $2 }

AndLetBinding :: { Language.Ocaml.Abs.AndLetBinding }
AndLetBinding
  : 'and' ListAttribute LetBindingBody ListPostItemAttribute { Language.Ocaml.Abs.AndLetBinding $2 $3 $4 }

LetopBindingBody :: { Language.Ocaml.Abs.LetopBindingBody }
LetopBindingBody
  : ValIdent StrictBinding { Language.Ocaml.Abs.LetopStrictBinding $1 $2 }
  | ValIdent { Language.Ocaml.Abs.LetopValIdent $1 }
  | SimplePattern ':' CoreType EQUAL SeqExpr { Language.Ocaml.Abs.LetopPatternBindingWithType $1 $3 $4 $5 }
  | PatternNoExn EQUAL SeqExpr { Language.Ocaml.Abs.LetopPatternBinding $1 $2 $3 }

LetopBindings :: { Language.Ocaml.Abs.LetopBindings }
LetopBindings
  : LetopBindingBody { Language.Ocaml.Abs.BindingBody $1 }
  | LetopBindings ANDOP LetopBindingBody { Language.Ocaml.Abs.AndOpBinding $1 $2 $3 }

StrictBinding :: { Language.Ocaml.Abs.StrictBinding }
StrictBinding
  : EQUAL SeqExpr { Language.Ocaml.Abs.Binding $1 $2 }
  | ListFunParam OptionalTypeConstraint EQUAL FunBody { Language.Ocaml.Abs.FunParams $1 $2 $3 $4 }

FunBody :: { Language.Ocaml.Abs.FunBody }
FunBody
  : 'function' Ext ListAttribute ListMatchCase { Language.Ocaml.Abs.FunBodyFunction $2 $3 $4 }
  | FunExpr1 { Language.Ocaml.Abs.FunBodyFinalFunExpr $1 }
  | FunExpr1 ';' { Language.Ocaml.Abs.FunBodyFinalFunExprSemi $1 }
  | FunExpr1 ';' SeqExpr { Language.Ocaml.Abs.FunBodyMoreFunExprs $1 $3 }
  | FunExpr1 ';' PERCENT ListAttrId SeqExpr { Language.Ocaml.Abs.FunBodyMoreFunExprsAttr $1 $3 $4 $5 }

ListMatchCase :: { [Language.Ocaml.Abs.MatchCase] }
ListMatchCase
  : '|' ListMatchCase { $2 }
  | MatchCase { (:[]) $1 }
  | MatchCase '|' ListMatchCase { (:) $1 $3 }

MatchCase :: { Language.Ocaml.Abs.MatchCase }
MatchCase
  : Pattern '->' SeqExpr { Language.Ocaml.Abs.MatchCase $1 $3 }
  | Pattern 'when' SeqExpr '->' SeqExpr { Language.Ocaml.Abs.GuardedMatchCase $1 $3 $5 }
  | Pattern '->' '.' { Language.Ocaml.Abs.UnreachableMatchCase $1 }

FunParam :: { Language.Ocaml.Abs.FunParam }
FunParam
  : '(' 'type' ListLIDENT ')' { Language.Ocaml.Abs.LocallyAbstractTypeParam $3 }
  | LabeledSimplePattern { Language.Ocaml.Abs.Param $1 }

ListFunParam :: { [Language.Ocaml.Abs.FunParam] }
ListFunParam
  : FunParam { (:[]) $1 } | FunParam ListFunParam { (:) $1 $2 }

ExprComma :: { Language.Ocaml.Abs.ExprComma }
ExprComma : Expr { Language.Ocaml.Abs.ExprComma $1 }

ListExprComma :: { [Language.Ocaml.Abs.ExprComma] }
ListExprComma
  : ExprComma { (:[]) $1 }
  | ExprComma ',' ListExprComma { (:) $1 $3 }

RecordExprFields :: { Language.Ocaml.Abs.RecordExprFields }
RecordExprFields
  : RecordExprField { Language.Ocaml.Abs.FinalRecordExprField1 $1 }
  | RecordExprField ';' { Language.Ocaml.Abs.FinalRecordExprField2 $1 }
  | RecordExprField ';' RecordExprFields { Language.Ocaml.Abs.MoreRecordExprFields $1 $3 }

RecordExprContent :: { Language.Ocaml.Abs.RecordExprContent }
RecordExprContent
  : SimpleExpr 'with' RecordExprFields { Language.Ocaml.Abs.RecordExprContent1 $1 $3 }
  | RecordExprFields { Language.Ocaml.Abs.RecordExprContent2 $1 }

OptionalTypeConstraint :: { Language.Ocaml.Abs.OptionalTypeConstraint }
OptionalTypeConstraint
  : {- empty -} { Language.Ocaml.Abs.NoTypeConstraint }
  | TypeConstraint { Language.Ocaml.Abs.ATypeConstraint $1 }

RecordExprField :: { Language.Ocaml.Abs.RecordExprField }
RecordExprField
  : LabelLongident OptionalTypeConstraint OptionalAssignExpr { Language.Ocaml.Abs.RecordExprField $1 $2 $3 }

ListObjectExprField :: { [Language.Ocaml.Abs.ObjectExprField] }
ListObjectExprField
  : ObjectExprField { (:[]) $1 }
  | ObjectExprField ';' { (:[]) $1 }
  | ObjectExprField ';' ListObjectExprField { (:) $1 $3 }

OptionalAssignExpr :: { Language.Ocaml.Abs.OptionalAssignExpr }
OptionalAssignExpr
  : {- empty -} { Language.Ocaml.Abs.NoAssign }
  | EQUAL Expr { Language.Ocaml.Abs.AnAssign $1 $2 }

ObjectExprField :: { Language.Ocaml.Abs.ObjectExprField }
ObjectExprField
  : LIDENT OptionalAssignExpr { Language.Ocaml.Abs.ObjectExprField $1 $2 }

ListExpr :: { [Language.Ocaml.Abs.Expr] }
ListExpr
  : Expr { (:[]) $1 }
  | Expr ';' { (:[]) $1 }
  | Expr ';' ListExpr { (:) $1 $3 }

TypeConstraint :: { Language.Ocaml.Abs.TypeConstraint }
TypeConstraint
  : ':' CoreType { Language.Ocaml.Abs.TypeConstraint $2 }
  | ':' CoreType ':>' CoreType { Language.Ocaml.Abs.CoercionFromTo $2 $4 }
  | ':>' CoreType { Language.Ocaml.Abs.CoercionTo $2 }

Pattern :: { Language.Ocaml.Abs.Pattern }
Pattern
  : Pattern '::' Pattern { Language.Ocaml.Abs.ConsPattern $1 $3 }
  | Pattern Attribute { Language.Ocaml.Abs.PatternWithAttribute $1 $2 }
  | PatternGen { Language.Ocaml.Abs.PatternGen $1 }
  | Pattern 'as' ValIdent { Language.Ocaml.Abs.AsPattern $1 $3 }
  | PatternCommaListPattern { Language.Ocaml.Abs.TuplePattern $1 }
  | Pattern '|' Pattern { Language.Ocaml.Abs.OrPattern $1 $3 }
  | 'exception' Ext ListAttribute Pattern { Language.Ocaml.Abs.ExceptionPattern $2 $3 $4 }

PatternNoExn :: { Language.Ocaml.Abs.PatternNoExn }
PatternNoExn
  : PatternNoExn '::' Pattern { Language.Ocaml.Abs.ConsPatternNoExn $1 $3 }
  | PatternNoExn Attribute { Language.Ocaml.Abs.PatternWithAttributeNoExn $1 $2 }
  | PatternGen { Language.Ocaml.Abs.PatternGenNoExn $1 }
  | PatternNoExn 'as' ValIdent { Language.Ocaml.Abs.AsPatternNoExn $1 $3 }
  | PatternCommaListPatternNoExn { Language.Ocaml.Abs.TuplePatternNoExn $1 }
  | PatternNoExn '|' Pattern { Language.Ocaml.Abs.OrPatternNoExn $1 $3 }

ListLIDENT :: { [Language.Ocaml.Abs.LIDENT] }
ListLIDENT : LIDENT { (:[]) $1 } | LIDENT ListLIDENT { (:) $1 $2 }

PatternGen :: { Language.Ocaml.Abs.PatternGen }
PatternGen
  : SimplePattern { Language.Ocaml.Abs.SimplePatternGen $1 }
  | ConstrLongident Pattern { Language.Ocaml.Abs.ConstrPattern $1 $2 }
  | ConstrLongident '(' 'type' ListLIDENT ')' SimplePattern { Language.Ocaml.Abs.ConstrPatternWithLocallyAbstractType $1 $4 $6 }
  | NameTag Pattern { Language.Ocaml.Abs.TagPatternGen $1 $2 }
  | 'lazy' Ext ListAttribute SimplePattern { Language.Ocaml.Abs.LazyPattern $2 $3 $4 }

SimplePattern :: { Language.Ocaml.Abs.SimplePattern }
SimplePattern
  : ValIdent { Language.Ocaml.Abs.ValIdent $1 }
  | SimplePatternNotIdent { Language.Ocaml.Abs.SimplePatternNotIdent $1 }

SimplePatternNotIdent :: { Language.Ocaml.Abs.SimplePatternNotIdent }
SimplePatternNotIdent
  : '(' Pattern ')' { Language.Ocaml.Abs.Pattern $2 }
  | SimpleDelimitedPattern { Language.Ocaml.Abs.SimpleDelimitedPattern $1 }
  | '(' 'module' Ext ListAttribute ModuleName ')' { Language.Ocaml.Abs.ModulePattern $3 $4 $5 }
  | '(' 'module' Ext ListAttribute ModuleName ':' PackageType ')' { Language.Ocaml.Abs.ModulePatternWithType $3 $4 $5 $7 }
  | '_' { Language.Ocaml.Abs.UnderscorePattern }
  | SignedConstant { Language.Ocaml.Abs.ConstantPattern $1 }
  | SignedConstant '..' SignedConstant { Language.Ocaml.Abs.RangePattern $1 $3 }
  | ConstrLongident { Language.Ocaml.Abs.ConstrNamePattern $1 }
  | NameTag { Language.Ocaml.Abs.TagPattern $1 }
  | '#' TypeLongident { Language.Ocaml.Abs.TypeConstrPattern $2 }
  | ModLongident '.' SimpleDelimitedPattern { Language.Ocaml.Abs.DotPattern $1 $3 }
  | ModLongident '.' '[' ']' { Language.Ocaml.Abs.EmptyStringPattern $1 }
  | ModLongident '.' '(' ')' { Language.Ocaml.Abs.EmptyArrayPattern_ $1 }
  | ModLongident '.' '(' Pattern ')' { Language.Ocaml.Abs.ArrayPattern_ $1 $4 }
  | '(' Pattern ':' CoreType ')' { Language.Ocaml.Abs.PatternWithType $2 $4 }
  | Extension { Language.Ocaml.Abs.ExtensionPattern $1 }

SimpleDelimitedPattern :: { Language.Ocaml.Abs.SimpleDelimitedPattern }
SimpleDelimitedPattern
  : '{' RecordPatContent '}' { Language.Ocaml.Abs.RecordPattern $2 }
  | '[' ListPattern ']' { Language.Ocaml.Abs.ListPattern $2 }
  | '[|' ListPattern '|]' { Language.Ocaml.Abs.ArrayPattern $2 }
  | '[|' '|]' { Language.Ocaml.Abs.EmptyArrayPattern }

PatternCommaListPattern :: { Language.Ocaml.Abs.PatternCommaListPattern }
PatternCommaListPattern
  : PatternCommaListPattern ',' Pattern { Language.Ocaml.Abs.MorePattern $1 $3 }
  | Pattern ',' Pattern { Language.Ocaml.Abs.TwoPattern $1 $3 }

PatternCommaListPatternNoExn :: { Language.Ocaml.Abs.PatternCommaListPatternNoExn }
PatternCommaListPatternNoExn
  : PatternCommaListPatternNoExn ',' Pattern { Language.Ocaml.Abs.MorePatternNoExn $1 $3 }
  | PatternNoExn ',' Pattern { Language.Ocaml.Abs.TwoPatternNoExn $1 $3 }

ListPattern :: { [Language.Ocaml.Abs.Pattern] }
ListPattern
  : Pattern { (:[]) $1 }
  | Pattern ';' { (:[]) $1 }
  | Pattern ';' ListPattern { (:) $1 $3 }

OptionalSemi :: { Language.Ocaml.Abs.OptionalSemi }
OptionalSemi
  : {- empty -} { Language.Ocaml.Abs.NoSemi }
  | ';' { Language.Ocaml.Abs.ASemi }

RecordPatContent :: { Language.Ocaml.Abs.RecordPatContent }
RecordPatContent
  : RecordPatField OptionalSemi { Language.Ocaml.Abs.FinalRecordPattern $1 $2 }
  | RecordPatField ';' '_' OptionalSemi { Language.Ocaml.Abs.UnderscoreRecordPattern $1 $4 }
  | RecordPatField ';' RecordPatContent { Language.Ocaml.Abs.MoreRecordPatterns $1 $3 }

OptionalCoreType :: { Language.Ocaml.Abs.OptionalCoreType }
OptionalCoreType
  : {- empty -} { Language.Ocaml.Abs.NoCoreType }
  | ':' CoreType { Language.Ocaml.Abs.ACoreType $2 }

OptionalAssignPattern :: { Language.Ocaml.Abs.OptionalAssignPattern }
OptionalAssignPattern
  : {- empty -} { Language.Ocaml.Abs.NoAssignPattern }
  | EQUAL Pattern { Language.Ocaml.Abs.AnAssignPattern $1 $2 }

RecordPatField :: { Language.Ocaml.Abs.RecordPatField }
RecordPatField
  : LabelLongident OptionalCoreType OptionalAssignPattern { Language.Ocaml.Abs.RecordPatField $1 $2 $3 }

ValueDescription :: { Language.Ocaml.Abs.ValueDescription }
ValueDescription
  : 'val' Ext ListAttribute ValIdent ':' PolyType ListPostItemAttribute { Language.Ocaml.Abs.ValueDescription $2 $3 $4 $6 $7 }

ListSTRING :: { [Language.Ocaml.Abs.STRING] }
ListSTRING : STRING { (:[]) $1 } | STRING ListSTRING { (:) $1 $2 }

PrimitiveDeclaration :: { Language.Ocaml.Abs.PrimitiveDeclaration }
PrimitiveDeclaration
  : 'external' Ext ListAttribute ValIdent ':' PolyType EQUAL ListSTRING ListPostItemAttribute { Language.Ocaml.Abs.PrimitiveDeclaration $2 $3 $4 $6 $7 $8 $9 }

AndTypeDeclaration :: { Language.Ocaml.Abs.AndTypeDeclaration }
AndTypeDeclaration
  : 'and' ListAttribute TypeParameters LIDENT TypeKind ListConstraint ListPostItemAttribute { Language.Ocaml.Abs.AndTypeDeclaration $2 $3 $4 $5 $6 $7 }

ListAndTypeDeclaration :: { [Language.Ocaml.Abs.AndTypeDeclaration] }
ListAndTypeDeclaration
  : {- empty -} { [] }
  | AndTypeDeclaration ListAndTypeDeclaration { (:) $1 $2 }

TypeSubstDeclarations :: { Language.Ocaml.Abs.TypeSubstDeclarations }
TypeSubstDeclarations
  : TypeSubstDeclaration ListAndTypeSubstDeclaration { Language.Ocaml.Abs.TypeSubstDeclarations $1 $2 }

AndTypeSubstDeclaration :: { Language.Ocaml.Abs.AndTypeSubstDeclaration }
AndTypeSubstDeclaration
  : 'and' ListAttribute TypeParameters LIDENT TypeSubstKind ListConstraint ListPostItemAttribute { Language.Ocaml.Abs.AndTypeSubstDeclaration $2 $3 $4 $5 $6 $7 }

ListAndTypeSubstDeclaration :: { [Language.Ocaml.Abs.AndTypeSubstDeclaration] }
ListAndTypeSubstDeclaration
  : {- empty -} { [] }
  | AndTypeSubstDeclaration { (:[]) $1 }
  | AndTypeSubstDeclaration 'and' ListAndTypeSubstDeclaration { (:) $1 $3 }

TypeDeclaration :: { Language.Ocaml.Abs.TypeDeclaration }
TypeDeclaration
  : 'type' Ext ListAttribute 'nonrec' TypeParameters LIDENT TypeKind ListConstraint ListPostItemAttribute { Language.Ocaml.Abs.NonrecTypeDeclaration $2 $3 $5 $6 $7 $8 $9 }
  | 'type' Ext ListAttribute TypeParameters LIDENT TypeKind ListConstraint ListPostItemAttribute { Language.Ocaml.Abs.TypeDeclaration $2 $3 $4 $5 $6 $7 $8 }

TypeSubstDeclaration :: { Language.Ocaml.Abs.TypeSubstDeclaration }
TypeSubstDeclaration
  : 'type' Ext ListAttribute TypeParameters LIDENT TypeSubstKind ListConstraint ListPostItemAttribute { Language.Ocaml.Abs.TypeSubstDeclaration $2 $3 $4 $5 $6 $7 $8 }

Constraint :: { Language.Ocaml.Abs.Constraint }
Constraint
  : 'constraint' CoreType EQUAL CoreType { Language.Ocaml.Abs.Constraint $2 $3 $4 }

ListConstraint :: { [Language.Ocaml.Abs.Constraint] }
ListConstraint
  : {- empty -} { [] } | Constraint ListConstraint { (:) $1 $2 }

NonemptyTypeKind :: { Language.Ocaml.Abs.NonemptyTypeKind }
NonemptyTypeKind
  : CoreType { Language.Ocaml.Abs.AbstractType $1 }
  | ConstructorDeclarations { Language.Ocaml.Abs.VariantType $1 }
  | '..' { Language.Ocaml.Abs.OpenType }
  | '{' LabelDeclarations '}' { Language.Ocaml.Abs.RecordType $2 }
  | 'private' CoreType { Language.Ocaml.Abs.PrivateAbstractType $2 }
  | 'private' ConstructorDeclarations { Language.Ocaml.Abs.PrivateVariantType $2 }
  | 'private' '..' { Language.Ocaml.Abs.PrivateOpenType }
  | 'private' '{' LabelDeclarations '}' { Language.Ocaml.Abs.PrivateRecordType $3 }
  | CoreType EQUAL ConstructorDeclarations { Language.Ocaml.Abs.TypeSynonymVariantType $1 $2 $3 }
  | CoreType EQUAL 'private' ConstructorDeclarations { Language.Ocaml.Abs.TypeSynonymPrivateVariantType $1 $2 $4 }
  | CoreType EQUAL '..' { Language.Ocaml.Abs.TypeSynonymOpenType $1 $2 }
  | CoreType EQUAL 'private' '..' { Language.Ocaml.Abs.TypeSynonymPrivateOpenType $1 $2 }
  | CoreType EQUAL '{' LabelDeclarations '}' { Language.Ocaml.Abs.TypeSynonymRecordType $1 $2 $4 }
  | CoreType EQUAL 'private' '{' LabelDeclarations '}' { Language.Ocaml.Abs.TypeSynonymPrivateRecordType $1 $2 $5 }

TypeKind :: { Language.Ocaml.Abs.TypeKind }
TypeKind
  : {- empty -} { Language.Ocaml.Abs.NoTypeKind }
  | EQUAL NonemptyTypeKind { Language.Ocaml.Abs.TypeKind $1 $2 }

TypeSubstKind :: { Language.Ocaml.Abs.TypeSubstKind }
TypeSubstKind
  : COLONEQUAL NonemptyTypeKind { Language.Ocaml.Abs.TypeSubstKind $1 $2 }

TypeParameters :: { Language.Ocaml.Abs.TypeParameters }
TypeParameters
  : {- empty -} { Language.Ocaml.Abs.NoTypeParameters }
  | TypeParameter { Language.Ocaml.Abs.SingleTypeParameter $1 }
  | '(' ListTypeParameter ')' { Language.Ocaml.Abs.TypeParameters $2 }

ListTypeParameter :: { [Language.Ocaml.Abs.TypeParameter] }
ListTypeParameter
  : TypeParameter { (:[]) $1 }
  | TypeParameter ',' ListTypeParameter { (:) $1 $3 }

TypeParameter :: { Language.Ocaml.Abs.TypeParameter }
TypeParameter
  : TypeVariance TypeVariable { Language.Ocaml.Abs.TypeParameter $1 $2 }

TypeVariable :: { Language.Ocaml.Abs.TypeVariable }
TypeVariable
  : '\'' OCamlIdent { Language.Ocaml.Abs.TypeVariable $2 }
  | '_' { Language.Ocaml.Abs.Underscore }

TypeVariance :: { Language.Ocaml.Abs.TypeVariance }
TypeVariance
  : {- empty -} { Language.Ocaml.Abs.NoVarianceNoInjectivity }
  | PLUS { Language.Ocaml.Abs.CovariantNoInjectivity $1 }
  | MINUS { Language.Ocaml.Abs.ContravariantNoInjectivity $1 }
  | BANG { Language.Ocaml.Abs.NoVarianceInjective $1 }
  | '+!' { Language.Ocaml.Abs.CovariantInjective }
  | '!+' { Language.Ocaml.Abs.InjectiveCovariant }
  | '-!' { Language.Ocaml.Abs.ContravariantInjective }
  | '!-' { Language.Ocaml.Abs.InjectiveContravariant }
  | PLUSMINUSOP { Language.Ocaml.Abs.InfixOpVariance $1 }
  | PREFIXOP { Language.Ocaml.Abs.PrefixOpVariance $1 }

ListConstructorDeclaration :: { [Language.Ocaml.Abs.ConstructorDeclaration] }
ListConstructorDeclaration
  : ConstructorDeclaration { (:[]) $1 }
  | ConstructorDeclaration '|' ListConstructorDeclaration { (:) $1 $3 }

ConstructorDeclarations :: { Language.Ocaml.Abs.ConstructorDeclarations }
ConstructorDeclarations
  : '|' { Language.Ocaml.Abs.EmptyConstructorDeclarations }
  | '|' ListConstructorDeclaration { Language.Ocaml.Abs.BarConstructorDeclarations $2 }
  | ListConstructorDeclaration { Language.Ocaml.Abs.ConstructorDeclarations $1 }

ConstructorDeclaration :: { Language.Ocaml.Abs.ConstructorDeclaration }
ConstructorDeclaration
  : ConstrIdent GeneralizedConstructorArguments ListAttribute { Language.Ocaml.Abs.ConstructorDeclaration $1 $2 $3 }

StrExceptionDeclaration :: { Language.Ocaml.Abs.StrExceptionDeclaration }
StrExceptionDeclaration
  : SigExceptionDeclaration { Language.Ocaml.Abs.SigStrExceptionDeclaration $1 }
  | 'exception' Ext ListAttribute ConstrIdent EQUAL ConstrLongident ListAttribute ListPostItemAttribute { Language.Ocaml.Abs.Exception $2 $3 $4 $5 $6 $7 $8 }

SigExceptionDeclaration :: { Language.Ocaml.Abs.SigExceptionDeclaration }
SigExceptionDeclaration
  : 'exception' Ext ListAttribute ConstrIdent GeneralizedConstructorArguments ListAttribute ListPostItemAttribute { Language.Ocaml.Abs.SigExceptionDeclaration $2 $3 $4 $5 $6 $7 }

GeneralizedConstructorArguments :: { Language.Ocaml.Abs.GeneralizedConstructorArguments }
GeneralizedConstructorArguments
  : {- empty -} { Language.Ocaml.Abs.NoGeneralizedConstructorArguments }
  | 'of' ConstructorArguments { Language.Ocaml.Abs.GeneralizedConstructorArguments1 $2 }
  | ':' ConstructorArguments '->' AtomicType { Language.Ocaml.Abs.GeneralizedConstructorArguments2 $2 $4 }
  | ':' ListTypeVar '.' ConstructorArguments '->' AtomicType { Language.Ocaml.Abs.GeneralizedConstructorArguments3 $2 $4 $6 }
  | ':' AtomicType { Language.Ocaml.Abs.GeneralizedConstructorArguments4 $2 }
  | ':' ListTypeVar '.' AtomicType { Language.Ocaml.Abs.GeneralizedConstructorArguments5 $2 $4 }

ConstructorArguments :: { Language.Ocaml.Abs.ConstructorArguments }
ConstructorArguments
  : TupleType { Language.Ocaml.Abs.Arg1 $1 }
  | '{' LabelDeclarations '}' { Language.Ocaml.Abs.Arg2 $2 }

LabelDeclarations :: { Language.Ocaml.Abs.LabelDeclarations }
LabelDeclarations
  : LabelDeclaration { Language.Ocaml.Abs.FinalLabelDeclaration $1 }
  | LabelDeclarationSemi { Language.Ocaml.Abs.FinalLabelDeclarationSemi $1 }
  | LabelDeclarationSemi LabelDeclarations { Language.Ocaml.Abs.MoreLabelDeclarations $1 $2 }

LabelDeclaration :: { Language.Ocaml.Abs.LabelDeclaration }
LabelDeclaration
  : MutableFlag LIDENT ':' AliasType ListAttribute { Language.Ocaml.Abs.LabelDeclarationMonoType $1 $2 $4 $5 }
  | MutableFlag LIDENT ':' ListTypeVar '.' AliasType ListAttribute { Language.Ocaml.Abs.LabelDeclarationPolyType $1 $2 $4 $6 $7 }

LabelDeclarationSemi :: { Language.Ocaml.Abs.LabelDeclarationSemi }
LabelDeclarationSemi
  : MutableFlag LIDENT ':' AliasType ListAttribute ';' ListAttribute { Language.Ocaml.Abs.LabelDeclarationSemiMonoType $1 $2 $4 $5 $7 }
  | MutableFlag LIDENT ':' ListTypeVar '.' AliasType ListAttribute ';' ListAttribute { Language.Ocaml.Abs.LabelDeclarationSemiPolyType $1 $2 $4 $6 $7 $9 }

BarLlistExtensionConstructor :: { Language.Ocaml.Abs.BarLlistExtensionConstructor }
BarLlistExtensionConstructor
  : '|' { Language.Ocaml.Abs.NoExtensionConstructors }
  | '|' ListExtensionConstructor { Language.Ocaml.Abs.BarExtensionConstructors $2 }
  | ListExtensionConstructor { Language.Ocaml.Abs.ExtensionConstructors $1 }

ListExtensionConstructor :: { [Language.Ocaml.Abs.ExtensionConstructor] }
ListExtensionConstructor
  : {- empty -} { [] }
  | ExtensionConstructor { (:[]) $1 }
  | ExtensionConstructor '|' ListExtensionConstructor { (:) $1 $3 }

BarLlistExtensionConstructorDeclaration :: { Language.Ocaml.Abs.BarLlistExtensionConstructorDeclaration }
BarLlistExtensionConstructorDeclaration
  : '|' { Language.Ocaml.Abs.NoConstructor }
  | '|' ListExtensionConstructorDeclaration { Language.Ocaml.Abs.Constructor $2 }
  | ListExtensionConstructorDeclaration { Language.Ocaml.Abs.Constructor $1 }

ListExtensionConstructorDeclaration :: { [Language.Ocaml.Abs.ExtensionConstructorDeclaration] }
ListExtensionConstructorDeclaration
  : {- empty -} { [] }
  | ExtensionConstructorDeclaration { (:[]) $1 }
  | ExtensionConstructorDeclaration '|' ListExtensionConstructorDeclaration { (:) $1 $3 }

ExtensionConstructor :: { Language.Ocaml.Abs.ExtensionConstructor }
ExtensionConstructor
  : ExtensionConstructorDeclaration { Language.Ocaml.Abs.Declaration $1 }
  | ExtensionConstructorRebind { Language.Ocaml.Abs.Rebind $1 }

ExtensionConstructorDeclaration :: { Language.Ocaml.Abs.ExtensionConstructorDeclaration }
ExtensionConstructorDeclaration
  : ConstrIdent GeneralizedConstructorArguments ListAttribute { Language.Ocaml.Abs.ExtensionConstructorDeclaration $1 $2 $3 }

ExtensionConstructorRebind :: { Language.Ocaml.Abs.ExtensionConstructorRebind }
ExtensionConstructorRebind
  : ConstrIdent EQUAL ConstrLongident ListAttribute { Language.Ocaml.Abs.ExtensionConstructorRebind $1 $2 $3 $4 }

WithConstraint :: { Language.Ocaml.Abs.WithConstraint }
WithConstraint
  : 'type' TypeParameters LabelLongident WithTypeBinder AliasType ListConstraint { Language.Ocaml.Abs.WithConstraint1 $2 $3 $4 $5 $6 }
  | 'type' TypeParameters LabelLongident COLONEQUAL AliasType { Language.Ocaml.Abs.WithConstraint2 $2 $3 $4 $5 }
  | 'module' ModLongident EQUAL ModExtLongident { Language.Ocaml.Abs.WithConstraint3 $2 $3 $4 }
  | 'module' ModLongident COLONEQUAL ModExtLongident { Language.Ocaml.Abs.WithConstraint4 $2 $3 $4 }
  | 'module' 'type' MtyLongident EQUAL ModuleType { Language.Ocaml.Abs.WithConstraint5 $3 $4 $5 }
  | 'module' 'type' MtyLongident COLONEQUAL ModuleType { Language.Ocaml.Abs.WithConstraint6 $3 $4 $5 }

WithTypeBinder :: { Language.Ocaml.Abs.WithTypeBinder }
WithTypeBinder
  : EQUAL { Language.Ocaml.Abs.WithTypeBinderEqual $1 }
  | EQUAL 'private' { Language.Ocaml.Abs.WithTypeBinderEqualPrivate $1 }

TypeVar :: { Language.Ocaml.Abs.TypeVar }
TypeVar : '\'' OCamlIdent { Language.Ocaml.Abs.TypeVarIdent $2 }

ListTypeVar :: { [Language.Ocaml.Abs.TypeVar] }
ListTypeVar
  : TypeVar { (:[]) $1 } | TypeVar ListTypeVar { (:) $1 $2 }

PolyType :: { Language.Ocaml.Abs.PolyType }
PolyType
  : CoreType { Language.Ocaml.Abs.MonoCoreType $1 }
  | ListTypeVar '.' CoreType { Language.Ocaml.Abs.PolyCoreType $1 $3 }

CoreType :: { Language.Ocaml.Abs.CoreType }
CoreType
  : AliasType { Language.Ocaml.Abs.CoreTypeWithoutAttribute $1 }
  | CoreType Attribute { Language.Ocaml.Abs.CoreTypeWithAttribute $1 $2 }

ListCoreType :: { [Language.Ocaml.Abs.CoreType] }
ListCoreType
  : CoreType { (:[]) $1 } | CoreType ',' ListCoreType { (:) $1 $3 }

AliasType :: { Language.Ocaml.Abs.AliasType }
AliasType
  : FunctionType { Language.Ocaml.Abs.FunctionType $1 }
  | AliasType 'as' TypeVar { Language.Ocaml.Abs.AliasType $1 $3 }

FunctionType :: { Language.Ocaml.Abs.FunctionType }
FunctionType
  : TupleType { Language.Ocaml.Abs.TupleType $1 }
  | OptLabel TupleType '->' FunctionType { Language.Ocaml.Abs.ArgTypeWithOptLabel $1 $2 $4 }
  | LIDENT ':' TupleType '->' FunctionType { Language.Ocaml.Abs.ArgTypeWithLabel $1 $3 $5 }
  | TupleType '->' FunctionType { Language.Ocaml.Abs.ArgTypeWithoutLabel $1 $3 }

TupleType :: { Language.Ocaml.Abs.TupleType }
TupleType
  : AtomicType { Language.Ocaml.Abs.AtomicType $1 }
  | AtomicType STAR TupleType { Language.Ocaml.Abs.AtomicTypes $1 $2 $3 }

OptionalBar :: { Language.Ocaml.Abs.OptionalBar }
OptionalBar
  : {- empty -} { Language.Ocaml.Abs.NoBar }
  | '|' { Language.Ocaml.Abs.ABar }

DelimitedTypeSupportingLocalOpen :: { Language.Ocaml.Abs.DelimitedTypeSupportingLocalOpen }
DelimitedTypeSupportingLocalOpen
  : '(' CoreType ')' { Language.Ocaml.Abs.LocalOpen1 $2 }
  | '(' 'module' Ext ListAttribute PackageType ')' { Language.Ocaml.Abs.LocalOpen2 $3 $4 $5 }
  | '[' TagField ']' { Language.Ocaml.Abs.LocalOpen3 $2 }
  | '[' '|' ListRowField ']' { Language.Ocaml.Abs.LocalOpen4 $3 }
  | '[' RowField '|' ListRowField ']' { Language.Ocaml.Abs.LocalOpen5 $2 $4 }
  | '[>' OptionalBar ListRowField ']' { Language.Ocaml.Abs.LocalOpen6 $2 $3 }
  | '[>' ']' { Language.Ocaml.Abs.LocalOpen7 }
  | '[<' OptionalBar ListRowField ']' { Language.Ocaml.Abs.LocalOpen8 $2 $3 }
  | '[<' OptionalBar ListRowField GREATER ListNameTag ']' { Language.Ocaml.Abs.LocalOpen9 $2 $3 $4 $5 }

ObjectType :: { Language.Ocaml.Abs.ObjectType }
ObjectType
  : LESS MethList GREATER { Language.Ocaml.Abs.MethList $1 $2 $3 }
  | LESS GREATER { Language.Ocaml.Abs.Empty $1 $2 }

DelimitedType :: { Language.Ocaml.Abs.DelimitedType }
DelimitedType
  : ObjectType { Language.Ocaml.Abs.ObjectType $1 }
  | Extension { Language.Ocaml.Abs.DelimitedTypeExtension $1 }
  | DelimitedTypeSupportingLocalOpen { Language.Ocaml.Abs.DelimitedTypeSupportingLocalOpen $1 }

AtomicType :: { Language.Ocaml.Abs.AtomicType }
AtomicType
  : DelimitedType { Language.Ocaml.Abs.DelimitedType $1 }
  | TypeLongident { Language.Ocaml.Abs.TypeConstr $1 }
  | AtomicType TypeLongident { Language.Ocaml.Abs.SimpleTypeApp $1 $2 }
  | '(' CoreType ',' ListCoreType ')' TypeLongident { Language.Ocaml.Abs.ComplexTypeApp $2 $4 $6 }
  | '#' CltyLongident { Language.Ocaml.Abs.ClassTypeConstr $2 }
  | AtomicType '#' CltyLongident { Language.Ocaml.Abs.SimpleSubTypeApp $1 $3 }
  | '(' CoreType ',' ListCoreType ')' '#' CltyLongident { Language.Ocaml.Abs.ComplexSubTypeApp $2 $4 $7 }
  | ModExtLongident '.' DelimitedTypeSupportingLocalOpen { Language.Ocaml.Abs.QualifiedDelimitedType $1 $3 }
  | '\'' OCamlIdent { Language.Ocaml.Abs.TypeVar $2 }
  | '_' { Language.Ocaml.Abs.UnderscoreType }

PackageType :: { Language.Ocaml.Abs.PackageType }
PackageType : ModuleType { Language.Ocaml.Abs.PackageType $1 }

ListRowField :: { [Language.Ocaml.Abs.RowField] }
ListRowField
  : RowField { (:[]) $1 } | RowField '|' ListRowField { (:) $1 $3 }

RowField :: { Language.Ocaml.Abs.RowField }
RowField
  : TagField { Language.Ocaml.Abs.TagField $1 }
  | CoreType { Language.Ocaml.Abs.CoreType $1 }

TagField :: { Language.Ocaml.Abs.TagField }
TagField
  : NameTag 'of' OptAmpersand AmperTypeList ListAttribute { Language.Ocaml.Abs.Of $1 $3 $4 $5 }
  | NameTag ListAttribute { Language.Ocaml.Abs.Tag $1 $2 }

OptAmpersand :: { Language.Ocaml.Abs.OptAmpersand }
OptAmpersand
  : AMPERSAND { Language.Ocaml.Abs.Ampersand $1 }
  | {- empty -} { Language.Ocaml.Abs.NoAmpersand }

AmperTypeList :: { Language.Ocaml.Abs.AmperTypeList }
AmperTypeList
  : AliasType { Language.Ocaml.Abs.AmperTypeListNil $1 }
  | AliasType AMPERSAND AmperTypeList { Language.Ocaml.Abs.AmperTypeListCons $1 $2 $3 }

ListNameTag :: { [Language.Ocaml.Abs.NameTag] }
ListNameTag
  : NameTag { (:[]) $1 } | NameTag ListNameTag { (:) $1 $2 }

MethList :: { Language.Ocaml.Abs.MethList }
MethList
  : LIDENT ':' AliasType ListAttribute ';' ListAttribute MethList { Language.Ocaml.Abs.FieldSemiMethListMonoType $1 $3 $4 $6 $7 }
  | LIDENT ':' ListTypeVar '.' AliasType ListAttribute ';' ListAttribute MethList { Language.Ocaml.Abs.FieldSemiMethListPolyType $1 $3 $5 $6 $8 $9 }
  | AtomicType ';' MethList { Language.Ocaml.Abs.InheritSemiMethList $1 $3 }
  | LIDENT ':' AliasType ListAttribute ';' { Language.Ocaml.Abs.FieldSemiMonoType $1 $3 $4 }
  | LIDENT ':' ListTypeVar '.' AliasType ListAttribute ';' { Language.Ocaml.Abs.FieldSemiPolyType $1 $3 $5 $6 }
  | AtomicType ';' { Language.Ocaml.Abs.InheritSemi $1 }
  | LIDENT ':' AliasType ListAttribute { Language.Ocaml.Abs.FieldMonoType $1 $3 $4 }
  | LIDENT ':' ListTypeVar '.' AliasType ListAttribute { Language.Ocaml.Abs.FieldPolyType $1 $3 $5 $6 }
  | AtomicType { Language.Ocaml.Abs.Inherit $1 }
  | '..' { Language.Ocaml.Abs.DotDot }

Constant :: { Language.Ocaml.Abs.Constant }
Constant
  : INT { Language.Ocaml.Abs.Int $1 }
  | CHAR { Language.Ocaml.Abs.Char $1 }
  | STRING { Language.Ocaml.Abs.String $1 }
  | FLOAT { Language.Ocaml.Abs.Float $1 }

SignedConstant :: { Language.Ocaml.Abs.SignedConstant }
SignedConstant
  : Constant { Language.Ocaml.Abs.UnsignedConstant $1 }
  | MINUS INT { Language.Ocaml.Abs.NegInt $1 $2 }
  | MINUS FLOAT { Language.Ocaml.Abs.NegFloat $1 $2 }
  | PLUS INT { Language.Ocaml.Abs.PosInt $1 $2 }
  | PLUS FLOAT { Language.Ocaml.Abs.PosFloat $1 $2 }

OCamlIdent :: { Language.Ocaml.Abs.OCamlIdent }
OCamlIdent
  : UIDENT { Language.Ocaml.Abs.Uppercase $1 }
  | LIDENT { Language.Ocaml.Abs.Lowercase $1 }

ValExtraIdent :: { Language.Ocaml.Abs.ValExtraIdent }
ValExtraIdent : '(' Operator ')' { Language.Ocaml.Abs.Operator $2 }

ValIdent :: { Language.Ocaml.Abs.ValIdent }
ValIdent
  : LIDENT { Language.Ocaml.Abs.LowercaseValIdent $1 }
  | ValExtraIdent { Language.Ocaml.Abs.ValExtraIdent $1 }

Operator :: { Language.Ocaml.Abs.Operator }
Operator
  : PREFIXOP { Language.Ocaml.Abs.PrefixOp $1 }
  | LETOP { Language.Ocaml.Abs.LetOp $1 }
  | ANDOP { Language.Ocaml.Abs.AndOp $1 }
  | DOTOP '(' IndexMod ')' { Language.Ocaml.Abs.ParenAccessDotop $1 $3 }
  | DOTOP '(' IndexMod ')' '<-' { Language.Ocaml.Abs.ParenUpdateDotop $1 $3 }
  | DOTOP '[' IndexMod ']' { Language.Ocaml.Abs.BraceAccessDotop $1 $3 }
  | DOTOP '[' IndexMod ']' '<-' { Language.Ocaml.Abs.BraceUpdateDotop $1 $3 }
  | DOTOP '{' IndexMod '}' { Language.Ocaml.Abs.BraceAccessDotop $1 $3 }
  | DOTOP '{' IndexMod '}' '<-' { Language.Ocaml.Abs.BraceUpdateDotop $1 $3 }
  | HASHOP { Language.Ocaml.Abs.HashSymbolOp $1 }
  | BANG { Language.Ocaml.Abs.BangOp $1 }
  | RELOP { Language.Ocaml.Abs.RelOp $1 }
  | CONCATOP { Language.Ocaml.Abs.ConcatOp $1 }
  | PLUSMINUSOP { Language.Ocaml.Abs.PlusMinusOp $1 }
  | MULTDIVOP { Language.Ocaml.Abs.MultDivOp $1 }
  | POWOP { Language.Ocaml.Abs.PowOp $1 }
  | PLUS { Language.Ocaml.Abs.PlusOp $1 }
  | PLUSDOT { Language.Ocaml.Abs.PlusDotOp $1 }
  | PLUSEQ { Language.Ocaml.Abs.PlusEqOp $1 }
  | MINUS { Language.Ocaml.Abs.MinusOp $1 }
  | MINUSDOT { Language.Ocaml.Abs.MinusDotOp $1 }
  | STAR { Language.Ocaml.Abs.StarOp $1 }
  | PERCENT { Language.Ocaml.Abs.PercentOp $1 }
  | EQUAL { Language.Ocaml.Abs.EqualOp $1 }
  | BANGEQUAL { Language.Ocaml.Abs.NotEqualOp $1 }
  | LESS { Language.Ocaml.Abs.LessOp $1 }
  | GREATER { Language.Ocaml.Abs.GreaterOp $1 }
  | OR { Language.Ocaml.Abs.OrOp $1 }
  | BARBAR { Language.Ocaml.Abs.BarBarOp $1 }
  | AMPERSAND { Language.Ocaml.Abs.AmpersandOp $1 }
  | AMPERAMPER { Language.Ocaml.Abs.AmperAmperOp $1 }
  | COLONEQUAL { Language.Ocaml.Abs.ColonEqualOp $1 }

IndexMod :: { Language.Ocaml.Abs.IndexMod }
IndexMod
  : {- empty -} { Language.Ocaml.Abs.NoIndexMod }
  | ';' '..' { Language.Ocaml.Abs.SemiDotDot }

ConstrExtraNonprefixIdent :: { Language.Ocaml.Abs.ConstrExtraNonprefixIdent }
ConstrExtraNonprefixIdent
  : '[' ']' { Language.Ocaml.Abs.EmptyListConstr }
  | '(' ')' { Language.Ocaml.Abs.UnitConstr }
  | 'false' { Language.Ocaml.Abs.FalseConstr }
  | 'true' { Language.Ocaml.Abs.TrueConstr }

ConstrIdent :: { Language.Ocaml.Abs.ConstrIdent }
ConstrIdent
  : UIDENT { Language.Ocaml.Abs.ConstrIdent $1 }
  | '(' '::' ')' { Language.Ocaml.Abs.ListConstr }
  | ConstrExtraNonprefixIdent { Language.Ocaml.Abs.PrimitiveConstr $1 }

ConstrLongident :: { Language.Ocaml.Abs.ConstrLongident }
ConstrLongident
  : ModLongident { Language.Ocaml.Abs.QualifiedConstrIdent $1 }
  | ModLongident '.' '(' '::' ')' { Language.Ocaml.Abs.QualifiedListConstr $1 }
  | '(' '::' ')' { Language.Ocaml.Abs.UnqualifiedListConstr }
  | ConstrExtraNonprefixIdent { Language.Ocaml.Abs.UnqualifiedPrimitiveConstr $1 }

ValLongident :: { Language.Ocaml.Abs.ValLongident }
ValLongident
  : ValIdent { Language.Ocaml.Abs.UnqualifiedValLongIdent $1 }
  | ModLongident '.' ValIdent { Language.Ocaml.Abs.QualifiedValIdent $1 $3 }

LabelLongident :: { Language.Ocaml.Abs.LabelLongident }
LabelLongident
  : LIDENT { Language.Ocaml.Abs.LabelLongident $1 }
  | ModLongident '.' LIDENT { Language.Ocaml.Abs.QualifiedLabelLongident $1 $3 }

TypeLongident :: { Language.Ocaml.Abs.TypeLongident }
TypeLongident
  : LIDENT { Language.Ocaml.Abs.TypeLongident $1 }
  | ModExtLongident '.' LIDENT { Language.Ocaml.Abs.QualifiedTypelLongident $1 $3 }

ModLongident :: { Language.Ocaml.Abs.ModLongident }
ModLongident
  : UIDENT { Language.Ocaml.Abs.ModLongident $1 }
  | ModLongident '.' UIDENT { Language.Ocaml.Abs.QualifiedModLongident $1 $3 }

ModExtLongident :: { Language.Ocaml.Abs.ModExtLongident }
ModExtLongident
  : UIDENT { Language.Ocaml.Abs.ModExtLongident $1 }
  | ModExtLongident '.' UIDENT { Language.Ocaml.Abs.QualifiedModExtLongident $1 $3 }
  | ModExtLongident '(' ModExtLongident ')' { Language.Ocaml.Abs.ParenModExtLongident $1 $3 }

MtyLongident :: { Language.Ocaml.Abs.MtyLongident }
MtyLongident
  : OCamlIdent { Language.Ocaml.Abs.MtyLongident $1 }
  | ModExtLongident '.' OCamlIdent { Language.Ocaml.Abs.QualifiedMtyLongident $1 $3 }

CltyLongident :: { Language.Ocaml.Abs.CltyLongident }
CltyLongident
  : LIDENT { Language.Ocaml.Abs.CltyLongident $1 }
  | ModExtLongident '.' LIDENT { Language.Ocaml.Abs.QualifiedCltyLongident $1 $3 }

ClassLongident :: { Language.Ocaml.Abs.ClassLongident }
ClassLongident
  : LIDENT { Language.Ocaml.Abs.ClassLongident $1 }
  | ModLongident '.' LIDENT { Language.Ocaml.Abs.QualifiedClassLongident $1 $3 }

OptionalToplevelDirectiveArgument :: { Language.Ocaml.Abs.OptionalToplevelDirectiveArgument }
OptionalToplevelDirectiveArgument
  : {- empty -} { Language.Ocaml.Abs.NoToplevelDirectiveArgument }
  | ToplevelDirectiveArgument { Language.Ocaml.Abs.AToplevelDirectiveArgument $1 }

ToplevelDirective :: { Language.Ocaml.Abs.ToplevelDirective }
ToplevelDirective
  : '#' OCamlIdent ToplevelDirectiveArgument { Language.Ocaml.Abs.ToplevelDirectiveApp $2 $3 }

ToplevelDirectiveArgument :: { Language.Ocaml.Abs.ToplevelDirectiveArgument }
ToplevelDirectiveArgument
  : STRING { Language.Ocaml.Abs.ToplevelString $1 }
  | INT { Language.Ocaml.Abs.ToplevelInt $1 }
  | ValLongident { Language.Ocaml.Abs.ValueIdent $1 }
  | ModLongident { Language.Ocaml.Abs.ToplevelModuleIdent $1 }
  | 'false' { Language.Ocaml.Abs.ToplevelFalse }
  | 'true' { Language.Ocaml.Abs.ToplevelTrue }

NameTag :: { Language.Ocaml.Abs.NameTag }
NameTag : '`' OCamlIdent { Language.Ocaml.Abs.NameTag $2 }

RecFlag :: { Language.Ocaml.Abs.RecFlag }
RecFlag
  : {- empty -} { Language.Ocaml.Abs.Nonrecursive }
  | 'rec' { Language.Ocaml.Abs.Recursive }

DirectionFlag :: { Language.Ocaml.Abs.DirectionFlag }
DirectionFlag
  : 'to' { Language.Ocaml.Abs.UpTo }
  | 'downto' { Language.Ocaml.Abs.DownTo }

PrivateFlag :: { Language.Ocaml.Abs.PrivateFlag }
PrivateFlag
  : {- empty -} { Language.Ocaml.Abs.Public }
  | 'private' { Language.Ocaml.Abs.Private }

MutableFlag :: { Language.Ocaml.Abs.MutableFlag }
MutableFlag
  : {- empty -} { Language.Ocaml.Abs.Immutable }
  | 'mutable' { Language.Ocaml.Abs.Mutable }

VirtualFlag :: { Language.Ocaml.Abs.VirtualFlag }
VirtualFlag
  : {- empty -} { Language.Ocaml.Abs.Concrete }
  | 'virtual' { Language.Ocaml.Abs.Virtual }

MutableVirtualFlags :: { Language.Ocaml.Abs.MutableVirtualFlags }
MutableVirtualFlags
  : {- empty -} { Language.Ocaml.Abs.ImmutableContrete }
  | 'mutable' { Language.Ocaml.Abs.MutableConcrete }
  | 'virtual' { Language.Ocaml.Abs.ImmutableVirtual }
  | 'mutable' 'virtual' { Language.Ocaml.Abs.MutableVirtual }
  | 'virtual' 'mutable' { Language.Ocaml.Abs.VirtualMutable }

PrivateVirtualFlags :: { Language.Ocaml.Abs.PrivateVirtualFlags }
PrivateVirtualFlags
  : {- empty -} { Language.Ocaml.Abs.PublicConcrete }
  | 'private' { Language.Ocaml.Abs.PrivateConcrete }
  | 'virtual' { Language.Ocaml.Abs.PublicVirtual }
  | 'private' 'virtual' { Language.Ocaml.Abs.PrivateVirtual }
  | 'virtual' 'private' { Language.Ocaml.Abs.VirtualPrivate }

VirtualWithMutableFlag :: { Language.Ocaml.Abs.VirtualWithMutableFlag }
VirtualWithMutableFlag
  : 'virtual' { Language.Ocaml.Abs.VirtualWithImmutable }
  | 'mutable' 'virtual' { Language.Ocaml.Abs.MutableWithVirtual }
  | 'virtual' 'mutable' { Language.Ocaml.Abs.VirtualWithMutable }

VirtualWithPrivateFlag :: { Language.Ocaml.Abs.VirtualWithPrivateFlag }
VirtualWithPrivateFlag
  : 'virtual' { Language.Ocaml.Abs.VirtualWithPublic }
  | 'private' 'virtual' { Language.Ocaml.Abs.PrivateWithVirtual }
  | 'virtual' 'private' { Language.Ocaml.Abs.VirtualWithPrivate }

NoOverrideFlag :: { Language.Ocaml.Abs.NoOverrideFlag }
NoOverrideFlag : {- empty -} { Language.Ocaml.Abs.NoFlag }

OverrideFlag :: { Language.Ocaml.Abs.OverrideFlag }
OverrideFlag
  : {- empty -} { Language.Ocaml.Abs.Fresh }
  | BANG { Language.Ocaml.Abs.Override $1 }

Subtractive :: { Language.Ocaml.Abs.Subtractive }
Subtractive
  : MINUS { Language.Ocaml.Abs.Minus $1 }
  | MINUSDOT { Language.Ocaml.Abs.MinusDot $1 }

Additive :: { Language.Ocaml.Abs.Additive }
Additive
  : PLUS { Language.Ocaml.Abs.Plus $1 }
  | PLUSDOT { Language.Ocaml.Abs.PlusDot $1 }

OptLabel :: { Language.Ocaml.Abs.OptLabel }
OptLabel
  : OPTLABEL { Language.Ocaml.Abs.OptLabel $1 }
  | '?' LIDENT ':' { Language.Ocaml.Abs.OtherLabel $2 }

AttrId :: { Language.Ocaml.Abs.AttrId }
AttrId
  : LIDENT { Language.Ocaml.Abs.LowercaseAttr $1 }
  | UIDENT { Language.Ocaml.Abs.UppercaseAttr $1 }
  | 'and' { Language.Ocaml.Abs.AndAttr }
  | 'as' { Language.Ocaml.Abs.AsAttr }
  | 'assert' { Language.Ocaml.Abs.AssertAttr }
  | 'begin' { Language.Ocaml.Abs.BeginAttr }
  | 'class' { Language.Ocaml.Abs.ClassAttr }
  | 'constraint' { Language.Ocaml.Abs.ConstraintAttr }
  | 'do' { Language.Ocaml.Abs.DoAttr }
  | 'done' { Language.Ocaml.Abs.DoneAttr }
  | 'downto' { Language.Ocaml.Abs.DowntoAttr }
  | 'else' { Language.Ocaml.Abs.ElseAttr }
  | 'end' { Language.Ocaml.Abs.EndAttr }
  | 'exception' { Language.Ocaml.Abs.ExceptionAttr }
  | 'external' { Language.Ocaml.Abs.ExternalAttr }
  | 'false' { Language.Ocaml.Abs.FalseAttr }
  | 'for' { Language.Ocaml.Abs.ForAttr }
  | 'fun' { Language.Ocaml.Abs.FunAttr }
  | 'function' { Language.Ocaml.Abs.FunctionAttr }
  | 'functor' { Language.Ocaml.Abs.FunctorAttr }
  | 'if' { Language.Ocaml.Abs.IfAttr }
  | 'in' { Language.Ocaml.Abs.InAttr }
  | 'include' { Language.Ocaml.Abs.IncludeAttr }
  | 'inherit' { Language.Ocaml.Abs.InheritAttr }
  | 'initializer' { Language.Ocaml.Abs.InitializerAttr }
  | 'lazy' { Language.Ocaml.Abs.LazyAttr }
  | 'let' { Language.Ocaml.Abs.LetAttr }
  | 'match' { Language.Ocaml.Abs.MatchAttr }
  | 'method' { Language.Ocaml.Abs.MethodAttr }
  | 'module' { Language.Ocaml.Abs.ModuleAttr }
  | 'mutable' { Language.Ocaml.Abs.MutableAttr }
  | 'new' { Language.Ocaml.Abs.NewAttr }
  | 'nonrec' { Language.Ocaml.Abs.NonrecAttr }
  | 'object' { Language.Ocaml.Abs.ObjectAttr }
  | 'of' { Language.Ocaml.Abs.OfAttr }
  | 'open' { Language.Ocaml.Abs.OpenAttr }
  | OR { Language.Ocaml.Abs.OrAttr $1 }
  | 'private' { Language.Ocaml.Abs.PrivateAttr }
  | 'rec' { Language.Ocaml.Abs.RecAttr }
  | 'sig' { Language.Ocaml.Abs.SigAttr }
  | 'struct' { Language.Ocaml.Abs.StructAttr }
  | 'then' { Language.Ocaml.Abs.ThenAttr }
  | 'to' { Language.Ocaml.Abs.ToAttr }
  | 'true' { Language.Ocaml.Abs.TrueAttr }
  | 'try' { Language.Ocaml.Abs.TryAttr }
  | 'type' { Language.Ocaml.Abs.TypeAttr }
  | 'val' { Language.Ocaml.Abs.ValAttr }
  | 'virtual' { Language.Ocaml.Abs.VirtualAttr }
  | 'when' { Language.Ocaml.Abs.WhenAttr }
  | 'while' { Language.Ocaml.Abs.WhileAttr }
  | 'with' { Language.Ocaml.Abs.WithAttr }

ListAttrId :: { [Language.Ocaml.Abs.AttrId] }
ListAttrId
  : AttrId { (:[]) $1 } | AttrId '.' ListAttrId { (:) $1 $3 }

Attribute :: { Language.Ocaml.Abs.Attribute }
Attribute
  : '[@' ListAttrId AttrPayload ']' { Language.Ocaml.Abs.Attribute $2 $3 }

PostItemAttribute :: { Language.Ocaml.Abs.PostItemAttribute }
PostItemAttribute
  : '[@@' ListAttrId AttrPayload ']' { Language.Ocaml.Abs.PostItemAttribute $2 $3 }

FloatingAttribute :: { Language.Ocaml.Abs.FloatingAttribute }
FloatingAttribute
  : '[@@@' ListAttrId AttrPayload ']' { Language.Ocaml.Abs.FloatingAttribute $2 $3 }

ListPostItemAttribute :: { [Language.Ocaml.Abs.PostItemAttribute] }
ListPostItemAttribute
  : {- empty -} { [] }
  | PostItemAttribute ListPostItemAttribute { (:) $1 $2 }

ListAttribute :: { [Language.Ocaml.Abs.Attribute] }
ListAttribute
  : {- empty -} { [] } | Attribute ListAttribute { (:) $1 $2 }

Ext :: { Language.Ocaml.Abs.Ext }
Ext
  : {- empty -} { Language.Ocaml.Abs.NoExt }
  | PERCENT ListAttrId { Language.Ocaml.Abs.Ext $1 $2 }

Extension :: { Language.Ocaml.Abs.Extension }
Extension
  : '[%' ListAttrId Payload ']' { Language.Ocaml.Abs.ExtensionPayload $2 $3 }
  | QUOTED_STRING_EXPR { Language.Ocaml.Abs.QuotedStringExpr $1 }

ItemExtension :: { Language.Ocaml.Abs.ItemExtension }
ItemExtension
  : '[%%' ListAttrId Payload ']' { Language.Ocaml.Abs.ItemExtensionPayload $2 $3 }
  | QUOTED_STRING_ITEM { Language.Ocaml.Abs.QuotedStringItem $1 }

Payload :: { Language.Ocaml.Abs.Payload }
Payload
  : Structure { Language.Ocaml.Abs.PayloadStructure $1 }
  | ':' Signature { Language.Ocaml.Abs.PayloadSignature $2 }
  | ':' CoreType { Language.Ocaml.Abs.PayloadCoreType $2 }
  | '?' Pattern { Language.Ocaml.Abs.PayloadPattern $2 }
  | '?' Pattern 'when' SeqExpr { Language.Ocaml.Abs.PayloadGuardedPattern $2 $4 }

AttrPayload :: { Language.Ocaml.Abs.AttrPayload }
AttrPayload : Payload { Language.Ocaml.Abs.AttrPayload $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

