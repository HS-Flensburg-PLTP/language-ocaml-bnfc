-- File generated by the BNF Converter (bnfc 2.9.6).

{-# LANGUAGE CPP #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE LambdaCase #-}
#if __GLASGOW_HASKELL__ <= 708
{-# LANGUAGE OverlappingInstances #-}
#endif

-- | Pretty-printer for Ocaml.

module Ocaml.Print where

import Prelude
  ( ($), (.)
  , Bool(..), (==), (<)
  , Int, Integer, Double, (+), (-), (*)
  , String, (++)
  , ShowS, showChar, showString
  , all, elem, foldr, id, map, null, replicate, shows, span
  )
import Data.Char ( Char, isSpace )
import qualified Ocaml.Abs

-- | The top-level printing method.

printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 False (map ($ "") $ d []) ""
  where
  rend
    :: Int        -- ^ Indentation level.
    -> Bool       -- ^ Pending indentation to be output before next character?
    -> [String]
    -> ShowS
  rend i p = \case
      "["      :ts -> char '[' . rend i False ts
      "("      :ts -> char '(' . rend i False ts
      "{"      :ts -> onNewLine i     p . showChar   '{'  . new (i+1) ts
      "}" : ";":ts -> onNewLine (i-1) p . showString "};" . new (i-1) ts
      "}"      :ts -> onNewLine (i-1) p . showChar   '}'  . new (i-1) ts
      [";"]        -> char ';'
      ";"      :ts -> char ';' . new i ts
      t  : ts@(s:_) | closingOrPunctuation s
                   -> pending . showString t . rend i False ts
      t        :ts -> pending . space t      . rend i False ts
      []           -> id
    where
    -- Output character after pending indentation.
    char :: Char -> ShowS
    char c = pending . showChar c

    -- Output pending indentation.
    pending :: ShowS
    pending = if p then indent i else id

  -- Indentation (spaces) for given indentation level.
  indent :: Int -> ShowS
  indent i = replicateS (2*i) (showChar ' ')

  -- Continue rendering in new line with new indentation.
  new :: Int -> [String] -> ShowS
  new j ts = showChar '\n' . rend j True ts

  -- Make sure we are on a fresh line.
  onNewLine :: Int -> Bool -> ShowS
  onNewLine i p = (if p then id else showChar '\n') . indent i

  -- Separate given string from following text by a space (if needed).
  space :: String -> ShowS
  space t s =
    case (all isSpace t, null spc, null rest) of
      (True , _   , True ) -> []             -- remove trailing space
      (False, _   , True ) -> t              -- remove trailing space
      (False, True, False) -> t ++ ' ' : s   -- add space if none
      _                    -> t ++ s
    where
      (spc, rest) = span isSpace s

  closingOrPunctuation :: String -> Bool
  closingOrPunctuation [c] = c `elem` closerOrPunct
  closingOrPunctuation _   = False

  closerOrPunct :: String
  closerOrPunct = ")],;"

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- | The printer class does the job.

class Print a where
  prt :: Int -> a -> Doc

instance {-# OVERLAPPABLE #-} Print a => Print [a] where
  prt i = concatD . map (prt i)

instance Print Char where
  prt _ c = doc (showChar '\'' . mkEsc '\'' c . showChar '\'')

instance Print String where
  prt _ = printString

printString :: String -> Doc
printString s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q = \case
  s | s == q -> showChar '\\' . showChar s
  '\\' -> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  s -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id

instance Print Integer where
  prt _ x = doc (shows x)

instance Print Double where
  prt _ x = doc (shows x)

instance Print Ocaml.Abs.CHAR where
  prt _ (Ocaml.Abs.CHAR i) = doc $ showString i
instance Print Ocaml.Abs.FLOAT where
  prt _ (Ocaml.Abs.FLOAT i) = doc $ showString i
instance Print Ocaml.Abs.RELOP where
  prt _ (Ocaml.Abs.RELOP i) = doc $ showString i
instance Print Ocaml.Abs.CONCATOP where
  prt _ (Ocaml.Abs.CONCATOP i) = doc $ showString i
instance Print Ocaml.Abs.PLUSMINUSOP where
  prt _ (Ocaml.Abs.PLUSMINUSOP i) = doc $ showString i
instance Print Ocaml.Abs.MULTDIVOP where
  prt _ (Ocaml.Abs.MULTDIVOP i) = doc $ showString i
instance Print Ocaml.Abs.POWOP where
  prt _ (Ocaml.Abs.POWOP i) = doc $ showString i
instance Print Ocaml.Abs.DOTOP where
  prt _ (Ocaml.Abs.DOTOP i) = doc $ showString i
instance Print Ocaml.Abs.LETOP where
  prt _ (Ocaml.Abs.LETOP i) = doc $ showString i
instance Print Ocaml.Abs.ANDOP where
  prt _ (Ocaml.Abs.ANDOP i) = doc $ showString i
instance Print Ocaml.Abs.DecimalLiteral where
  prt _ (Ocaml.Abs.DecimalLiteral i) = doc $ showString i
instance Print Ocaml.Abs.DecimalLiteralModifier where
  prt _ (Ocaml.Abs.DecimalLiteralModifier i) = doc $ showString i
instance Print Ocaml.Abs.HexLiteral where
  prt _ (Ocaml.Abs.HexLiteral i) = doc $ showString i
instance Print Ocaml.Abs.HexLiteralModifier where
  prt _ (Ocaml.Abs.HexLiteralModifier i) = doc $ showString i
instance Print Ocaml.Abs.OctLiteral where
  prt _ (Ocaml.Abs.OctLiteral i) = doc $ showString i
instance Print Ocaml.Abs.OctLiteralModifier where
  prt _ (Ocaml.Abs.OctLiteralModifier i) = doc $ showString i
instance Print Ocaml.Abs.BinLiteral where
  prt _ (Ocaml.Abs.BinLiteral i) = doc $ showString i
instance Print Ocaml.Abs.BinLiteralModifier where
  prt _ (Ocaml.Abs.BinLiteralModifier i) = doc $ showString i
instance Print Ocaml.Abs.LABEL where
  prt _ (Ocaml.Abs.LABEL i) = doc $ showString i
instance Print Ocaml.Abs.LIDENT where
  prt _ (Ocaml.Abs.LIDENT i) = doc $ showString i
instance Print Ocaml.Abs.OPTLABEL where
  prt _ (Ocaml.Abs.OPTLABEL i) = doc $ showString i
instance Print Ocaml.Abs.PREFIXOP where
  prt _ (Ocaml.Abs.PREFIXOP i) = doc $ showString i
instance Print Ocaml.Abs.HASHOP where
  prt _ (Ocaml.Abs.HASHOP i) = doc $ showString i
instance Print Ocaml.Abs.STRING where
  prt _ (Ocaml.Abs.STRING i) = doc $ showString i
instance Print Ocaml.Abs.QUOTED_STRING_EXPR where
  prt _ (Ocaml.Abs.QUOTED_STRING_EXPR i) = doc $ showString i
instance Print Ocaml.Abs.QUOTED_STRING_ITEM where
  prt _ (Ocaml.Abs.QUOTED_STRING_ITEM i) = doc $ showString i
instance Print Ocaml.Abs.UIDENT where
  prt _ (Ocaml.Abs.UIDENT i) = doc $ showString i
instance Print Ocaml.Abs.INT where
  prt i = \case
    Ocaml.Abs.ModifiedDecimal decimalliteralmodifier -> prPrec i 0 (concatD [prt 0 decimalliteralmodifier])
    Ocaml.Abs.Decimal decimalliteral -> prPrec i 0 (concatD [prt 0 decimalliteral])
    Ocaml.Abs.ModifiedHex hexliteralmodifier -> prPrec i 0 (concatD [prt 0 hexliteralmodifier])
    Ocaml.Abs.Hex hexliteral -> prPrec i 0 (concatD [prt 0 hexliteral])
    Ocaml.Abs.ModifiedOct octliteralmodifier -> prPrec i 0 (concatD [prt 0 octliteralmodifier])
    Ocaml.Abs.Oct octliteral -> prPrec i 0 (concatD [prt 0 octliteral])
    Ocaml.Abs.ModifiedBin binliteralmodifier -> prPrec i 0 (concatD [prt 0 binliteralmodifier])
    Ocaml.Abs.Bin binliteral -> prPrec i 0 (concatD [prt 0 binliteral])

instance Print Ocaml.Abs.Implementation where
  prt i = \case
    Ocaml.Abs.Implementation structure -> prPrec i 0 (concatD [prt 0 structure])

instance Print Ocaml.Abs.Interface where
  prt i = \case
    Ocaml.Abs.Interface signature -> prPrec i 0 (concatD [prt 0 signature])

instance Print [Ocaml.Abs.StructureItem] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.ToplevelPhrase where
  prt i = \case
    Ocaml.Abs.StrExpr seqexpr postitemattributes -> prPrec i 0 (concatD [prt 0 seqexpr, prt 0 postitemattributes, doc (showString ";;")])
    Ocaml.Abs.StructureItems structureitems -> prPrec i 0 (concatD [prt 0 structureitems, doc (showString ";;")])
    Ocaml.Abs.ToplevelDirective topleveldirective -> prPrec i 0 (concatD [prt 0 topleveldirective, doc (showString ";;")])

instance Print Ocaml.Abs.UseFile where
  prt i = \case
    Ocaml.Abs.UseFile usefileelements -> prPrec i 0 (concatD [prt 0 usefileelements])
    Ocaml.Abs.UseFileWithStrExp seqexpr postitemattributes usefileelements -> prPrec i 0 (concatD [prt 0 seqexpr, prt 0 postitemattributes, prt 0 usefileelements])

instance Print [Ocaml.Abs.UseFileElement] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.UseFileElement where
  prt i = \case
    Ocaml.Abs.NoUseFileElement -> prPrec i 0 (concatD [doc (showString ";;")])
    Ocaml.Abs.UseFileStrExp seqexpr postitemattributes -> prPrec i 0 (concatD [doc (showString ";;"), prt 0 seqexpr, prt 0 postitemattributes])
    Ocaml.Abs.UseFileStructureItem structureitem -> prPrec i 0 (concatD [prt 0 structureitem])
    Ocaml.Abs.UseFileToplevelDirective topleveldirective -> prPrec i 0 (concatD [prt 0 topleveldirective])

instance Print [Ocaml.Abs.FunctorArg] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.FunctorArg where
  prt i = \case
    Ocaml.Abs.NoFunctorArg -> prPrec i 0 (concatD [doc (showString "("), doc (showString ")")])
    Ocaml.Abs.FunctorArg modulename moduletype -> prPrec i 0 (concatD [doc (showString "("), prt 0 modulename, doc (showString ":"), prt 0 moduletype, doc (showString ")")])

instance Print Ocaml.Abs.ModuleName where
  prt i = \case
    Ocaml.Abs.ModuleNameIdent uident -> prPrec i 0 (concatD [prt 0 uident])
    Ocaml.Abs.ModuleNameUnderscore -> prPrec i 0 (concatD [doc (showString "_")])

instance Print Ocaml.Abs.ModuleExpr where
  prt i = \case
    Ocaml.Abs.ModuleExprStruct attributes structure -> prPrec i 0 (concatD [doc (showString "struct"), prt 0 attributes, prt 0 structure, doc (showString "end")])
    Ocaml.Abs.ModuleExprFunctor attributes functorargs moduleexpr -> prPrec i 0 (concatD [doc (showString "functor"), prt 0 attributes, prt 0 functorargs, doc (showString "->"), prt 0 moduleexpr])
    Ocaml.Abs.ModuleExprParen parenmoduleexpr -> prPrec i 0 (concatD [prt 0 parenmoduleexpr])
    Ocaml.Abs.ModuleExpr moduleexpr attribute -> prPrec i 0 (concatD [prt 0 moduleexpr, prt 0 attribute])
    Ocaml.Abs.ModuleExprIdent modlongident -> prPrec i 0 (concatD [prt 0 modlongident])
    Ocaml.Abs.ModuleExprFunctorApp moduleexpr parenmoduleexpr -> prPrec i 0 (concatD [prt 0 moduleexpr, prt 0 parenmoduleexpr])
    Ocaml.Abs.FunctorAppUnit moduleexpr -> prPrec i 0 (concatD [prt 0 moduleexpr, doc (showString "("), doc (showString ")")])
    Ocaml.Abs.ModuleExprExtension extension -> prPrec i 0 (concatD [prt 0 extension])

instance Print Ocaml.Abs.ParenModuleExpr where
  prt i = \case
    Ocaml.Abs.TypedParenModuleExpr moduleexpr moduletype -> prPrec i 0 (concatD [doc (showString "("), prt 0 moduleexpr, doc (showString ":"), prt 0 moduletype, doc (showString ")")])
    Ocaml.Abs.ParenModuleExpr moduleexpr -> prPrec i 0 (concatD [doc (showString "("), prt 0 moduleexpr, doc (showString ")")])
    Ocaml.Abs.ValParenModuleExpr attributes exprcolonpackagetype -> prPrec i 0 (concatD [doc (showString "("), doc (showString "val"), prt 0 attributes, prt 0 exprcolonpackagetype, doc (showString ")")])

instance Print Ocaml.Abs.ExprColonPackageType where
  prt i = \case
    Ocaml.Abs.Expr expr -> prPrec i 0 (concatD [prt 0 expr])
    Ocaml.Abs.TypedExpr expr moduletype -> prPrec i 0 (concatD [prt 0 expr, doc (showString ":"), prt 0 moduletype])
    Ocaml.Abs.TypedCoercionExpr expr moduletype1 moduletype2 -> prPrec i 0 (concatD [prt 0 expr, doc (showString ":"), prt 0 moduletype1, doc (showString ":>"), prt 0 moduletype2])
    Ocaml.Abs.CoercionExpr expr moduletype -> prPrec i 0 (concatD [prt 0 expr, doc (showString ":>"), prt 0 moduletype])

instance Print [Ocaml.Abs.StructureElement] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.Structure where
  prt i = \case
    Ocaml.Abs.NoStructure -> prPrec i 0 (concatD [])
    Ocaml.Abs.StandaloneExpression seqexpr postitemattributes -> prPrec i 0 (concatD [prt 0 seqexpr, prt 0 postitemattributes])
    Ocaml.Abs.StandaloneExpressionAndStructureElements seqexpr postitemattributes structureelements -> prPrec i 0 (concatD [prt 0 seqexpr, prt 0 postitemattributes, prt 0 structureelements])
    Ocaml.Abs.StructureElements structureelements -> prPrec i 0 (concatD [prt 0 structureelements])

instance Print Ocaml.Abs.StructureElement where
  prt i = \case
    Ocaml.Abs.StructureSemiSemi -> prPrec i 0 (concatD [doc (showString ";;")])
    Ocaml.Abs.StructureStrExpr seqexpr postitemattributes -> prPrec i 0 (concatD [doc (showString ";;"), prt 0 seqexpr, prt 0 postitemattributes])
    Ocaml.Abs.StructureItem structureitem -> prPrec i 0 (concatD [prt 0 structureitem])

instance Print Ocaml.Abs.StructureItem where
  prt i = \case
    Ocaml.Abs.StructureLetBindings letbindingsext -> prPrec i 0 (concatD [prt 0 letbindingsext])
    Ocaml.Abs.StructureItemExtension itemextension postitemattributes -> prPrec i 0 (concatD [prt 0 itemextension, prt 0 postitemattributes])
    Ocaml.Abs.StructureFloatingAttribute floatingattribute -> prPrec i 0 (concatD [prt 0 floatingattribute])
    Ocaml.Abs.StructurePrimitiveDeclaration primitivedeclaration -> prPrec i 0 (concatD [prt 0 primitivedeclaration])
    Ocaml.Abs.StructureValueDescription valuedescription -> prPrec i 0 (concatD [prt 0 valuedescription])
    Ocaml.Abs.StructureTypeDeclarations typedeclaration andtypedeclarations -> prPrec i 0 (concatD [prt 0 typedeclaration, prt 0 andtypedeclarations])
    Ocaml.Abs.StructureStrTypeExtension strtypeextension -> prPrec i 0 (concatD [prt 0 strtypeextension])
    Ocaml.Abs.StrExceptionDeclaration strexceptiondeclaration -> prPrec i 0 (concatD [prt 0 strexceptiondeclaration])
    Ocaml.Abs.StructureModuleBinding ext attributes modulename modulebindingbody postitemattributes -> prPrec i 0 (concatD [doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, prt 0 postitemattributes])
    Ocaml.Abs.StructureRecModuleBindings ext attributes modulename modulebindingbody postitemattributes andmodulebindings -> prPrec i 0 (concatD [doc (showString "module"), prt 0 ext, prt 0 attributes, doc (showString "rec"), prt 0 modulename, prt 0 modulebindingbody, prt 0 postitemattributes, prt 0 andmodulebindings])
    Ocaml.Abs.StructureModuleTypeDeclaration moduletypedeclaration -> prPrec i 0 (concatD [prt 0 moduletypedeclaration])
    Ocaml.Abs.StructureOpenDeclaration opendeclaration -> prPrec i 0 (concatD [prt 0 opendeclaration])
    Ocaml.Abs.StructureClassDeclarations ext attributes virtualflag formalclassparameters lident classfunbinding postitemattributes andclassdeclarations -> prPrec i 0 (concatD [doc (showString "class"), prt 0 ext, prt 0 attributes, prt 0 virtualflag, prt 0 formalclassparameters, prt 0 lident, prt 0 classfunbinding, prt 0 postitemattributes, prt 0 andclassdeclarations])
    Ocaml.Abs.StructureClassTypeDeclarations classtypedeclarations -> prPrec i 0 (concatD [prt 0 classtypedeclarations])
    Ocaml.Abs.StructureIncludeStatement ext attributes moduleexpr postitemattributes -> prPrec i 0 (concatD [doc (showString "include"), prt 0 ext, prt 0 attributes, prt 0 moduleexpr, prt 0 postitemattributes])

instance Print Ocaml.Abs.ModuleBindingBody where
  prt i = \case
    Ocaml.Abs.ModuleBinding moduleexpr -> prPrec i 0 (concatD [doc (showString "="), prt 0 moduleexpr])
    Ocaml.Abs.TypedModuleBinding moduletype moduleexpr -> prPrec i 0 (concatD [doc (showString ":"), prt 0 moduletype, doc (showString "="), prt 0 moduleexpr])
    Ocaml.Abs.FunctorBinding functorarg modulebindingbody -> prPrec i 0 (concatD [prt 0 functorarg, prt 0 modulebindingbody])

instance Print [Ocaml.Abs.AndModuleBinding] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [doc (showString "and"), prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.AndModuleBinding where
  prt i = \case
    Ocaml.Abs.AndModuleBinding attributes modulename modulebindingbody postitemattributes -> prPrec i 0 (concatD [prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, prt 0 postitemattributes])

instance Print Ocaml.Abs.OptionalModuleType where
  prt i = \case
    Ocaml.Abs.NoModuleType -> prPrec i 0 (concatD [])
    Ocaml.Abs.AModuleType moduletype -> prPrec i 0 (concatD [doc (showString "="), prt 0 moduletype])

instance Print Ocaml.Abs.ModuleTypeDeclaration where
  prt i = \case
    Ocaml.Abs.ModuleTypeDeclaration attributes ocamlident optionalmoduletype postitemattributes -> prPrec i 0 (concatD [doc (showString "module"), doc (showString "type"), prt 0 attributes, prt 0 ocamlident, prt 0 optionalmoduletype, prt 0 postitemattributes])

instance Print Ocaml.Abs.OpenDeclaration where
  prt i = \case
    Ocaml.Abs.OpenDeclaration overrideflag ext attributes moduleexpr postitemattributes -> prPrec i 0 (concatD [doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, prt 0 postitemattributes])

instance Print Ocaml.Abs.OpenDescription where
  prt i = \case
    Ocaml.Abs.OpenDescription overrideflag ext attributes modextlongident postitemattributes -> prPrec i 0 (concatD [doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 modextlongident, prt 0 postitemattributes])

instance Print [Ocaml.Abs.WithConstraint] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "and"), prt 0 xs]

instance Print Ocaml.Abs.ModuleType where
  prt i = \case
    Ocaml.Abs.ModuleTypeSignature attributes signature -> prPrec i 0 (concatD [doc (showString "sig"), prt 0 attributes, prt 0 signature, doc (showString "end")])
    Ocaml.Abs.ModuleTypeFunctor attributes functorargs moduletype -> prPrec i 0 (concatD [doc (showString "functor"), prt 0 attributes, prt 0 functorargs, doc (showString "->"), prt 0 moduletype])
    Ocaml.Abs.ModuleTypeOf attributes moduleexpr -> prPrec i 0 (concatD [doc (showString "module"), doc (showString "type"), doc (showString "of"), prt 0 attributes, prt 0 moduleexpr])
    Ocaml.Abs.ParenModuleType moduletype -> prPrec i 0 (concatD [doc (showString "("), prt 0 moduletype, doc (showString ")")])
    Ocaml.Abs.ModuleTypeWithAttribute moduletype attribute -> prPrec i 0 (concatD [prt 0 moduletype, prt 0 attribute])
    Ocaml.Abs.ModuleTypeModuleIdent modlongident -> prPrec i 0 (concatD [prt 0 modlongident])
    Ocaml.Abs.ModuleTypeNoArgFunctorApp moduletype -> prPrec i 0 (concatD [doc (showString "("), doc (showString ")"), doc (showString "->"), prt 0 moduletype])
    Ocaml.Abs.ModuleTypeFunctorApp moduletype1 moduletype2 -> prPrec i 0 (concatD [prt 0 moduletype1, doc (showString "->"), prt 0 moduletype2])
    Ocaml.Abs.ModuleTypeWith moduletype withconstraints -> prPrec i 0 (concatD [prt 0 moduletype, doc (showString "with"), prt 0 withconstraints])
    Ocaml.Abs.ModuleTypeExtension extension -> prPrec i 0 (concatD [prt 0 extension])

instance Print Ocaml.Abs.Signature where
  prt i = \case
    Ocaml.Abs.Signature signatureelements -> prPrec i 0 (concatD [prt 0 signatureelements])

instance Print [Ocaml.Abs.SignatureElement] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.SignatureElement where
  prt i = \case
    Ocaml.Abs.SigSemiSemi -> prPrec i 0 (concatD [doc (showString ";;")])
    Ocaml.Abs.SigItem signatureitem -> prPrec i 0 (concatD [prt 0 signatureitem])

instance Print Ocaml.Abs.SignatureItem where
  prt i = \case
    Ocaml.Abs.SigItemExtension itemextension postitemattributes -> prPrec i 0 (concatD [prt 0 itemextension, prt 0 postitemattributes])
    Ocaml.Abs.SigFloatingAttribute floatingattribute -> prPrec i 0 (concatD [prt 0 floatingattribute])
    Ocaml.Abs.SigValueDescription valuedescription -> prPrec i 0 (concatD [prt 0 valuedescription])
    Ocaml.Abs.SigPrimitiveDeclaration primitivedeclaration -> prPrec i 0 (concatD [prt 0 primitivedeclaration])
    Ocaml.Abs.SigTypeDeclarations typedeclaration andtypedeclarations -> prPrec i 0 (concatD [prt 0 typedeclaration, prt 0 andtypedeclarations])
    Ocaml.Abs.SigTypeSubstDeclarations typesubstdeclarations -> prPrec i 0 (concatD [prt 0 typesubstdeclarations])
    Ocaml.Abs.SigSigTypeExtension sigtypeextension -> prPrec i 0 (concatD [prt 0 sigtypeextension])
    Ocaml.Abs.SigSigExceptionDeclaration sigexceptiondeclaration -> prPrec i 0 (concatD [prt 0 sigexceptiondeclaration])
    Ocaml.Abs.SigModuleDeclaration moduledeclaration -> prPrec i 0 (concatD [prt 0 moduledeclaration])
    Ocaml.Abs.SigModuleAlias modulealias -> prPrec i 0 (concatD [prt 0 modulealias])
    Ocaml.Abs.SigModuleSubst modulesubst -> prPrec i 0 (concatD [prt 0 modulesubst])
    Ocaml.Abs.SigRecModuleDeclarations recmoduledeclaration andmoduledeclarations -> prPrec i 0 (concatD [prt 0 recmoduledeclaration, prt 0 andmoduledeclarations])
    Ocaml.Abs.SigModuleTypeDeclaration moduletypedeclaration -> prPrec i 0 (concatD [prt 0 moduletypedeclaration])
    Ocaml.Abs.SigModuleTypeSubst moduletypesubst -> prPrec i 0 (concatD [prt 0 moduletypesubst])
    Ocaml.Abs.SigOpenDescription opendescription -> prPrec i 0 (concatD [prt 0 opendescription])
    Ocaml.Abs.SigIncludeStatement moduletypeincludestatement -> prPrec i 0 (concatD [prt 0 moduletypeincludestatement])
    Ocaml.Abs.SigClassDescription ext attributes virtualflag formalclassparameters lident classtype postitemattributes andclassdescriptions -> prPrec i 0 (concatD [doc (showString "class"), prt 0 ext, prt 0 attributes, prt 0 virtualflag, prt 0 formalclassparameters, prt 0 lident, doc (showString ":"), prt 0 classtype, prt 0 postitemattributes, prt 0 andclassdescriptions])
    Ocaml.Abs.SigClassTypeDeclarations classtypedeclarations -> prPrec i 0 (concatD [prt 0 classtypedeclarations])

instance Print Ocaml.Abs.ModuleTypeIncludeStatement where
  prt i = \case
    Ocaml.Abs.ModuleTypeIncludeStatement ext attributes moduletype postitemattributes -> prPrec i 0 (concatD [doc (showString "include"), prt 0 ext, prt 0 attributes, prt 0 moduletype, prt 0 postitemattributes])

instance Print Ocaml.Abs.ModuleDeclaration where
  prt i = \case
    Ocaml.Abs.ModuleDeclaration ext attributes modulename moduledeclarationbody postitemattributes -> prPrec i 0 (concatD [doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 moduledeclarationbody, prt 0 postitemattributes])

instance Print Ocaml.Abs.ModuleDeclarationBody where
  prt i = \case
    Ocaml.Abs.ModuleBody moduletype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 moduletype])
    Ocaml.Abs.FunctorBody functorarg moduledeclarationbody -> prPrec i 0 (concatD [prt 0 functorarg, prt 0 moduledeclarationbody])

instance Print Ocaml.Abs.ModuleAlias where
  prt i = \case
    Ocaml.Abs.ModuleAlias ext attributes modulename moduleexpralias postitemattributes -> prPrec i 0 (concatD [doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, doc (showString "="), prt 0 moduleexpralias, prt 0 postitemattributes])

instance Print Ocaml.Abs.ModuleExprAlias where
  prt i = \case
    Ocaml.Abs.ModuleExprAlias modlongident -> prPrec i 0 (concatD [prt 0 modlongident])

instance Print Ocaml.Abs.ModuleSubst where
  prt i = \case
    Ocaml.Abs.ModuleSubst ext attributes uident modextlongident postitemattributes -> prPrec i 0 (concatD [doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 uident, doc (showString ":="), prt 0 modextlongident, prt 0 postitemattributes])

instance Print Ocaml.Abs.RecModuleDeclaration where
  prt i = \case
    Ocaml.Abs.RecModuleDeclaration ext attributes modulename moduletype postitemattributes -> prPrec i 0 (concatD [doc (showString "module"), prt 0 ext, prt 0 attributes, doc (showString "rec"), prt 0 modulename, doc (showString ":"), prt 0 moduletype, prt 0 postitemattributes])

instance Print Ocaml.Abs.AndModuleDeclaration where
  prt i = \case
    Ocaml.Abs.AndModuleDeclaration attributes modulename moduletype postitemattributes -> prPrec i 0 (concatD [prt 0 attributes, prt 0 modulename, doc (showString ":"), prt 0 moduletype, prt 0 postitemattributes])

instance Print [Ocaml.Abs.AndModuleDeclaration] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "and"), prt 0 xs]

instance Print Ocaml.Abs.ModuleTypeSubst where
  prt i = \case
    Ocaml.Abs.ModuleTypeSubst ext attributes ocamlident moduletype postitemattributes -> prPrec i 0 (concatD [doc (showString "module"), doc (showString "type"), prt 0 ext, prt 0 attributes, prt 0 ocamlident, doc (showString ":="), prt 0 moduletype, prt 0 postitemattributes])

instance Print Ocaml.Abs.AndClassDeclaration where
  prt i = \case
    Ocaml.Abs.AndClassDeclaration attributes virtualflag formalclassparameters lident classfunbinding postitemattributes -> prPrec i 0 (concatD [doc (showString "and"), prt 0 attributes, prt 0 virtualflag, prt 0 formalclassparameters, prt 0 lident, prt 0 classfunbinding, prt 0 postitemattributes])

instance Print [Ocaml.Abs.AndClassDeclaration] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.ClassFunBinding where
  prt i = \case
    Ocaml.Abs.ClassFunBinding classexpr -> prPrec i 0 (concatD [doc (showString "="), prt 0 classexpr])
    Ocaml.Abs.TypedClassFunBinding classtype classexpr -> prPrec i 0 (concatD [doc (showString ":"), prt 0 classtype, doc (showString "="), prt 0 classexpr])
    Ocaml.Abs.LabeledClassFunBinding labeledsimplepattern classfunbinding -> prPrec i 0 (concatD [prt 0 labeledsimplepattern, prt 0 classfunbinding])

instance Print Ocaml.Abs.FormalClassParameters where
  prt i = \case
    Ocaml.Abs.NoFormalClassParamters -> prPrec i 0 (concatD [])
    Ocaml.Abs.FormalClassParameters typeparameters -> prPrec i 0 (concatD [doc (showString "["), prt 0 typeparameters, doc (showString "]")])

instance Print Ocaml.Abs.ClassExpr where
  prt i = \case
    Ocaml.Abs.ClassSimpleExpr classsimpleexpr -> prPrec i 0 (concatD [prt 0 classsimpleexpr])
    Ocaml.Abs.ClassExprFunctor attributes classfundef -> prPrec i 0 (concatD [doc (showString "fun"), prt 0 attributes, prt 0 classfundef])
    Ocaml.Abs.ClassExprLetBindings letbindingsnoext classexpr -> prPrec i 0 (concatD [prt 0 letbindingsnoext, doc (showString "in"), prt 0 classexpr])
    Ocaml.Abs.ClassExprLetOpen overrideflag attributes modlongident classexpr -> prPrec i 0 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 attributes, prt 0 modlongident, doc (showString "in"), prt 0 classexpr])
    Ocaml.Abs.ClassExpr classexpr attribute -> prPrec i 0 (concatD [prt 0 classexpr, prt 0 attribute])
    Ocaml.Abs.LabeledClassSimpleExpr classsimpleexpr labeledsimpleexprs -> prPrec i 0 (concatD [prt 0 classsimpleexpr, prt 0 labeledsimpleexprs])
    Ocaml.Abs.ClassExprExtension extension -> prPrec i 0 (concatD [prt 0 extension])

instance Print Ocaml.Abs.ClassSimpleExpr where
  prt i = \case
    Ocaml.Abs.ParenClassExpr classexpr -> prPrec i 0 (concatD [doc (showString "("), prt 0 classexpr, doc (showString ")")])
    Ocaml.Abs.ClassName classlongident -> prPrec i 0 (concatD [prt 0 classlongident])
    Ocaml.Abs.ClassNameWithParamters coretypes classlongident -> prPrec i 0 (concatD [doc (showString "["), prt 0 coretypes, doc (showString "]"), prt 0 classlongident])
    Ocaml.Abs.TypedClassExpr classexpr classtype -> prPrec i 0 (concatD [doc (showString "("), prt 0 classexpr, doc (showString ":"), prt 0 classtype, doc (showString ")")])
    Ocaml.Abs.ClassSimplExprObject attributes classstructure -> prPrec i 0 (concatD [doc (showString "object"), prt 0 attributes, prt 0 classstructure, doc (showString "end")])

instance Print Ocaml.Abs.ClassFunDef where
  prt i = \case
    Ocaml.Abs.ClassFun labeledsimplepattern classexpr -> prPrec i 0 (concatD [prt 0 labeledsimplepattern, doc (showString "->"), prt 0 classexpr])
    Ocaml.Abs.LabeledClassFunDef labeledsimplepattern classfundef -> prPrec i 0 (concatD [prt 0 labeledsimplepattern, prt 0 classfundef])

instance Print Ocaml.Abs.ClassStructure where
  prt i = \case
    Ocaml.Abs.ClassSelfPattern classselfpattern classfields -> prPrec i 0 (concatD [prt 0 classselfpattern, prt 0 classfields])

instance Print Ocaml.Abs.ClassSelfPattern where
  prt i = \case
    Ocaml.Abs.ParenClassPattern pattern_ -> prPrec i 0 (concatD [doc (showString "("), prt 0 pattern_, doc (showString ")")])
    Ocaml.Abs.TypedClassPattern pattern_ coretype -> prPrec i 0 (concatD [doc (showString "("), prt 0 pattern_, doc (showString ":"), prt 0 coretype, doc (showString ")")])
    Ocaml.Abs.NoClassSelfPattern -> prPrec i 0 (concatD [])

instance Print [Ocaml.Abs.ClassField] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.OptionalAs where
  prt i = \case
    Ocaml.Abs.NoAs -> prPrec i 0 (concatD [])
    Ocaml.Abs.AAs lident -> prPrec i 0 (concatD [doc (showString "as"), prt 0 lident])

instance Print Ocaml.Abs.ClassField where
  prt i = \case
    Ocaml.Abs.ClassFieldInherit overrideflag attributes classexpr optionalas postitemattributes -> prPrec i 0 (concatD [doc (showString "inherit"), prt 0 overrideflag, prt 0 attributes, prt 0 classexpr, prt 0 optionalas, prt 0 postitemattributes])
    Ocaml.Abs.ClassFieldVal value postitemattributes -> prPrec i 0 (concatD [doc (showString "val"), prt 0 value, prt 0 postitemattributes])
    Ocaml.Abs.ClassFieldMethod method postitemattributes -> prPrec i 0 (concatD [doc (showString "method"), prt 0 method, prt 0 postitemattributes])
    Ocaml.Abs.ClassFieldConstraint attributes coretype1 coretype2 postitemattributes -> prPrec i 0 (concatD [doc (showString "constraint"), prt 0 attributes, prt 0 coretype1, doc (showString "="), prt 0 coretype2, prt 0 postitemattributes])
    Ocaml.Abs.ClassFieldInitializer attributes seqexpr postitemattributes -> prPrec i 0 (concatD [doc (showString "initializer"), prt 0 attributes, prt 0 seqexpr, prt 0 postitemattributes])
    Ocaml.Abs.ClassFieldItemExtension itemextension postitemattributes -> prPrec i 0 (concatD [prt 0 itemextension, prt 0 postitemattributes])
    Ocaml.Abs.ClassFieldFloatingAttribute floatingattribute -> prPrec i 0 (concatD [prt 0 floatingattribute])

instance Print Ocaml.Abs.Value where
  prt i = \case
    Ocaml.Abs.Value1 nooverrideflag attributes virtualwithmutableflag lident coretype -> prPrec i 0 (concatD [prt 0 nooverrideflag, prt 0 attributes, prt 0 virtualwithmutableflag, prt 0 lident, doc (showString ":"), prt 0 coretype])
    Ocaml.Abs.Value2 overrideflag attributes mutableflag lident seqexpr -> prPrec i 0 (concatD [prt 0 overrideflag, prt 0 attributes, prt 0 mutableflag, prt 0 lident, doc (showString "="), prt 0 seqexpr])
    Ocaml.Abs.Value3 overrideflag attributes mutableflag lident typeconstraint seqexpr -> prPrec i 0 (concatD [prt 0 overrideflag, prt 0 attributes, prt 0 mutableflag, prt 0 lident, prt 0 typeconstraint, doc (showString "="), prt 0 seqexpr])

instance Print Ocaml.Abs.Method_ where
  prt i = \case
    Ocaml.Abs.Method1 nooverrideflag attributes virtualwithprivateflag lident polytype -> prPrec i 0 (concatD [prt 0 nooverrideflag, prt 0 attributes, prt 0 virtualwithprivateflag, prt 0 lident, doc (showString ":"), prt 0 polytype])
    Ocaml.Abs.Method2 overrideflag attributes privateflag lident strictbinding -> prPrec i 0 (concatD [prt 0 overrideflag, prt 0 attributes, prt 0 privateflag, prt 0 lident, prt 0 strictbinding])
    Ocaml.Abs.Method3 overrideflag attributes privateflag lident polytype seqexpr -> prPrec i 0 (concatD [prt 0 overrideflag, prt 0 attributes, prt 0 privateflag, prt 0 lident, doc (showString ":"), prt 0 polytype, doc (showString "="), prt 0 seqexpr])
    Ocaml.Abs.Method4 overrideflag attributes privateflag lident lidents coretype seqexpr -> prPrec i 0 (concatD [prt 0 overrideflag, prt 0 attributes, prt 0 privateflag, prt 0 lident, doc (showString ":"), doc (showString "type"), prt 0 lidents, doc (showString "."), prt 0 coretype, doc (showString "="), prt 0 seqexpr])

instance Print Ocaml.Abs.ClassType where
  prt i = \case
    Ocaml.Abs.ClassSignature classsignature -> prPrec i 0 (concatD [prt 0 classsignature])
    Ocaml.Abs.ClassTypeWithOptLabel optlabel tupletype classtype -> prPrec i 0 (concatD [prt 0 optlabel, prt 0 tupletype, doc (showString "->"), prt 0 classtype])
    Ocaml.Abs.ClassTypeWithOptionalLabel lident tupletype classtype -> prPrec i 0 (concatD [doc (showString "?"), prt 0 lident, doc (showString ":"), prt 0 tupletype, doc (showString "->"), prt 0 classtype])
    Ocaml.Abs.ClassTypeWithtLabel lident tupletype classtype -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 tupletype, doc (showString "->"), prt 0 classtype])
    Ocaml.Abs.ClassTypeWithoutLabel tupletype classtype -> prPrec i 0 (concatD [prt 0 tupletype, doc (showString "->"), prt 0 classtype])

instance Print Ocaml.Abs.ClassSignature where
  prt i = \case
    Ocaml.Abs.ClassSignatureName cltylongident -> prPrec i 0 (concatD [prt 0 cltylongident])
    Ocaml.Abs.ClassSignatureNameWithParamters coretypes cltylongident -> prPrec i 0 (concatD [doc (showString "["), prt 0 coretypes, doc (showString "]"), prt 0 cltylongident])
    Ocaml.Abs.ClassSignatureExtension extension -> prPrec i 0 (concatD [prt 0 extension])
    Ocaml.Abs.ClassSignatureObject attributes classselftype classsigfields -> prPrec i 0 (concatD [doc (showString "object"), prt 0 attributes, prt 0 classselftype, prt 0 classsigfields, doc (showString "end")])
    Ocaml.Abs.WithAttribute classsignature attribute -> prPrec i 0 (concatD [prt 0 classsignature, prt 0 attribute])
    Ocaml.Abs.ClassSignatureLetOpen overrideflag attributes modlongident classsignature -> prPrec i 0 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 attributes, prt 0 modlongident, doc (showString "in"), prt 0 classsignature])

instance Print Ocaml.Abs.ClassSelfType where
  prt i = \case
    Ocaml.Abs.ClassSelfType coretype -> prPrec i 0 (concatD [doc (showString "("), prt 0 coretype, doc (showString ")")])
    Ocaml.Abs.NoClassSelfType -> prPrec i 0 (concatD [])

instance Print Ocaml.Abs.ClassSigField where
  prt i = \case
    Ocaml.Abs.ClassSigFieldInherit attributes classsignature postitemattributes -> prPrec i 0 (concatD [doc (showString "inherit"), prt 0 attributes, prt 0 classsignature, prt 0 postitemattributes])
    Ocaml.Abs.ClassSigFieldVal attributes mutablevirtualflags lident coretype postitemattributes -> prPrec i 0 (concatD [doc (showString "val"), prt 0 attributes, prt 0 mutablevirtualflags, prt 0 lident, doc (showString ":"), prt 0 coretype, prt 0 postitemattributes])
    Ocaml.Abs.ClassSigFieldMethod attributes privatevirtualflags lident polytype postitemattributes -> prPrec i 0 (concatD [doc (showString "method"), prt 0 attributes, prt 0 privatevirtualflags, prt 0 lident, doc (showString ":"), prt 0 polytype, prt 0 postitemattributes])
    Ocaml.Abs.ClassSigFieldConstraint attributes coretype1 coretype2 postitemattributes -> prPrec i 0 (concatD [doc (showString "constraint"), prt 0 attributes, prt 0 coretype1, doc (showString "="), prt 0 coretype2, prt 0 postitemattributes])
    Ocaml.Abs.ClassSigFieldItemExtension itemextension postitemattributes -> prPrec i 0 (concatD [prt 0 itemextension, prt 0 postitemattributes])
    Ocaml.Abs.ClassSigFieldFloatingAttribute floatingattribute -> prPrec i 0 (concatD [prt 0 floatingattribute])

instance Print [Ocaml.Abs.ClassSigField] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.Constrain where
  prt i = \case
    Ocaml.Abs.Constrain coretype1 coretype2 -> prPrec i 0 (concatD [prt 0 coretype1, doc (showString "="), prt 0 coretype2])

instance Print Ocaml.Abs.AndClassDescription where
  prt i = \case
    Ocaml.Abs.AndClassDescription attributes virtualflag formalclassparameters lident classtype postitemattributes -> prPrec i 0 (concatD [doc (showString "and"), prt 0 attributes, prt 0 virtualflag, prt 0 formalclassparameters, prt 0 lident, doc (showString ":"), prt 0 classtype, prt 0 postitemattributes])

instance Print [Ocaml.Abs.AndClassDescription] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.ClassTypeDeclarations where
  prt i = \case
    Ocaml.Abs.ClassTypeDeclarations classtypedeclaration andclasstypedeclarations -> prPrec i 0 (concatD [prt 0 classtypedeclaration, prt 0 andclasstypedeclarations])

instance Print Ocaml.Abs.ClassTypeDeclaration where
  prt i = \case
    Ocaml.Abs.ClassTypeDeclaration ext attributes virtualflag formalclassparameters lident classsignature postitemattributes -> prPrec i 0 (concatD [doc (showString "class"), doc (showString "type"), prt 0 ext, prt 0 attributes, prt 0 virtualflag, prt 0 formalclassparameters, prt 0 lident, doc (showString "="), prt 0 classsignature, prt 0 postitemattributes])

instance Print Ocaml.Abs.AndClassTypeDeclaration where
  prt i = \case
    Ocaml.Abs.AndClassTypeDeclaration attributes virtualflag formalclassparameters lident classsignature postitemattributes -> prPrec i 0 (concatD [prt 0 attributes, prt 0 virtualflag, prt 0 formalclassparameters, prt 0 lident, doc (showString "="), prt 0 classsignature, prt 0 postitemattributes])

instance Print [Ocaml.Abs.AndClassTypeDeclaration] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "and"), prt 0 xs]

instance Print Ocaml.Abs.SeqExpr where
  prt i = \case
    Ocaml.Abs.FinalFunExpr funexpr -> prPrec i 0 (concatD [prt 1 funexpr])
    Ocaml.Abs.FinalFunExprSemi funexpr -> prPrec i 0 (concatD [prt 1 funexpr, doc (showString ";")])
    Ocaml.Abs.MoreFunExprs funexpr seqexpr -> prPrec i 0 (concatD [prt 1 funexpr, doc (showString ";"), prt 0 seqexpr])
    Ocaml.Abs.MoreFunExprsAttr funexpr attrids seqexpr -> prPrec i 0 (concatD [prt 1 funexpr, doc (showString ";"), doc (showString "%"), prt 0 attrids, prt 0 seqexpr])
    Ocaml.Abs.SeqExprFunction ext attributes matchcases -> prPrec i 0 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])

instance Print Ocaml.Abs.LabeledSimplePattern where
  prt i = \case
    Ocaml.Abs.OptPattern labelletpattern optdefault -> prPrec i 0 (concatD [doc (showString "?"), doc (showString "("), prt 0 labelletpattern, prt 0 optdefault, doc (showString ")")])
    Ocaml.Abs.OptLabelVar lident -> prPrec i 0 (concatD [doc (showString "?"), prt 0 lident])
    Ocaml.Abs.OptLabeledPattern optlabel letpattern optdefault -> prPrec i 0 (concatD [prt 0 optlabel, doc (showString "("), prt 0 letpattern, prt 0 optdefault, doc (showString ")")])
    Ocaml.Abs.OptLabeledVar optlabel patternvar -> prPrec i 0 (concatD [prt 0 optlabel, prt 0 patternvar])
    Ocaml.Abs.LabeledPattern labelletpattern -> prPrec i 0 (concatD [doc (showString "~"), doc (showString "("), prt 0 labelletpattern, doc (showString ")")])
    Ocaml.Abs.LabeledVar lident -> prPrec i 0 (concatD [doc (showString "~"), prt 0 lident])
    Ocaml.Abs.LabeledSimplePattern label simplepattern -> prPrec i 0 (concatD [prt 0 label, prt 0 simplepattern])
    Ocaml.Abs.SimplePattern simplepattern -> prPrec i 0 (concatD [prt 0 simplepattern])

instance Print Ocaml.Abs.PatternVar where
  prt i = \case
    Ocaml.Abs.PatternVar lident -> prPrec i 0 (concatD [prt 0 lident])
    Ocaml.Abs.UnderscorePatternVar -> prPrec i 0 (concatD [doc (showString "_")])

instance Print Ocaml.Abs.OptDefault where
  prt i = \case
    Ocaml.Abs.NoDefault -> prPrec i 0 (concatD [])
    Ocaml.Abs.Default seqexpr -> prPrec i 0 (concatD [doc (showString "="), prt 0 seqexpr])

instance Print Ocaml.Abs.LabelLetPattern where
  prt i = \case
    Ocaml.Abs.LabelLetPattern lident -> prPrec i 0 (concatD [prt 0 lident])
    Ocaml.Abs.TypedLabelLetPattern lident coretype -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 coretype])

instance Print Ocaml.Abs.LetPattern where
  prt i = \case
    Ocaml.Abs.LetPattern pattern_ -> prPrec i 0 (concatD [prt 0 pattern_])
    Ocaml.Abs.TypedLetPattern pattern_ coretype -> prPrec i 0 (concatD [prt 0 pattern_, doc (showString ":"), prt 0 coretype])

instance Print Ocaml.Abs.QualifiedDotop where
  prt i = \case
    Ocaml.Abs.Unqualified dotop -> prPrec i 0 (concatD [prt 0 dotop])
    Ocaml.Abs.Qualified modlongident dotop -> prPrec i 0 (concatD [doc (showString "."), prt 0 modlongident, prt 0 dotop])

instance Print Ocaml.Abs.OptionalAtomicTypeAnnotation where
  prt i = \case
    Ocaml.Abs.NoAtomicTypeAnnotation -> prPrec i 0 (concatD [])
    Ocaml.Abs.AnAtomicTypeAnnotation atomictype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 atomictype])

instance Print Ocaml.Abs.FunExpr where
  prt i = \case
    Ocaml.Abs.ConstrName_ constrlongident -> prPrec i 16 (concatD [prt 0 constrlongident])
    Ocaml.Abs.NameTagApp nametag simpleexpr -> prPrec i 15 (concatD [prt 0 nametag, prt 16 simpleexpr])
    Ocaml.Abs.SimpleExprApp simpleexpr labeledsimpleexprs -> prPrec i 15 (concatD [prt 16 simpleexpr, prt 0 labeledsimpleexprs])
    Ocaml.Abs.Assert ext attributes simpleexpr -> prPrec i 15 (concatD [doc (showString "assert"), prt 0 ext, prt 0 attributes, prt 16 simpleexpr])
    Ocaml.Abs.Lazy ext attributes simpleexpr -> prPrec i 15 (concatD [doc (showString "lazy"), prt 0 ext, prt 0 attributes, prt 16 simpleexpr])
    Ocaml.Abs.SimpleExpr simpleexpr -> prPrec i 15 (concatD [prt 16 simpleexpr])
    Ocaml.Abs.Subtractive subtractive expr -> prPrec i 14 (concatD [prt 0 subtractive, prt 15 expr])
    Ocaml.Abs.Additive additive expr -> prPrec i 14 (concatD [prt 0 additive, prt 15 expr])
    Ocaml.Abs.PowInfix funexpr powop expr -> prPrec i 13 (concatD [prt 14 funexpr, prt 0 powop, prt 13 expr])
    Ocaml.Abs.MultDivInfix funexpr multdivop expr -> prPrec i 12 (concatD [prt 12 funexpr, prt 0 multdivop, prt 13 expr])
    Ocaml.Abs.MultInfix funexpr expr -> prPrec i 12 (concatD [prt 12 funexpr, doc (showString "*"), prt 13 expr])
    Ocaml.Abs.DivInfix funexpr expr -> prPrec i 12 (concatD [prt 12 funexpr, doc (showString "/"), prt 13 expr])
    Ocaml.Abs.ModInfix funexpr expr -> prPrec i 12 (concatD [prt 12 funexpr, doc (showString "%"), prt 13 expr])
    Ocaml.Abs.PlusMinusInfix funexpr plusminusop expr -> prPrec i 11 (concatD [prt 11 funexpr, prt 0 plusminusop, prt 12 expr])
    Ocaml.Abs.PlusInfix funexpr expr -> prPrec i 11 (concatD [prt 11 funexpr, doc (showString "+"), prt 12 expr])
    Ocaml.Abs.PlusDotInfix funexpr expr -> prPrec i 11 (concatD [prt 11 funexpr, doc (showString "+."), prt 12 expr])
    Ocaml.Abs.MinusInfix funexpr expr -> prPrec i 11 (concatD [prt 11 funexpr, doc (showString "-"), prt 12 expr])
    Ocaml.Abs.MinusDotInfix funexpr expr -> prPrec i 11 (concatD [prt 11 funexpr, doc (showString "-."), prt 12 expr])
    Ocaml.Abs.Cons funexpr expr -> prPrec i 10 (concatD [prt 11 funexpr, doc (showString "::"), prt 10 expr])
    Ocaml.Abs.ConcatInfix funexpr concatop expr -> prPrec i 9 (concatD [prt 10 funexpr, prt 0 concatop, prt 9 expr])
    Ocaml.Abs.RelInfix funexpr relop expr -> prPrec i 8 (concatD [prt 8 funexpr, prt 0 relop, prt 9 expr])
    Ocaml.Abs.EqualInfix funexpr expr -> prPrec i 8 (concatD [prt 8 funexpr, doc (showString "="), prt 9 expr])
    Ocaml.Abs.LessInfix funexpr expr -> prPrec i 8 (concatD [prt 8 funexpr, doc (showString "<"), prt 9 expr])
    Ocaml.Abs.GreaterInfix funexpr expr -> prPrec i 8 (concatD [prt 8 funexpr, doc (showString ">"), prt 9 expr])
    Ocaml.Abs.Infix funexpr expr -> prPrec i 7 (concatD [prt 8 funexpr, doc (showString "&"), prt 7 expr])
    Ocaml.Abs.OrInfix funexpr expr -> prPrec i 6 (concatD [prt 7 funexpr, doc (showString "or"), prt 6 expr])
    Ocaml.Abs.BarBarInfix funexpr expr -> prPrec i 6 (concatD [prt 7 funexpr, doc (showString "||"), prt 6 expr])
    Ocaml.Abs.Comma expr exprcommas -> prPrec i 5 (concatD [prt 6 expr, doc (showString ","), prt 0 exprcommas])
    Ocaml.Abs.UpdateExpr lident expr -> prPrec i 4 (concatD [prt 0 lident, doc (showString "<-"), prt 0 expr])
    Ocaml.Abs.AssignInfix funexpr expr -> prPrec i 4 (concatD [prt 5 funexpr, doc (showString ":="), prt 0 expr])
    Ocaml.Abs.QualifiedDot simpleexpr labellongident expr -> prPrec i 4 (concatD [prt 17 simpleexpr, doc (showString "."), prt 0 labellongident, doc (showString "<-"), prt 0 expr])
    Ocaml.Abs.ArrayUpdateExpr simpleexpr seqexpr expr -> prPrec i 4 (concatD [prt 17 simpleexpr, doc (showString "."), doc (showString "("), prt 0 seqexpr, doc (showString ")"), doc (showString "<-"), prt 0 expr])
    Ocaml.Abs.RecordUpdateExpr simpleexpr seqexpr expr -> prPrec i 4 (concatD [prt 17 simpleexpr, doc (showString "."), doc (showString "{"), prt 0 seqexpr, doc (showString "}"), doc (showString "<-"), prt 0 expr])
    Ocaml.Abs.StringUpdateExpr simpleexpr seqexpr expr -> prPrec i 4 (concatD [prt 17 simpleexpr, doc (showString "."), doc (showString "["), prt 0 seqexpr, doc (showString "]"), doc (showString "<-"), prt 0 expr])
    Ocaml.Abs.ArrayUpdateDotopExpr simpleexpr qualifieddotop exprs expr -> prPrec i 4 (concatD [prt 17 simpleexpr, prt 0 qualifieddotop, doc (showString "("), prt 0 exprs, doc (showString ")"), doc (showString "<-"), prt 0 expr])
    Ocaml.Abs.RecordUpdateDotopExpr simpleexpr qualifieddotop exprs expr -> prPrec i 4 (concatD [prt 17 simpleexpr, prt 0 qualifieddotop, doc (showString "{"), prt 0 exprs, doc (showString "}"), doc (showString "<-"), prt 0 expr])
    Ocaml.Abs.StringUpdateDotopExpr simpleexpr qualifieddotop exprs expr -> prPrec i 4 (concatD [prt 17 simpleexpr, prt 0 qualifieddotop, doc (showString "["), prt 0 exprs, doc (showString "]"), doc (showString "<-"), prt 0 expr])
    Ocaml.Abs.IfElse ext attributes seqexpr expr1 expr2 -> prPrec i 3 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Ocaml.Abs.If ext attributes seqexpr expr -> prPrec i 3 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Ocaml.Abs.Let letbindingsext seqexpr -> prPrec i 1 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpBinding letop letopbindings seqexpr -> prPrec i 1 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetModule ext attributes modulename modulebindingbody seqexpr -> prPrec i 1 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetException ext attributes letexceptiondeclaration seqexpr -> prPrec i 1 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes, prt 0 letexceptiondeclaration, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpen overrideflag ext attributes moduleexpr seqexpr -> prPrec i 1 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.Fun ext attributes funparamaslists optionalatomictypeannotation funbody -> prPrec i 1 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparamaslists, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Ocaml.Abs.Match ext attributes seqexpr matchcases -> prPrec i 1 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.Try ext attributes seqexpr matchcases -> prPrec i 1 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.While ext attributes seqexpr1 seqexpr2 -> prPrec i 1 (concatD [doc (showString "while"), prt 0 ext, prt 0 attributes, prt 0 seqexpr1, doc (showString "do"), prt 0 seqexpr2, doc (showString "done")])
    Ocaml.Abs.For ext attributes pattern_ seqexpr1 directionflag seqexpr2 seqexpr3 -> prPrec i 1 (concatD [doc (showString "for"), prt 0 ext, prt 0 attributes, prt 0 pattern_, doc (showString "="), prt 0 seqexpr1, prt 0 directionflag, prt 0 seqexpr2, doc (showString "do"), prt 0 seqexpr3, doc (showString "done")])
    Ocaml.Abs.FunExprWithAttribute funexpr attribute -> prPrec i 1 (concatD [prt 2 funexpr, prt 0 attribute])

instance Print Ocaml.Abs.Expr where
  prt i = \case
    Ocaml.Abs.Function15 ext attributes matchcases -> prPrec i 15 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Ocaml.Abs.Let15 letbindingsext seqexpr -> prPrec i 15 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpBinding15 letop letopbindings seqexpr -> prPrec i 15 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetModule15 ext attributes modulename modulebindingbody seqexpr -> prPrec i 15 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetException15 ext attributes letexceptiondeclaration seqexpr -> prPrec i 15 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes, prt 0 letexceptiondeclaration, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpen15 overrideflag ext attributes moduleexpr seqexpr -> prPrec i 15 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.Fun15 ext attributes funparamaslists optionalatomictypeannotation funbody -> prPrec i 15 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparamaslists, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Ocaml.Abs.Match15 ext attributes seqexpr matchcases -> prPrec i 15 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.Try15 ext attributes seqexpr matchcases -> prPrec i 15 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.IfElse15 ext attributes seqexpr expr1 expr2 -> prPrec i 15 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Ocaml.Abs.If15 ext attributes seqexpr expr -> prPrec i 15 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Ocaml.Abs.FunExpr15 funexpr -> prPrec i 15 (concatD [prt 15 funexpr])
    Ocaml.Abs.Function13 ext attributes matchcases -> prPrec i 13 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Ocaml.Abs.Let13 letbindingsext seqexpr -> prPrec i 13 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpBinding13 letop letopbindings seqexpr -> prPrec i 13 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetModule13 ext attributes modulename modulebindingbody seqexpr -> prPrec i 13 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetException13 ext attributes letexceptiondeclaration seqexpr -> prPrec i 13 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes, prt 0 letexceptiondeclaration, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpen13 overrideflag ext attributes moduleexpr seqexpr -> prPrec i 13 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.Fun13 ext attributes funparamaslists optionalatomictypeannotation funbody -> prPrec i 13 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparamaslists, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Ocaml.Abs.Match13 ext attributes seqexpr matchcases -> prPrec i 13 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.Try13 ext attributes seqexpr matchcases -> prPrec i 13 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.IfElse13 ext attributes seqexpr expr1 expr2 -> prPrec i 13 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Ocaml.Abs.If13 ext attributes seqexpr expr -> prPrec i 13 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Ocaml.Abs.FunExpr13 funexpr -> prPrec i 13 (concatD [prt 13 funexpr])
    Ocaml.Abs.Function12 ext attributes matchcases -> prPrec i 12 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Ocaml.Abs.Let12 letbindingsext seqexpr -> prPrec i 12 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpBinding12 letop letopbindings seqexpr -> prPrec i 12 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetModule12 ext attributes modulename modulebindingbody seqexpr -> prPrec i 12 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetException12 ext attributes letexceptiondeclaration seqexpr -> prPrec i 12 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes, prt 0 letexceptiondeclaration, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpen12 overrideflag ext attributes moduleexpr seqexpr -> prPrec i 12 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.Fun12 ext attributes funparamaslists optionalatomictypeannotation funbody -> prPrec i 12 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparamaslists, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Ocaml.Abs.Match12 ext attributes seqexpr matchcases -> prPrec i 12 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.Try12 ext attributes seqexpr matchcases -> prPrec i 12 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.IfElse12 ext attributes seqexpr expr1 expr2 -> prPrec i 12 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Ocaml.Abs.If12 ext attributes seqexpr expr -> prPrec i 12 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Ocaml.Abs.FunExpr12 funexpr -> prPrec i 12 (concatD [prt 12 funexpr])
    Ocaml.Abs.Function11 ext attributes matchcases -> prPrec i 11 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Ocaml.Abs.Let11 letbindingsext seqexpr -> prPrec i 11 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpBinding11 letop letopbindings seqexpr -> prPrec i 11 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetModule11 ext attributes modulename modulebindingbody seqexpr -> prPrec i 11 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetException11 ext attributes letexceptiondeclaration seqexpr -> prPrec i 11 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes, prt 0 letexceptiondeclaration, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpen11 overrideflag ext attributes moduleexpr seqexpr -> prPrec i 11 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.Fun11 ext attributes funparamaslists optionalatomictypeannotation funbody -> prPrec i 11 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparamaslists, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Ocaml.Abs.Match11 ext attributes seqexpr matchcases -> prPrec i 11 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.Try11 ext attributes seqexpr matchcases -> prPrec i 11 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.IfElse11 ext attributes seqexpr expr1 expr2 -> prPrec i 11 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Ocaml.Abs.If11 ext attributes seqexpr expr -> prPrec i 11 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Ocaml.Abs.FunExpr11 funexpr -> prPrec i 11 (concatD [prt 11 funexpr])
    Ocaml.Abs.Function10 ext attributes matchcases -> prPrec i 10 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Ocaml.Abs.Let10 letbindingsext seqexpr -> prPrec i 10 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpBinding10 letop letopbindings seqexpr -> prPrec i 10 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetModule10 ext attributes modulename modulebindingbody seqexpr -> prPrec i 10 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetException10 ext attributes letexceptiondeclaration seqexpr -> prPrec i 10 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes, prt 0 letexceptiondeclaration, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpen10 overrideflag ext attributes moduleexpr seqexpr -> prPrec i 10 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.Fun10 ext attributes funparamaslists optionalatomictypeannotation funbody -> prPrec i 10 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparamaslists, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Ocaml.Abs.Match10 ext attributes seqexpr matchcases -> prPrec i 10 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.Try10 ext attributes seqexpr matchcases -> prPrec i 10 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.IfElse10 ext attributes seqexpr expr1 expr2 -> prPrec i 10 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Ocaml.Abs.If10 ext attributes seqexpr expr -> prPrec i 10 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Ocaml.Abs.FunExpr10 funexpr -> prPrec i 10 (concatD [prt 10 funexpr])
    Ocaml.Abs.Function9 ext attributes matchcases -> prPrec i 9 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Ocaml.Abs.Let9 letbindingsext seqexpr -> prPrec i 9 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpBinding9 letop letopbindings seqexpr -> prPrec i 9 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetModule9 ext attributes modulename modulebindingbody seqexpr -> prPrec i 9 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetException9 ext attributes letexceptiondeclaration seqexpr -> prPrec i 9 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes, prt 0 letexceptiondeclaration, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpen9 overrideflag ext attributes moduleexpr seqexpr -> prPrec i 9 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.Fun9 ext attributes funparamaslists optionalatomictypeannotation funbody -> prPrec i 9 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparamaslists, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Ocaml.Abs.Match9 ext attributes seqexpr matchcases -> prPrec i 9 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.Try9 ext attributes seqexpr matchcases -> prPrec i 9 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.IfElse9 ext attributes seqexpr expr1 expr2 -> prPrec i 9 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Ocaml.Abs.If9 ext attributes seqexpr expr -> prPrec i 9 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Ocaml.Abs.FunExpr9 funexpr -> prPrec i 9 (concatD [prt 9 funexpr])
    Ocaml.Abs.Function7 ext attributes matchcases -> prPrec i 7 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Ocaml.Abs.Let7 letbindingsext seqexpr -> prPrec i 7 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpBinding7 letop letopbindings seqexpr -> prPrec i 7 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetModule7 ext attributes modulename modulebindingbody seqexpr -> prPrec i 7 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetException7 ext attributes letexceptiondeclaration seqexpr -> prPrec i 7 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes, prt 0 letexceptiondeclaration, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpen7 overrideflag ext attributes moduleexpr seqexpr -> prPrec i 7 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.Fun7 ext attributes funparamaslists optionalatomictypeannotation funbody -> prPrec i 7 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparamaslists, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Ocaml.Abs.Match7 ext attributes seqexpr matchcases -> prPrec i 7 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.Try7 ext attributes seqexpr matchcases -> prPrec i 7 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.IfElse7 ext attributes seqexpr expr1 expr2 -> prPrec i 7 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Ocaml.Abs.If7 ext attributes seqexpr expr -> prPrec i 7 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Ocaml.Abs.FunExpr7 funexpr -> prPrec i 7 (concatD [prt 7 funexpr])
    Ocaml.Abs.Function6 ext attributes matchcases -> prPrec i 6 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Ocaml.Abs.Let6 letbindingsext seqexpr -> prPrec i 6 (concatD [prt 0 letbindingsext, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpBinding6 letop letopbindings seqexpr -> prPrec i 6 (concatD [prt 0 letop, prt 0 letopbindings, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetModule6 ext attributes modulename modulebindingbody seqexpr -> prPrec i 6 (concatD [doc (showString "let"), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, prt 0 modulebindingbody, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetException6 ext attributes letexceptiondeclaration seqexpr -> prPrec i 6 (concatD [doc (showString "let"), doc (showString "exception"), prt 0 ext, prt 0 attributes, prt 0 letexceptiondeclaration, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.LetOpen6 overrideflag ext attributes moduleexpr seqexpr -> prPrec i 6 (concatD [doc (showString "let"), doc (showString "open"), prt 0 overrideflag, prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString "in"), prt 0 seqexpr])
    Ocaml.Abs.Fun6 ext attributes funparamaslists optionalatomictypeannotation funbody -> prPrec i 6 (concatD [doc (showString "fun"), prt 0 ext, prt 0 attributes, prt 0 funparamaslists, prt 0 optionalatomictypeannotation, doc (showString "->"), prt 0 funbody])
    Ocaml.Abs.Match6 ext attributes seqexpr matchcases -> prPrec i 6 (concatD [doc (showString "match"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.Try6 ext attributes seqexpr matchcases -> prPrec i 6 (concatD [doc (showString "try"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "with"), prt 0 matchcases])
    Ocaml.Abs.IfElse6 ext attributes seqexpr expr1 expr2 -> prPrec i 6 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr1, doc (showString "else"), prt 0 expr2])
    Ocaml.Abs.If6 ext attributes seqexpr expr -> prPrec i 6 (concatD [doc (showString "if"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "then"), prt 0 expr])
    Ocaml.Abs.FunExpr6 funexpr -> prPrec i 6 (concatD [prt 6 funexpr])
    Ocaml.Abs.Function ext attributes matchcases -> prPrec i 0 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Ocaml.Abs.FunExpr1 funexpr -> prPrec i 0 (concatD [prt 1 funexpr])

instance Print Ocaml.Abs.SimpleExpr where
  prt i = \case
    Ocaml.Abs.ParenSeqExpr seqexpr -> prPrec i 19 (concatD [doc (showString "("), prt 0 seqexpr, doc (showString ")")])
    Ocaml.Abs.TypedSeqExpr seqexpr typeconstraint -> prPrec i 19 (concatD [doc (showString "("), prt 0 seqexpr, prt 0 typeconstraint, doc (showString ")")])
    Ocaml.Abs.ValLongident_ vallongident -> prPrec i 19 (concatD [prt 0 vallongident])
    Ocaml.Abs.Constant_ constant -> prPrec i 19 (concatD [prt 0 constant])
    Ocaml.Abs.ConstrName constrlongident -> prPrec i 19 (concatD [prt 0 constrlongident])
    Ocaml.Abs.NameTag_ nametag -> prPrec i 19 (concatD [prt 0 nametag])
    Ocaml.Abs.ObjectExpr objectexprfields -> prPrec i 19 (concatD [doc (showString "{<"), prt 0 objectexprfields, doc (showString ">}")])
    Ocaml.Abs.EmptyObjectExpr -> prPrec i 19 (concatD [doc (showString "{<"), doc (showString ">}")])
    Ocaml.Abs.QualifiedArrayExpr_ modlongident seqexpr -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "("), prt 0 seqexpr, doc (showString ")")])
    Ocaml.Abs.QualifiedObjectExpr modlongident objectexprfields -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "{"), prt 0 objectexprfields, doc (showString "}")])
    Ocaml.Abs.Extension extension -> prPrec i 19 (concatD [prt 0 extension])
    Ocaml.Abs.EmptyQualifiedArrayAccess modlongident -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "("), doc (showString ")")])
    Ocaml.Abs.RecordExpr_ recordexprcontent -> prPrec i 19 (concatD [doc (showString "{"), prt 0 recordexprcontent, doc (showString "}")])
    Ocaml.Abs.RecordAccess modlongident recordexprcontent -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "{"), prt 0 recordexprcontent, doc (showString "}")])
    Ocaml.Abs.ArrayExpr_ exprs -> prPrec i 19 (concatD [doc (showString "[|"), prt 0 exprs, doc (showString "|]")])
    Ocaml.Abs.EmptyArrayExpr -> prPrec i 19 (concatD [doc (showString "[|"), doc (showString "|]")])
    Ocaml.Abs.ArrayAccesss modlongident exprs -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "[|"), prt 0 exprs, doc (showString "|]")])
    Ocaml.Abs.ArrayAccesssTodo modlongident -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "[|"), doc (showString "|]")])
    Ocaml.Abs.StringExpr_ exprs -> prPrec i 19 (concatD [doc (showString "["), prt 0 exprs, doc (showString "]")])
    Ocaml.Abs.StringAccess modlongident exprs -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "["), prt 0 exprs, doc (showString "]")])
    Ocaml.Abs.StringAccessTodo modlongident -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "["), doc (showString "]")])
    Ocaml.Abs.QualifiedModule modlongident ext attributes moduleexpr moduletype -> prPrec i 19 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "("), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString ":"), prt 0 moduletype, doc (showString ")")])
    Ocaml.Abs.BeginEnd ext attributes seqexpr -> prPrec i 19 (concatD [doc (showString "begin"), prt 0 ext, prt 0 attributes, prt 0 seqexpr, doc (showString "end")])
    Ocaml.Abs.EmptyBeginEnd ext attributes -> prPrec i 19 (concatD [doc (showString "begin"), prt 0 ext, prt 0 attributes, doc (showString "end")])
    Ocaml.Abs.New ext attributes classlongident -> prPrec i 19 (concatD [doc (showString "new"), prt 0 ext, prt 0 attributes, prt 0 classlongident])
    Ocaml.Abs.Module ext attributes moduleexpr -> prPrec i 19 (concatD [doc (showString "("), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString ")")])
    Ocaml.Abs.TypedModule ext attributes moduleexpr moduletype -> prPrec i 19 (concatD [doc (showString "("), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 moduleexpr, doc (showString ":"), prt 0 moduletype, doc (showString ")")])
    Ocaml.Abs.Object ext attributes classstructure -> prPrec i 19 (concatD [doc (showString "object"), prt 0 ext, prt 0 attributes, prt 0 classstructure, doc (showString "end")])
    Ocaml.Abs.PrefixApp prefixop simpleexpr -> prPrec i 18 (concatD [prt 0 prefixop, prt 19 simpleexpr])
    Ocaml.Abs.BangApp simpleexpr -> prPrec i 18 (concatD [doc (showString "!"), prt 19 simpleexpr])
    Ocaml.Abs.ArrayExpr simpleexpr seqexpr -> prPrec i 17 (concatD [prt 17 simpleexpr, doc (showString "."), doc (showString "("), prt 0 seqexpr, doc (showString ")")])
    Ocaml.Abs.RecordExpr simpleexpr seqexpr -> prPrec i 17 (concatD [prt 17 simpleexpr, doc (showString "."), doc (showString "{"), prt 0 seqexpr, doc (showString "}")])
    Ocaml.Abs.StringExpr simpleexpr seqexpr -> prPrec i 17 (concatD [prt 17 simpleexpr, doc (showString "."), doc (showString "["), prt 0 seqexpr, doc (showString "]")])
    Ocaml.Abs.QualifiedArrayExpr simpleexpr qualifieddotop exprs -> prPrec i 17 (concatD [prt 17 simpleexpr, prt 0 qualifieddotop, doc (showString "("), prt 0 exprs, doc (showString ")")])
    Ocaml.Abs.QualifiedRecordExpr simpleexpr qualifieddotop exprs -> prPrec i 17 (concatD [prt 17 simpleexpr, prt 0 qualifieddotop, doc (showString "{"), prt 0 exprs, doc (showString "}")])
    Ocaml.Abs.QualifiedStringExpr simpleexpr qualifieddotop exprs -> prPrec i 17 (concatD [prt 17 simpleexpr, prt 0 qualifieddotop, doc (showString "["), prt 0 exprs, doc (showString "]")])
    Ocaml.Abs.RecordAccessTodo simpleexpr labellongident -> prPrec i 17 (concatD [prt 17 simpleexpr, doc (showString "."), prt 0 labellongident])
    Ocaml.Abs.MethodInvocation simpleexpr lident -> prPrec i 16 (concatD [prt 17 simpleexpr, doc (showString "#"), prt 0 lident])
    Ocaml.Abs.HashOp simpleexpr1 hashop simpleexpr2 -> prPrec i 16 (concatD [prt 17 simpleexpr1, prt 0 hashop, prt 16 simpleexpr2])

instance Print [Ocaml.Abs.LabeledSimpleExpr] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.LabeledSimpleExpr where
  prt i = \case
    Ocaml.Abs.LabeldSimpleExpr16 simpleexpr -> prPrec i 0 (concatD [prt 16 simpleexpr])
    Ocaml.Abs.LabeledExpr16 label simpleexpr -> prPrec i 0 (concatD [prt 0 label, prt 16 simpleexpr])
    Ocaml.Abs.Label16 lident -> prPrec i 0 (concatD [doc (showString "~"), prt 0 lident])
    Ocaml.Abs.TypedLabel16 lident typeconstraint -> prPrec i 0 (concatD [doc (showString "~"), doc (showString "("), prt 0 lident, prt 0 typeconstraint, doc (showString ")")])
    Ocaml.Abs.OptLabel16 lident -> prPrec i 0 (concatD [doc (showString "?"), prt 0 lident])
    Ocaml.Abs.OptLabeledExpr16 optlabel simpleexpr -> prPrec i 0 (concatD [prt 0 optlabel, prt 16 simpleexpr])

instance Print Ocaml.Abs.LetBindingBodyNoPunning where
  prt i = \case
    Ocaml.Abs.StrictBinding valident strictbinding -> prPrec i 0 (concatD [prt 0 valident, prt 0 strictbinding])
    Ocaml.Abs.MonoTypedBinding valident typeconstraint seqexpr -> prPrec i 0 (concatD [prt 0 valident, prt 0 typeconstraint, doc (showString "="), prt 0 seqexpr])
    Ocaml.Abs.PolyTypedBinding valident typevars coretype seqexpr -> prPrec i 0 (concatD [prt 0 valident, doc (showString ":"), prt 0 typevars, doc (showString "."), prt 0 coretype, doc (showString "="), prt 0 seqexpr])
    Ocaml.Abs.TypedBindingTodo valident lidents coretype seqexpr -> prPrec i 0 (concatD [prt 0 valident, doc (showString ":"), doc (showString "type"), prt 0 lidents, doc (showString "."), prt 0 coretype, doc (showString "="), prt 0 seqexpr])
    Ocaml.Abs.PatternNoExnBindingNoPunning patternnoexn seqexpr -> prPrec i 0 (concatD [prt 0 patternnoexn, doc (showString "="), prt 0 seqexpr])
    Ocaml.Abs.TypedBinding simplepatternnotident coretype seqexpr -> prPrec i 0 (concatD [prt 0 simplepatternnotident, doc (showString ":"), prt 0 coretype, doc (showString "="), prt 0 seqexpr])

instance Print Ocaml.Abs.LetBindingBody where
  prt i = \case
    Ocaml.Abs.LetBindingBodyNoPunning letbindingbodynopunning -> prPrec i 0 (concatD [prt 0 letbindingbodynopunning])

instance Print Ocaml.Abs.LetBindingsNoExt where
  prt i = \case
    Ocaml.Abs.SingleLetBindingNoExt attributes recflag letbindingbody postitemattributes -> prPrec i 0 (concatD [doc (showString "let"), prt 0 attributes, prt 0 recflag, prt 0 letbindingbody, prt 0 postitemattributes])
    Ocaml.Abs.MultipleLetBindingNoExt letbindingsnoext andletbinding -> prPrec i 0 (concatD [prt 0 letbindingsnoext, prt 0 andletbinding])

instance Print Ocaml.Abs.LetBindingsExt where
  prt i = \case
    Ocaml.Abs.SingleLetBindingExt ext attributes recflag letbindingbody postitemattributes -> prPrec i 0 (concatD [doc (showString "let"), prt 0 ext, prt 0 attributes, prt 0 recflag, prt 0 letbindingbody, prt 0 postitemattributes])
    Ocaml.Abs.MultipleLetBindingExt letbindingsext andletbinding -> prPrec i 0 (concatD [prt 0 letbindingsext, prt 0 andletbinding])

instance Print Ocaml.Abs.AndLetBinding where
  prt i = \case
    Ocaml.Abs.AndLetBinding attributes letbindingbody postitemattributes -> prPrec i 0 (concatD [doc (showString "and"), prt 0 attributes, prt 0 letbindingbody, prt 0 postitemattributes])

instance Print Ocaml.Abs.LetopBindingBody where
  prt i = \case
    Ocaml.Abs.LetIdent valident strictbinding -> prPrec i 0 (concatD [prt 0 valident, prt 0 strictbinding])
    Ocaml.Abs.LetopValIdent valident -> prPrec i 0 (concatD [prt 0 valident])
    Ocaml.Abs.SimplePatternBinding simplepattern coretype seqexpr -> prPrec i 0 (concatD [prt 0 simplepattern, doc (showString ":"), prt 0 coretype, doc (showString "="), prt 0 seqexpr])
    Ocaml.Abs.PatternNoExnBinding patternnoexn seqexpr -> prPrec i 0 (concatD [prt 0 patternnoexn, doc (showString "="), prt 0 seqexpr])

instance Print Ocaml.Abs.LetopBindings where
  prt i = \case
    Ocaml.Abs.BindingBody letopbindingbody -> prPrec i 0 (concatD [prt 0 letopbindingbody])
    Ocaml.Abs.AndOpBinding letopbindings andop letopbindingbody -> prPrec i 0 (concatD [prt 0 letopbindings, prt 0 andop, prt 0 letopbindingbody])

instance Print Ocaml.Abs.StrictBinding where
  prt i = \case
    Ocaml.Abs.Binding seqexpr -> prPrec i 0 (concatD [doc (showString "="), prt 0 seqexpr])
    Ocaml.Abs.FunParams funparamaslists optionaltypeconstraint funbody -> prPrec i 0 (concatD [prt 0 funparamaslists, prt 0 optionaltypeconstraint, doc (showString "="), prt 0 funbody])

instance Print Ocaml.Abs.FunBody where
  prt i = \case
    Ocaml.Abs.FunBodyFunction ext attributes matchcases -> prPrec i 0 (concatD [doc (showString "function"), prt 0 ext, prt 0 attributes, prt 0 matchcases])
    Ocaml.Abs.FunBodyFinalFunExpr funexpr -> prPrec i 0 (concatD [prt 1 funexpr])
    Ocaml.Abs.FunBodyFinalFunExprSemi funexpr -> prPrec i 0 (concatD [prt 1 funexpr, doc (showString ";")])
    Ocaml.Abs.FunBodyMoreFunExprs funexpr seqexpr -> prPrec i 0 (concatD [prt 1 funexpr, doc (showString ";"), prt 0 seqexpr])
    Ocaml.Abs.FunBodyMoreFunExprsAttr funexpr attrids seqexpr -> prPrec i 0 (concatD [prt 1 funexpr, doc (showString ";"), doc (showString "%"), prt 0 attrids, prt 0 seqexpr])

instance Print [Ocaml.Abs.MatchCase] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "|"), prt 0 xs]

instance Print Ocaml.Abs.MatchCase where
  prt i = \case
    Ocaml.Abs.MatchCase pattern_ seqexpr -> prPrec i 0 (concatD [prt 0 pattern_, doc (showString "->"), prt 0 seqexpr])
    Ocaml.Abs.GuardedMatchCase pattern_ seqexpr1 seqexpr2 -> prPrec i 0 (concatD [prt 0 pattern_, doc (showString "when"), prt 0 seqexpr1, doc (showString "->"), prt 0 seqexpr2])
    Ocaml.Abs.UnreachableMatchCase pattern_ -> prPrec i 0 (concatD [prt 0 pattern_, doc (showString "->"), doc (showString ".")])

instance Print Ocaml.Abs.FunParamAsList where
  prt i = \case
    Ocaml.Abs.FunParam1 lidents -> prPrec i 0 (concatD [doc (showString "("), doc (showString "type"), prt 0 lidents, doc (showString ")")])
    Ocaml.Abs.FunParam2 labeledsimplepattern -> prPrec i 0 (concatD [prt 0 labeledsimplepattern])

instance Print [Ocaml.Abs.FunParamAsList] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.ExprComma where
  prt i = \case
    Ocaml.Abs.ExprComma expr -> prPrec i 0 (concatD [prt 0 expr])

instance Print [Ocaml.Abs.ExprComma] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Ocaml.Abs.RecordExprFields where
  prt i = \case
    Ocaml.Abs.FinalRecordExprField1 recordexprfield -> prPrec i 0 (concatD [prt 0 recordexprfield])
    Ocaml.Abs.FinalRecordExprField2 recordexprfield -> prPrec i 0 (concatD [prt 0 recordexprfield, doc (showString ";")])
    Ocaml.Abs.MoreRecordExprFields recordexprfield recordexprfields -> prPrec i 0 (concatD [prt 0 recordexprfield, doc (showString ";"), prt 0 recordexprfields])

instance Print Ocaml.Abs.RecordExprContent where
  prt i = \case
    Ocaml.Abs.RecordExprContent1 simpleexpr recordexprfields -> prPrec i 0 (concatD [prt 0 simpleexpr, doc (showString "with"), prt 0 recordexprfields])
    Ocaml.Abs.RecordExprContent2 recordexprfields -> prPrec i 0 (concatD [prt 0 recordexprfields])

instance Print Ocaml.Abs.OptionalTypeConstraint where
  prt i = \case
    Ocaml.Abs.NoTypeConstraint -> prPrec i 0 (concatD [])
    Ocaml.Abs.ATypeConstraint typeconstraint -> prPrec i 0 (concatD [prt 0 typeconstraint])

instance Print Ocaml.Abs.RecordExprField where
  prt i = \case
    Ocaml.Abs.RecordExprField labellongident optionaltypeconstraint optionalassignexpr -> prPrec i 0 (concatD [prt 0 labellongident, prt 0 optionaltypeconstraint, prt 0 optionalassignexpr])

instance Print [Ocaml.Abs.ObjectExprField] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ [x] = concatD [prt 0 x, doc (showString ";")]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print Ocaml.Abs.OptionalAssignExpr where
  prt i = \case
    Ocaml.Abs.NoAssign -> prPrec i 0 (concatD [])
    Ocaml.Abs.AnAssign expr -> prPrec i 0 (concatD [doc (showString "="), prt 0 expr])

instance Print Ocaml.Abs.ObjectExprField where
  prt i = \case
    Ocaml.Abs.ObjectExprField lident optionalassignexpr -> prPrec i 0 (concatD [prt 0 lident, prt 0 optionalassignexpr])

instance Print [Ocaml.Abs.Expr] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ [x] = concatD [prt 0 x, doc (showString ";")]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print Ocaml.Abs.TypeConstraint where
  prt i = \case
    Ocaml.Abs.TypeConstraint coretype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 coretype])
    Ocaml.Abs.TypeConstraintCoercion coretype1 coretype2 -> prPrec i 0 (concatD [doc (showString ":"), prt 0 coretype1, doc (showString ":>"), prt 0 coretype2])
    Ocaml.Abs.TypeCoercion coretype -> prPrec i 0 (concatD [doc (showString ":>"), prt 0 coretype])

instance Print Ocaml.Abs.Pattern where
  prt i = \case
    Ocaml.Abs.Pattern patternpattern -> prPrec i 0 (concatD [prt 0 patternpattern])
    Ocaml.Abs.ExceptionPattern ext attributes pattern_ -> prPrec i 0 (concatD [doc (showString "exception"), prt 0 ext, prt 0 attributes, prt 0 pattern_])

instance Print Ocaml.Abs.PatternNoExn where
  prt i = \case
    Ocaml.Abs.PatternNoExn patternpatternnoexn -> prPrec i 0 (concatD [prt 0 patternpatternnoexn])

instance Print Ocaml.Abs.PatternPattern where
  prt i = \case
    Ocaml.Abs.ConsPattern pattern_1 pattern_2 -> prPrec i 0 (concatD [prt 0 pattern_1, doc (showString "::"), prt 0 pattern_2])
    Ocaml.Abs.PatternWithAttribute pattern_ attribute -> prPrec i 0 (concatD [prt 0 pattern_, prt 0 attribute])
    Ocaml.Abs.PatternGen patterngen -> prPrec i 0 (concatD [prt 0 patterngen])
    Ocaml.Abs.AsPattern pattern_ valident -> prPrec i 0 (concatD [prt 0 pattern_, doc (showString "as"), prt 0 valident])
    Ocaml.Abs.TuplePattern patterncommalistpattern -> prPrec i 0 (concatD [prt 0 patterncommalistpattern])
    Ocaml.Abs.OrPattern pattern_1 pattern_2 -> prPrec i 0 (concatD [prt 0 pattern_1, doc (showString "|"), prt 0 pattern_2])

instance Print Ocaml.Abs.PatternPatternNoExn where
  prt i = \case
    Ocaml.Abs.ConsPatternNoExn patternnoexn pattern_ -> prPrec i 0 (concatD [prt 0 patternnoexn, doc (showString "::"), prt 0 pattern_])
    Ocaml.Abs.PatternWithAttributeNoExn patternnoexn attribute -> prPrec i 0 (concatD [prt 0 patternnoexn, prt 0 attribute])
    Ocaml.Abs.PatternGenNoExn patterngen -> prPrec i 0 (concatD [prt 0 patterngen])
    Ocaml.Abs.AsPatternNoExn patternnoexn valident -> prPrec i 0 (concatD [prt 0 patternnoexn, doc (showString "as"), prt 0 valident])
    Ocaml.Abs.TuplePatternNoExn patterncommalistpatternnoexn -> prPrec i 0 (concatD [prt 0 patterncommalistpatternnoexn])
    Ocaml.Abs.OrPatternNoExn patternnoexn pattern_ -> prPrec i 0 (concatD [prt 0 patternnoexn, doc (showString "|"), prt 0 pattern_])

instance Print [Ocaml.Abs.LIDENT] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.PatternGen where
  prt i = \case
    Ocaml.Abs.SimplePatternGen simplepattern -> prPrec i 0 (concatD [prt 0 simplepattern])
    Ocaml.Abs.ConstrPattern constrlongident pattern_ -> prPrec i 0 (concatD [prt 0 constrlongident, prt 0 pattern_])
    Ocaml.Abs.ConstrTypePattern constrlongident lidents simplepattern -> prPrec i 0 (concatD [prt 0 constrlongident, doc (showString "("), doc (showString "type"), prt 0 lidents, doc (showString ")"), prt 0 simplepattern])
    Ocaml.Abs.TagPatternGen nametag pattern_ -> prPrec i 0 (concatD [prt 0 nametag, prt 0 pattern_])
    Ocaml.Abs.LazyPattern ext attributes simplepattern -> prPrec i 0 (concatD [doc (showString "lazy"), prt 0 ext, prt 0 attributes, prt 0 simplepattern])

instance Print Ocaml.Abs.SimplePattern where
  prt i = \case
    Ocaml.Abs.ValIdent valident -> prPrec i 0 (concatD [prt 0 valident])
    Ocaml.Abs.SimplePatternNotIdent simplepatternnotident -> prPrec i 0 (concatD [prt 0 simplepatternnotident])

instance Print Ocaml.Abs.SimplePatternNotIdent where
  prt i = \case
    Ocaml.Abs.ParenPattern pattern_ -> prPrec i 0 (concatD [doc (showString "("), prt 0 pattern_, doc (showString ")")])
    Ocaml.Abs.SimpleDelimitedPattern simpledelimitedpattern -> prPrec i 0 (concatD [prt 0 simpledelimitedpattern])
    Ocaml.Abs.ParenModule ext attributes modulename -> prPrec i 0 (concatD [doc (showString "("), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, doc (showString ")")])
    Ocaml.Abs.TypedParenModule ext attributes modulename packagetype -> prPrec i 0 (concatD [doc (showString "("), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, doc (showString ":"), prt 0 packagetype, doc (showString ")")])
    Ocaml.Abs.SimplePatternNotIdent_ simplepatternnotident -> prPrec i 0 (concatD [prt 0 simplepatternnotident])

instance Print Ocaml.Abs.SimplePatternNotIdent_ where
  prt i = \case
    Ocaml.Abs.UnderscorePattern -> prPrec i 0 (concatD [doc (showString "_")])
    Ocaml.Abs.ConstantPattern signedconstant -> prPrec i 0 (concatD [prt 0 signedconstant])
    Ocaml.Abs.RangePattern signedconstant1 signedconstant2 -> prPrec i 0 (concatD [prt 0 signedconstant1, doc (showString ".."), prt 0 signedconstant2])
    Ocaml.Abs.ConstrNamePattern constrlongident -> prPrec i 0 (concatD [prt 0 constrlongident])
    Ocaml.Abs.TagPattern nametag -> prPrec i 0 (concatD [prt 0 nametag])
    Ocaml.Abs.TypeConstrPattern typelongident -> prPrec i 0 (concatD [doc (showString "#"), prt 0 typelongident])
    Ocaml.Abs.DotPattern modlongident simpledelimitedpattern -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), prt 0 simpledelimitedpattern])
    Ocaml.Abs.EmptyStringPattern modlongident -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "["), doc (showString "]")])
    Ocaml.Abs.EmptyArrayPattern_ modlongident -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "("), doc (showString ")")])
    Ocaml.Abs.ArrayPattern_ modlongident pattern_ -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), doc (showString "("), prt 0 pattern_, doc (showString ")")])
    Ocaml.Abs.TypedPattern pattern_ coretype -> prPrec i 0 (concatD [doc (showString "("), prt 0 pattern_, doc (showString ":"), prt 0 coretype, doc (showString ")")])
    Ocaml.Abs.ModulePattern ext attributes modulename packagetype -> prPrec i 0 (concatD [doc (showString "("), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 modulename, doc (showString ":"), prt 0 packagetype, doc (showString ")")])
    Ocaml.Abs.ExtensionPattern extension -> prPrec i 0 (concatD [prt 0 extension])

instance Print Ocaml.Abs.SimpleDelimitedPattern where
  prt i = \case
    Ocaml.Abs.RecordPattern recordpatcontent -> prPrec i 0 (concatD [doc (showString "{"), prt 0 recordpatcontent, doc (showString "}")])
    Ocaml.Abs.ListPattern patternsemis -> prPrec i 0 (concatD [doc (showString "["), prt 0 patternsemis, doc (showString "]")])
    Ocaml.Abs.ArrayPattern patternsemis -> prPrec i 0 (concatD [doc (showString "[|"), prt 0 patternsemis, doc (showString "|]")])
    Ocaml.Abs.EmptyArrayPattern -> prPrec i 0 (concatD [doc (showString "[|"), doc (showString "|]")])

instance Print Ocaml.Abs.PatternCommaListPattern where
  prt i = \case
    Ocaml.Abs.MorePattern patterncommalistpattern pattern_ -> prPrec i 0 (concatD [prt 0 patterncommalistpattern, doc (showString ","), prt 0 pattern_])
    Ocaml.Abs.TwoPattern pattern_1 pattern_2 -> prPrec i 0 (concatD [prt 0 pattern_1, doc (showString ","), prt 0 pattern_2])

instance Print Ocaml.Abs.PatternCommaListPatternNoExn where
  prt i = \case
    Ocaml.Abs.MorePatternNoExn patterncommalistpatternnoexn pattern_ -> prPrec i 0 (concatD [prt 0 patterncommalistpatternnoexn, doc (showString ","), prt 0 pattern_])
    Ocaml.Abs.TwoPatternNoExn patternnoexn pattern_ -> prPrec i 0 (concatD [prt 0 patternnoexn, doc (showString ","), prt 0 pattern_])

instance Print Ocaml.Abs.PatternSemi where
  prt i = \case
    Ocaml.Abs.PatternSemi pattern_ -> prPrec i 0 (concatD [prt 0 pattern_])

instance Print [Ocaml.Abs.PatternSemi] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ [x] = concatD [prt 0 x, doc (showString ";")]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print Ocaml.Abs.OptionalSemi where
  prt i = \case
    Ocaml.Abs.NoSemi -> prPrec i 0 (concatD [])
    Ocaml.Abs.ASemi -> prPrec i 0 (concatD [doc (showString ";")])

instance Print Ocaml.Abs.RecordPatContent where
  prt i = \case
    Ocaml.Abs.FinalRecordPattern recordpatfield optionalsemi -> prPrec i 0 (concatD [prt 0 recordpatfield, prt 0 optionalsemi])
    Ocaml.Abs.UnderscoreRecordPattern recordpatfield optionalsemi -> prPrec i 0 (concatD [prt 0 recordpatfield, doc (showString ";"), doc (showString "_"), prt 0 optionalsemi])
    Ocaml.Abs.MoreRecordPatterns recordpatfield recordpatcontent -> prPrec i 0 (concatD [prt 0 recordpatfield, doc (showString ";"), prt 0 recordpatcontent])

instance Print Ocaml.Abs.OptionalCoreType where
  prt i = \case
    Ocaml.Abs.NoCoreType -> prPrec i 0 (concatD [])
    Ocaml.Abs.ACoreType coretype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 coretype])

instance Print Ocaml.Abs.OptionalAssignPattern where
  prt i = \case
    Ocaml.Abs.NoAssignPattern -> prPrec i 0 (concatD [])
    Ocaml.Abs.AnAssignPattern pattern_ -> prPrec i 0 (concatD [doc (showString "="), prt 0 pattern_])

instance Print Ocaml.Abs.RecordPatField where
  prt i = \case
    Ocaml.Abs.RecordPatField labellongident optionalcoretype optionalassignpattern -> prPrec i 0 (concatD [prt 0 labellongident, prt 0 optionalcoretype, prt 0 optionalassignpattern])

instance Print Ocaml.Abs.ValueDescription where
  prt i = \case
    Ocaml.Abs.ValueDescription ext attributes valident polytype postitemattributes -> prPrec i 0 (concatD [doc (showString "val"), prt 0 ext, prt 0 attributes, prt 0 valident, doc (showString ":"), prt 0 polytype, prt 0 postitemattributes])

instance Print [Ocaml.Abs.STRING] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.PrimitiveDeclaration where
  prt i = \case
    Ocaml.Abs.PrmitiveDeclaration ext attributes valident polytype strings postitemattributes -> prPrec i 0 (concatD [doc (showString "external"), prt 0 ext, prt 0 attributes, prt 0 valident, doc (showString ":"), prt 0 polytype, doc (showString "="), prt 0 strings, prt 0 postitemattributes])

instance Print Ocaml.Abs.AndTypeDeclaration where
  prt i = \case
    Ocaml.Abs.AndTypeDeclaration attributes typeparameters lident typekind constraints postitemattributes -> prPrec i 0 (concatD [doc (showString "and"), prt 0 attributes, prt 0 typeparameters, prt 0 lident, prt 0 typekind, prt 0 constraints, prt 0 postitemattributes])

instance Print [Ocaml.Abs.AndTypeDeclaration] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.TypeSubstDeclarations where
  prt i = \case
    Ocaml.Abs.TypeSubstDeclarations typesubstdeclaration andtypesubstdeclarations -> prPrec i 0 (concatD [prt 0 typesubstdeclaration, prt 0 andtypesubstdeclarations])

instance Print Ocaml.Abs.AndTypeSubstDeclaration where
  prt i = \case
    Ocaml.Abs.AndTypeSubstDeclaration attributes typeparameters lident typesubstkind constraints postitemattributes -> prPrec i 0 (concatD [doc (showString "and"), prt 0 attributes, prt 0 typeparameters, prt 0 lident, prt 0 typesubstkind, prt 0 constraints, prt 0 postitemattributes])

instance Print [Ocaml.Abs.AndTypeSubstDeclaration] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "and"), prt 0 xs]

instance Print Ocaml.Abs.TypeDeclaration where
  prt i = \case
    Ocaml.Abs.NonrecTypeDeclaration ext attributes typeparameters lident typekind constraints postitemattributes -> prPrec i 0 (concatD [doc (showString "type"), prt 0 ext, prt 0 attributes, doc (showString "nonrec"), prt 0 typeparameters, prt 0 lident, prt 0 typekind, prt 0 constraints, prt 0 postitemattributes])
    Ocaml.Abs.TypeDeclaration ext attributes typeparameters lident typekind constraints postitemattributes -> prPrec i 0 (concatD [doc (showString "type"), prt 0 ext, prt 0 attributes, prt 0 typeparameters, prt 0 lident, prt 0 typekind, prt 0 constraints, prt 0 postitemattributes])

instance Print Ocaml.Abs.TypeSubstDeclaration where
  prt i = \case
    Ocaml.Abs.TypeSubstDeclaration ext attributes typeparameters lident typesubstkind constraints postitemattributes -> prPrec i 0 (concatD [doc (showString "type"), prt 0 ext, prt 0 attributes, prt 0 typeparameters, prt 0 lident, prt 0 typesubstkind, prt 0 constraints, prt 0 postitemattributes])

instance Print Ocaml.Abs.Constraint where
  prt i = \case
    Ocaml.Abs.Constraint constrain -> prPrec i 0 (concatD [doc (showString "constraint"), prt 0 constrain])

instance Print [Ocaml.Abs.Constraint] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.NonemptyTypeKind where
  prt i = \case
    Ocaml.Abs.AbstractType coretype -> prPrec i 0 (concatD [prt 0 coretype])
    Ocaml.Abs.VariantType constructordeclarations -> prPrec i 0 (concatD [prt 0 constructordeclarations])
    Ocaml.Abs.OpenType -> prPrec i 0 (concatD [doc (showString "..")])
    Ocaml.Abs.RecordType labeldeclarations -> prPrec i 0 (concatD [doc (showString "{"), prt 0 labeldeclarations, doc (showString "}")])
    Ocaml.Abs.PrivateAbstractType coretype -> prPrec i 0 (concatD [doc (showString "private"), prt 0 coretype])
    Ocaml.Abs.PrivateVariantType constructordeclarations -> prPrec i 0 (concatD [doc (showString "private"), prt 0 constructordeclarations])
    Ocaml.Abs.PrivateOpenType -> prPrec i 0 (concatD [doc (showString "private"), doc (showString "..")])
    Ocaml.Abs.PrivateRecordType labeldeclarations -> prPrec i 0 (concatD [doc (showString "private"), doc (showString "{"), prt 0 labeldeclarations, doc (showString "}")])
    Ocaml.Abs.TypeSynonymVariantType coretype constructordeclarations -> prPrec i 0 (concatD [prt 0 coretype, doc (showString "="), prt 0 constructordeclarations])
    Ocaml.Abs.TypeSynonymPrivateVariantType coretype constructordeclarations -> prPrec i 0 (concatD [prt 0 coretype, doc (showString "="), doc (showString "private"), prt 0 constructordeclarations])
    Ocaml.Abs.TypeSynonymOpenType coretype -> prPrec i 0 (concatD [prt 0 coretype, doc (showString "="), doc (showString "..")])
    Ocaml.Abs.TypeSynonymPrivateOpenType coretype -> prPrec i 0 (concatD [prt 0 coretype, doc (showString "="), doc (showString "private"), doc (showString "..")])
    Ocaml.Abs.TypeSynonymRecordType coretype labeldeclarations -> prPrec i 0 (concatD [prt 0 coretype, doc (showString "="), doc (showString "{"), prt 0 labeldeclarations, doc (showString "}")])
    Ocaml.Abs.TypeSynonymPrivateRecordType coretype labeldeclarations -> prPrec i 0 (concatD [prt 0 coretype, doc (showString "="), doc (showString "private"), doc (showString "{"), prt 0 labeldeclarations, doc (showString "}")])

instance Print Ocaml.Abs.TypeKind where
  prt i = \case
    Ocaml.Abs.NoTypeKind -> prPrec i 0 (concatD [])
    Ocaml.Abs.TypeKind nonemptytypekind -> prPrec i 0 (concatD [doc (showString "="), prt 0 nonemptytypekind])

instance Print Ocaml.Abs.TypeSubstKind where
  prt i = \case
    Ocaml.Abs.TypeSubstKind nonemptytypekind -> prPrec i 0 (concatD [doc (showString ":="), prt 0 nonemptytypekind])

instance Print Ocaml.Abs.TypeParameters where
  prt i = \case
    Ocaml.Abs.NoTypeParameters -> prPrec i 0 (concatD [])
    Ocaml.Abs.SingleTypeParameter typeparameter -> prPrec i 0 (concatD [prt 0 typeparameter])
    Ocaml.Abs.TypeParameters typeparameters -> prPrec i 0 (concatD [doc (showString "("), prt 0 typeparameters, doc (showString ")")])

instance Print [Ocaml.Abs.TypeParameter] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Ocaml.Abs.TypeParameter where
  prt i = \case
    Ocaml.Abs.TypeParameter typevariance typevariable -> prPrec i 0 (concatD [prt 0 typevariance, prt 0 typevariable])

instance Print Ocaml.Abs.TypeVariable where
  prt i = \case
    Ocaml.Abs.TypeVariable ocamlident -> prPrec i 0 (concatD [doc (showString "'"), prt 0 ocamlident])
    Ocaml.Abs.Underscore -> prPrec i 0 (concatD [doc (showString "_")])

instance Print Ocaml.Abs.TypeVariance where
  prt i = \case
    Ocaml.Abs.NoVarianceNoInjectivity -> prPrec i 0 (concatD [])
    Ocaml.Abs.CovariantNoInjectivity -> prPrec i 0 (concatD [doc (showString "+")])
    Ocaml.Abs.ContravariantNoInjectivity -> prPrec i 0 (concatD [doc (showString "-")])
    Ocaml.Abs.NoVarianceInjective -> prPrec i 0 (concatD [doc (showString "!")])
    Ocaml.Abs.CovariantInjective -> prPrec i 0 (concatD [doc (showString "+!")])
    Ocaml.Abs.InjectiveCovariant -> prPrec i 0 (concatD [doc (showString "!+")])
    Ocaml.Abs.ContravariantInjective -> prPrec i 0 (concatD [doc (showString "-!")])
    Ocaml.Abs.InjectiveContravariant -> prPrec i 0 (concatD [doc (showString "!-")])
    Ocaml.Abs.InfixOpVariance plusminusop -> prPrec i 0 (concatD [prt 0 plusminusop])
    Ocaml.Abs.PrefixOpVariance prefixop -> prPrec i 0 (concatD [prt 0 prefixop])

instance Print [Ocaml.Abs.ConstructorDeclaration] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "|"), prt 0 xs]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "|"), prt 0 xs]

instance Print Ocaml.Abs.ConstructorDeclarations where
  prt i = \case
    Ocaml.Abs.EmptyConstructorDeclarations -> prPrec i 0 (concatD [doc (showString "|")])
    Ocaml.Abs.BarConstructorDeclarations constructordeclarations -> prPrec i 0 (concatD [doc (showString "|"), prt 0 constructordeclarations])
    Ocaml.Abs.ConstructorDeclarations constructordeclarations -> prPrec i 0 (concatD [prt 0 constructordeclarations])

instance Print Ocaml.Abs.ConstructorDeclaration where
  prt i = \case
    Ocaml.Abs.ConstructorDeclaration constrident generalizedconstructorarguments attributes -> prPrec i 0 (concatD [prt 0 constrident, prt 0 generalizedconstructorarguments, prt 0 attributes])

instance Print Ocaml.Abs.StrExceptionDeclaration where
  prt i = \case
    Ocaml.Abs.SigStrExceptionDeclaration sigexceptiondeclaration -> prPrec i 0 (concatD [prt 0 sigexceptiondeclaration])
    Ocaml.Abs.Exception ext attributes1 constrident constrlongident attributes2 postitemattributes -> prPrec i 0 (concatD [doc (showString "exception"), prt 0 ext, prt 0 attributes1, prt 0 constrident, doc (showString "="), prt 0 constrlongident, prt 0 attributes2, prt 0 postitemattributes])

instance Print Ocaml.Abs.SigExceptionDeclaration where
  prt i = \case
    Ocaml.Abs.SigExceptionDeclaration ext attributes1 constrident generalizedconstructorarguments attributes2 postitemattributes -> prPrec i 0 (concatD [doc (showString "exception"), prt 0 ext, prt 0 attributes1, prt 0 constrident, prt 0 generalizedconstructorarguments, prt 0 attributes2, prt 0 postitemattributes])

instance Print Ocaml.Abs.LetExceptionDeclaration where
  prt i = \case
    Ocaml.Abs.LetExceptionDeclaration constrident generalizedconstructorarguments attributes -> prPrec i 0 (concatD [prt 0 constrident, prt 0 generalizedconstructorarguments, prt 0 attributes])

instance Print Ocaml.Abs.GeneralizedConstructorArguments where
  prt i = \case
    Ocaml.Abs.NoGeneralizedConstructorArguments -> prPrec i 0 (concatD [])
    Ocaml.Abs.GeneralizedConstructorArguments1 constructorarguments -> prPrec i 0 (concatD [doc (showString "of"), prt 0 constructorarguments])
    Ocaml.Abs.GeneralizedConstructorArguments2 constructorarguments atomictype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 constructorarguments, doc (showString "->"), prt 0 atomictype])
    Ocaml.Abs.GeneralizedConstructorArguments3 typevars constructorarguments atomictype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 typevars, doc (showString "."), prt 0 constructorarguments, doc (showString "->"), prt 0 atomictype])
    Ocaml.Abs.GeneralizedConstructorArguments4 atomictype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 atomictype])
    Ocaml.Abs.GeneralizedConstructorArguments5 typevars atomictype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 typevars, doc (showString "."), prt 0 atomictype])

instance Print Ocaml.Abs.ConstructorArguments where
  prt i = \case
    Ocaml.Abs.Arg1 atomictypes -> prPrec i 0 (concatD [prt 0 atomictypes])
    Ocaml.Abs.Arg2 labeldeclarations -> prPrec i 0 (concatD [doc (showString "{"), prt 0 labeldeclarations, doc (showString "}")])

instance Print Ocaml.Abs.LabelDeclarations where
  prt i = \case
    Ocaml.Abs.FinalLabelDeclaration labeldeclaration -> prPrec i 0 (concatD [prt 0 labeldeclaration])
    Ocaml.Abs.FinalLabelDeclarationSemi labeldeclarationsemi -> prPrec i 0 (concatD [prt 0 labeldeclarationsemi])
    Ocaml.Abs.MoreLabelDeclarations labeldeclarationsemi labeldeclarations -> prPrec i 0 (concatD [prt 0 labeldeclarationsemi, prt 0 labeldeclarations])

instance Print Ocaml.Abs.LabelDeclaration where
  prt i = \case
    Ocaml.Abs.LabelDeclarationMonoType mutableflag lident aliastype attributes -> prPrec i 0 (concatD [prt 0 mutableflag, prt 0 lident, doc (showString ":"), prt 0 aliastype, prt 0 attributes])
    Ocaml.Abs.LabelDeclarationPolyType mutableflag lident typevars aliastype attributes -> prPrec i 0 (concatD [prt 0 mutableflag, prt 0 lident, doc (showString ":"), prt 0 typevars, doc (showString "."), prt 0 aliastype, prt 0 attributes])

instance Print Ocaml.Abs.LabelDeclarationSemi where
  prt i = \case
    Ocaml.Abs.LabelDeclarationSemiMonoType mutableflag lident aliastype attributes1 attributes2 -> prPrec i 0 (concatD [prt 0 mutableflag, prt 0 lident, doc (showString ":"), prt 0 aliastype, prt 0 attributes1, doc (showString ";"), prt 0 attributes2])
    Ocaml.Abs.LabelDeclarationSemiPolyType mutableflag lident typevars aliastype attributes1 attributes2 -> prPrec i 0 (concatD [prt 0 mutableflag, prt 0 lident, doc (showString ":"), prt 0 typevars, doc (showString "."), prt 0 aliastype, prt 0 attributes1, doc (showString ";"), prt 0 attributes2])

instance Print Ocaml.Abs.StrTypeExtension where
  prt i = \case
    Ocaml.Abs.StrTypeExtension ext attributes typeparameters typelongident privateflag barllistextensionconstructor postitemattributes -> prPrec i 0 (concatD [doc (showString "type"), prt 0 ext, prt 0 attributes, prt 0 typeparameters, prt 0 typelongident, doc (showString "+="), prt 0 privateflag, prt 0 barllistextensionconstructor, prt 0 postitemattributes])

instance Print Ocaml.Abs.BarLlistExtensionConstructor where
  prt i = \case
    Ocaml.Abs.NoExtensionConstructors -> prPrec i 0 (concatD [doc (showString "|")])
    Ocaml.Abs.BarExtensionConstructors extensionconstructors -> prPrec i 0 (concatD [doc (showString "|"), prt 0 extensionconstructors])
    Ocaml.Abs.ExtensionConstructors extensionconstructors -> prPrec i 0 (concatD [prt 0 extensionconstructors])

instance Print [Ocaml.Abs.ExtensionConstructor] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "|"), prt 0 xs]

instance Print Ocaml.Abs.SigTypeExtension where
  prt i = \case
    Ocaml.Abs.SigTypeExtension ext attributes typeparameters typelongident privateflag barllistextensionconstructordeclaration postitemattributes -> prPrec i 0 (concatD [doc (showString "type"), prt 0 ext, prt 0 attributes, prt 0 typeparameters, prt 0 typelongident, doc (showString "+="), prt 0 privateflag, prt 0 barllistextensionconstructordeclaration, prt 0 postitemattributes])

instance Print Ocaml.Abs.BarLlistExtensionConstructorDeclaration where
  prt i = \case
    Ocaml.Abs.NoConstructor -> prPrec i 0 (concatD [doc (showString "|")])
    Ocaml.Abs.Constructor extensionconstructordeclarations -> prPrec i 0 (concatD [doc (showString "|"), prt 0 extensionconstructordeclarations])

instance Print [Ocaml.Abs.ExtensionConstructorDeclaration] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "|"), prt 0 xs]

instance Print Ocaml.Abs.ExtensionConstructor where
  prt i = \case
    Ocaml.Abs.Declaration extensionconstructordeclaration -> prPrec i 0 (concatD [prt 0 extensionconstructordeclaration])
    Ocaml.Abs.Rebind extensionconstructorrebind -> prPrec i 0 (concatD [prt 0 extensionconstructorrebind])

instance Print Ocaml.Abs.ExtensionConstructorDeclaration where
  prt i = \case
    Ocaml.Abs.ExtensionConstructorDeclaration constrident generalizedconstructorarguments attributes -> prPrec i 0 (concatD [prt 0 constrident, prt 0 generalizedconstructorarguments, prt 0 attributes])

instance Print Ocaml.Abs.ExtensionConstructorRebind where
  prt i = \case
    Ocaml.Abs.ExtensionConstructorRebind constrident constrlongident attributes -> prPrec i 0 (concatD [prt 0 constrident, doc (showString "="), prt 0 constrlongident, prt 0 attributes])

instance Print Ocaml.Abs.WithConstraint where
  prt i = \case
    Ocaml.Abs.WithConstraint1 typeparameters labellongident withtypebinder aliastype constraints -> prPrec i 0 (concatD [doc (showString "type"), prt 0 typeparameters, prt 0 labellongident, prt 0 withtypebinder, prt 0 aliastype, prt 0 constraints])
    Ocaml.Abs.WithConstraint2 typeparameters labellongident aliastype -> prPrec i 0 (concatD [doc (showString "type"), prt 0 typeparameters, prt 0 labellongident, doc (showString ":="), prt 0 aliastype])
    Ocaml.Abs.WithConstraint3 modlongident modextlongident -> prPrec i 0 (concatD [doc (showString "module"), prt 0 modlongident, doc (showString "="), prt 0 modextlongident])
    Ocaml.Abs.WithConstraint4 modlongident modextlongident -> prPrec i 0 (concatD [doc (showString "module"), prt 0 modlongident, doc (showString ":="), prt 0 modextlongident])
    Ocaml.Abs.WithConstraint5 mtylongident moduletype -> prPrec i 0 (concatD [doc (showString "module"), doc (showString "type"), prt 0 mtylongident, doc (showString "="), prt 0 moduletype])
    Ocaml.Abs.WithConstraint6 mtylongident moduletype -> prPrec i 0 (concatD [doc (showString "module"), doc (showString "type"), prt 0 mtylongident, doc (showString ":="), prt 0 moduletype])

instance Print Ocaml.Abs.WithTypeBinder where
  prt i = \case
    Ocaml.Abs.WithTypeBinderEqual -> prPrec i 0 (concatD [doc (showString "=")])
    Ocaml.Abs.WithTypeBinderEqualPrivate -> prPrec i 0 (concatD [doc (showString "="), doc (showString "private")])

instance Print Ocaml.Abs.TypeVar where
  prt i = \case
    Ocaml.Abs.TypeVarIdent ocamlident -> prPrec i 0 (concatD [doc (showString "'"), prt 0 ocamlident])

instance Print [Ocaml.Abs.TypeVar] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.PolyType where
  prt i = \case
    Ocaml.Abs.MonoCoreType coretype -> prPrec i 0 (concatD [prt 0 coretype])
    Ocaml.Abs.PolyCoreType typevars coretype -> prPrec i 0 (concatD [prt 0 typevars, doc (showString "."), prt 0 coretype])

instance Print Ocaml.Abs.CoreType where
  prt i = \case
    Ocaml.Abs.CoreTypeWithoutAttribute aliastype -> prPrec i 0 (concatD [prt 0 aliastype])
    Ocaml.Abs.CoreTypeWithAttribute coretype attribute -> prPrec i 0 (concatD [prt 0 coretype, prt 0 attribute])

instance Print [Ocaml.Abs.CoreType] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Ocaml.Abs.AliasType where
  prt i = \case
    Ocaml.Abs.FunctionType functiontype -> prPrec i 0 (concatD [prt 0 functiontype])
    Ocaml.Abs.AliasType aliastype typevar -> prPrec i 0 (concatD [prt 0 aliastype, doc (showString "as"), prt 0 typevar])

instance Print Ocaml.Abs.FunctionType where
  prt i = \case
    Ocaml.Abs.TupleType tupletype -> prPrec i 0 (concatD [prt 0 tupletype])
    Ocaml.Abs.FunTypeWithOptLabel optlabel tupletype functiontype -> prPrec i 0 (concatD [prt 0 optlabel, prt 0 tupletype, doc (showString "->"), prt 0 functiontype])
    Ocaml.Abs.FunTypeWithOptionalLabel lident tupletype functiontype -> prPrec i 0 (concatD [doc (showString "?"), prt 0 lident, doc (showString ":"), prt 0 tupletype, doc (showString "->"), prt 0 functiontype])
    Ocaml.Abs.FunTypeWithtLabel lident tupletype functiontype -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 tupletype, doc (showString "->"), prt 0 functiontype])
    Ocaml.Abs.FunTypeWithoutLabel tupletype functiontype -> prPrec i 0 (concatD [prt 0 tupletype, doc (showString "->"), prt 0 functiontype])

instance Print Ocaml.Abs.TupleType where
  prt i = \case
    Ocaml.Abs.AtomicType atomictype -> prPrec i 0 (concatD [prt 0 atomictype])
    Ocaml.Abs.AtomicTypes atomictype atomictypes -> prPrec i 0 (concatD [prt 0 atomictype, doc (showString "*"), prt 0 atomictypes])

instance Print [Ocaml.Abs.AtomicType] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "*"), prt 0 xs]

instance Print Ocaml.Abs.OptionalBar where
  prt i = \case
    Ocaml.Abs.NoBar -> prPrec i 0 (concatD [])
    Ocaml.Abs.ABar -> prPrec i 0 (concatD [doc (showString "|")])

instance Print Ocaml.Abs.DelimitedTypeSupportingLocalOpen where
  prt i = \case
    Ocaml.Abs.LocalOpen1 coretype -> prPrec i 0 (concatD [doc (showString "("), prt 0 coretype, doc (showString ")")])
    Ocaml.Abs.LocalOpen2 ext attributes packagetype -> prPrec i 0 (concatD [doc (showString "("), doc (showString "module"), prt 0 ext, prt 0 attributes, prt 0 packagetype, doc (showString ")")])
    Ocaml.Abs.LocalOpen3 tagfield -> prPrec i 0 (concatD [doc (showString "["), prt 0 tagfield, doc (showString "]")])
    Ocaml.Abs.LocalOpen4 rowfields -> prPrec i 0 (concatD [doc (showString "["), doc (showString "|"), prt 0 rowfields, doc (showString "]")])
    Ocaml.Abs.LocalOpen5 rowfield rowfields -> prPrec i 0 (concatD [doc (showString "["), prt 0 rowfield, doc (showString "|"), prt 0 rowfields, doc (showString "]")])
    Ocaml.Abs.LocalOpen6 optionalbar rowfields -> prPrec i 0 (concatD [doc (showString "[>"), prt 0 optionalbar, prt 0 rowfields, doc (showString "]")])
    Ocaml.Abs.LocalOpen7 -> prPrec i 0 (concatD [doc (showString "[>"), doc (showString "]")])
    Ocaml.Abs.LocalOpen8 optionalbar rowfields -> prPrec i 0 (concatD [doc (showString "[<"), prt 0 optionalbar, prt 0 rowfields, doc (showString "]")])
    Ocaml.Abs.LocalOpen9 optionalbar rowfields nametags -> prPrec i 0 (concatD [doc (showString "[<"), prt 0 optionalbar, prt 0 rowfields, doc (showString ">"), prt 0 nametags, doc (showString "]")])

instance Print Ocaml.Abs.ObjectType where
  prt i = \case
    Ocaml.Abs.MethList methlist -> prPrec i 0 (concatD [doc (showString "<"), prt 0 methlist, doc (showString ">")])
    Ocaml.Abs.Empty -> prPrec i 0 (concatD [doc (showString "<"), doc (showString ">")])

instance Print Ocaml.Abs.DelimitedType where
  prt i = \case
    Ocaml.Abs.ObjectType objecttype -> prPrec i 0 (concatD [prt 0 objecttype])
    Ocaml.Abs.DelimitedTypeExtension extension -> prPrec i 0 (concatD [prt 0 extension])
    Ocaml.Abs.DelimitedTypeSupportingLocalOpen delimitedtypesupportinglocalopen -> prPrec i 0 (concatD [prt 0 delimitedtypesupportinglocalopen])

instance Print Ocaml.Abs.AtomicType where
  prt i = \case
    Ocaml.Abs.DelimitedType delimitedtype -> prPrec i 0 (concatD [prt 0 delimitedtype])
    Ocaml.Abs.TypeConstr typelongident -> prPrec i 0 (concatD [prt 0 typelongident])
    Ocaml.Abs.SimpleTypeApp atomictype typelongident -> prPrec i 0 (concatD [prt 0 atomictype, prt 0 typelongident])
    Ocaml.Abs.ComplexTypeApp coretype coretypes typelongident -> prPrec i 0 (concatD [doc (showString "("), prt 0 coretype, doc (showString ","), prt 0 coretypes, doc (showString ")"), prt 0 typelongident])
    Ocaml.Abs.ClassTypeConstr cltylongident -> prPrec i 0 (concatD [doc (showString "#"), prt 0 cltylongident])
    Ocaml.Abs.SimpleSubTypeApp atomictype cltylongident -> prPrec i 0 (concatD [prt 0 atomictype, doc (showString "#"), prt 0 cltylongident])
    Ocaml.Abs.ComplexSubTypeApp coretype coretypes cltylongident -> prPrec i 0 (concatD [doc (showString "("), prt 0 coretype, doc (showString ","), prt 0 coretypes, doc (showString ")"), doc (showString "#"), prt 0 cltylongident])
    Ocaml.Abs.QualifiedDelimitedType modextlongident delimitedtypesupportinglocalopen -> prPrec i 0 (concatD [prt 0 modextlongident, doc (showString "."), prt 0 delimitedtypesupportinglocalopen])
    Ocaml.Abs.TypeVar ocamlident -> prPrec i 0 (concatD [doc (showString "'"), prt 0 ocamlident])
    Ocaml.Abs.UnderscoreType -> prPrec i 0 (concatD [doc (showString "_")])

instance Print Ocaml.Abs.PackageType where
  prt i = \case
    Ocaml.Abs.PackageType moduletype -> prPrec i 0 (concatD [prt 0 moduletype])

instance Print [Ocaml.Abs.RowField] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "|"), prt 0 xs]

instance Print Ocaml.Abs.RowField where
  prt i = \case
    Ocaml.Abs.TagField tagfield -> prPrec i 0 (concatD [prt 0 tagfield])
    Ocaml.Abs.CoreType coretype -> prPrec i 0 (concatD [prt 0 coretype])

instance Print Ocaml.Abs.TagField where
  prt i = \case
    Ocaml.Abs.Of nametag optampersand aliastypes attributes -> prPrec i 0 (concatD [prt 0 nametag, doc (showString "of"), prt 0 optampersand, prt 0 aliastypes, prt 0 attributes])
    Ocaml.Abs.Tag nametag attributes -> prPrec i 0 (concatD [prt 0 nametag, prt 0 attributes])

instance Print Ocaml.Abs.OptAmpersand where
  prt i = \case
    Ocaml.Abs.Ampersand -> prPrec i 0 (concatD [doc (showString "&")])
    Ocaml.Abs.NoAmpersand -> prPrec i 0 (concatD [])

instance Print [Ocaml.Abs.AliasType] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "&"), prt 0 xs]

instance Print [Ocaml.Abs.NameTag] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.MethList where
  prt i = \case
    Ocaml.Abs.FieldSemiMethListMonoType lident aliastype attributes1 attributes2 methlist -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 aliastype, prt 0 attributes1, doc (showString ";"), prt 0 attributes2, prt 0 methlist])
    Ocaml.Abs.FieldSemiMethListPolyType lident typevars aliastype attributes1 attributes2 methlist -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 typevars, doc (showString "."), prt 0 aliastype, prt 0 attributes1, doc (showString ";"), prt 0 attributes2, prt 0 methlist])
    Ocaml.Abs.InheritSemiMethList atomictype methlist -> prPrec i 0 (concatD [prt 0 atomictype, doc (showString ";"), prt 0 methlist])
    Ocaml.Abs.FieldSemiMonoType lident aliastype attributes -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 aliastype, prt 0 attributes, doc (showString ";")])
    Ocaml.Abs.FieldSemiPolyType lident typevars aliastype attributes -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 typevars, doc (showString "."), prt 0 aliastype, prt 0 attributes, doc (showString ";")])
    Ocaml.Abs.InheritSemi atomictype -> prPrec i 0 (concatD [prt 0 atomictype, doc (showString ";")])
    Ocaml.Abs.FieldMonoType lident aliastype attributes -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 aliastype, prt 0 attributes])
    Ocaml.Abs.FieldPolyType lident typevars aliastype attributes -> prPrec i 0 (concatD [prt 0 lident, doc (showString ":"), prt 0 typevars, doc (showString "."), prt 0 aliastype, prt 0 attributes])
    Ocaml.Abs.Inherit atomictype -> prPrec i 0 (concatD [prt 0 atomictype])
    Ocaml.Abs.DotDot -> prPrec i 0 (concatD [doc (showString "..")])

instance Print Ocaml.Abs.Constant where
  prt i = \case
    Ocaml.Abs.Int int -> prPrec i 0 (concatD [prt 0 int])
    Ocaml.Abs.Char char -> prPrec i 0 (concatD [prt 0 char])
    Ocaml.Abs.String string -> prPrec i 0 (concatD [prt 0 string])
    Ocaml.Abs.Float float -> prPrec i 0 (concatD [prt 0 float])

instance Print Ocaml.Abs.SignedConstant where
  prt i = \case
    Ocaml.Abs.Constant constant -> prPrec i 0 (concatD [prt 0 constant])
    Ocaml.Abs.NegInt int -> prPrec i 0 (concatD [doc (showString "-"), prt 0 int])
    Ocaml.Abs.NegFloat float -> prPrec i 0 (concatD [doc (showString "-"), prt 0 float])
    Ocaml.Abs.PosInt int -> prPrec i 0 (concatD [doc (showString "+"), prt 0 int])
    Ocaml.Abs.PosFloat float -> prPrec i 0 (concatD [doc (showString "+"), prt 0 float])

instance Print Ocaml.Abs.OCamlIdent where
  prt i = \case
    Ocaml.Abs.Uppercase uident -> prPrec i 0 (concatD [prt 0 uident])
    Ocaml.Abs.Lowercase lident -> prPrec i 0 (concatD [prt 0 lident])

instance Print Ocaml.Abs.ValExtraIdent where
  prt i = \case
    Ocaml.Abs.Operator operator -> prPrec i 0 (concatD [doc (showString "("), prt 0 operator, doc (showString ")")])

instance Print Ocaml.Abs.ValIdent where
  prt i = \case
    Ocaml.Abs.LowercaseValIdent lident -> prPrec i 0 (concatD [prt 0 lident])
    Ocaml.Abs.ValExtraIdent valextraident -> prPrec i 0 (concatD [prt 0 valextraident])

instance Print Ocaml.Abs.Operator where
  prt i = \case
    Ocaml.Abs.PrefixOp prefixop -> prPrec i 0 (concatD [prt 0 prefixop])
    Ocaml.Abs.LetOp letop -> prPrec i 0 (concatD [prt 0 letop])
    Ocaml.Abs.AndOp andop -> prPrec i 0 (concatD [prt 0 andop])
    Ocaml.Abs.ArrayAccessOp dotop indexmod -> prPrec i 0 (concatD [prt 0 dotop, doc (showString "("), prt 0 indexmod, doc (showString ")")])
    Ocaml.Abs.ArrayUpdateOp dotop indexmod -> prPrec i 0 (concatD [prt 0 dotop, doc (showString "("), prt 0 indexmod, doc (showString ")"), doc (showString "<-")])
    Ocaml.Abs.StringAccessOp dotop indexmod -> prPrec i 0 (concatD [prt 0 dotop, doc (showString "["), prt 0 indexmod, doc (showString "]")])
    Ocaml.Abs.StringUpdateOp dotop indexmod -> prPrec i 0 (concatD [prt 0 dotop, doc (showString "["), prt 0 indexmod, doc (showString "]"), doc (showString "<-")])
    Ocaml.Abs.RecordAccessOp dotop indexmod -> prPrec i 0 (concatD [prt 0 dotop, doc (showString "{"), prt 0 indexmod, doc (showString "}")])
    Ocaml.Abs.RecordUpdateOp dotop indexmod -> prPrec i 0 (concatD [prt 0 dotop, doc (showString "{"), prt 0 indexmod, doc (showString "}"), doc (showString "<-")])
    Ocaml.Abs.HashSymbolOp hashop -> prPrec i 0 (concatD [prt 0 hashop])
    Ocaml.Abs.BangOp -> prPrec i 0 (concatD [doc (showString "!")])
    Ocaml.Abs.InfixOp infixoperator -> prPrec i 0 (concatD [prt 0 infixoperator])

instance Print Ocaml.Abs.InfixOperator where
  prt i = \case
    Ocaml.Abs.RelOp relop -> prPrec i 0 (concatD [prt 0 relop])
    Ocaml.Abs.InfixEqual -> prPrec i 0 (concatD [doc (showString "=")])
    Ocaml.Abs.InfixLess -> prPrec i 0 (concatD [doc (showString "<")])
    Ocaml.Abs.InfixGreater -> prPrec i 0 (concatD [doc (showString ">")])
    Ocaml.Abs.InfixBarBar -> prPrec i 0 (concatD [doc (showString "||")])
    Ocaml.Abs.InfixAmpersand -> prPrec i 0 (concatD [doc (showString "&")])
    Ocaml.Abs.InfixAmpersandAmpersand -> prPrec i 0 (concatD [doc (showString "&&")])
    Ocaml.Abs.ConcatOp concatop -> prPrec i 0 (concatD [prt 0 concatop])
    Ocaml.Abs.PlusMinusOp plusminusop -> prPrec i 0 (concatD [prt 0 plusminusop])
    Ocaml.Abs.InfixPlus -> prPrec i 0 (concatD [doc (showString "+")])
    Ocaml.Abs.InfixMinus -> prPrec i 0 (concatD [doc (showString "-")])
    Ocaml.Abs.MultDivOp multdivop -> prPrec i 0 (concatD [prt 0 multdivop])
    Ocaml.Abs.InfixStar -> prPrec i 0 (concatD [doc (showString "*")])
    Ocaml.Abs.InfixSlash -> prPrec i 0 (concatD [doc (showString "/")])
    Ocaml.Abs.InfixPercent -> prPrec i 0 (concatD [doc (showString "%")])
    Ocaml.Abs.PowOp powop -> prPrec i 0 (concatD [prt 0 powop])
    Ocaml.Abs.InfixOr -> prPrec i 0 (concatD [doc (showString "or")])
    Ocaml.Abs.InfixColonEqual -> prPrec i 0 (concatD [doc (showString ":=")])

instance Print Ocaml.Abs.IndexMod where
  prt i = \case
    Ocaml.Abs.NoIndexMod -> prPrec i 0 (concatD [])
    Ocaml.Abs.SemiDotDot -> prPrec i 0 (concatD [doc (showString ";"), doc (showString "..")])

instance Print Ocaml.Abs.ConstrExtraIdent where
  prt i = \case
    Ocaml.Abs.ConstrIdent -> prPrec i 0 (concatD [doc (showString "("), doc (showString "::"), doc (showString ")")])

instance Print Ocaml.Abs.ConstrExtraNonprefixIdent where
  prt i = \case
    Ocaml.Abs.Brackets -> prPrec i 0 (concatD [doc (showString "["), doc (showString "]")])
    Ocaml.Abs.Parens -> prPrec i 0 (concatD [doc (showString "("), doc (showString ")")])
    Ocaml.Abs.FalseLiteral -> prPrec i 0 (concatD [doc (showString "false")])
    Ocaml.Abs.TrueLiteral -> prPrec i 0 (concatD [doc (showString "true")])

instance Print Ocaml.Abs.ConstrIdent where
  prt i = \case
    Ocaml.Abs.ConstrUppercaseIdent uident -> prPrec i 0 (concatD [prt 0 uident])
    Ocaml.Abs.ConstrExtraIdent constrextraident -> prPrec i 0 (concatD [prt 0 constrextraident])
    Ocaml.Abs.ConstrExpraNonprefixIdent constrextranonprefixident -> prPrec i 0 (concatD [prt 0 constrextranonprefixident])

instance Print Ocaml.Abs.ConstrLongident where
  prt i = \case
    Ocaml.Abs.ModLongidentTodo modlongident -> prPrec i 0 (concatD [prt 0 modlongident])
    Ocaml.Abs.QualifiedConstrExtraLongident modlongident constrextraident -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), prt 0 constrextraident])
    Ocaml.Abs.ConstrExtraLongdent constrextraident -> prPrec i 0 (concatD [prt 0 constrextraident])
    Ocaml.Abs.ConstrExtraNonprefixLonident constrextranonprefixident -> prPrec i 0 (concatD [prt 0 constrextranonprefixident])

instance Print Ocaml.Abs.ValLongident where
  prt i = \case
    Ocaml.Abs.ValLongident valident -> prPrec i 0 (concatD [prt 0 valident])
    Ocaml.Abs.QualifiedValLongident modlongident valident -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), prt 0 valident])

instance Print Ocaml.Abs.LabelLongident where
  prt i = \case
    Ocaml.Abs.LabelLongident lident -> prPrec i 0 (concatD [prt 0 lident])
    Ocaml.Abs.QualifiedLabelLongident modlongident lident -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), prt 0 lident])

instance Print Ocaml.Abs.TypeLongident where
  prt i = \case
    Ocaml.Abs.TypeLongident lident -> prPrec i 0 (concatD [prt 0 lident])
    Ocaml.Abs.QualifiedTypelLongident modextlongident lident -> prPrec i 0 (concatD [prt 0 modextlongident, doc (showString "."), prt 0 lident])

instance Print Ocaml.Abs.ModLongident where
  prt i = \case
    Ocaml.Abs.ModLongident uident -> prPrec i 0 (concatD [prt 0 uident])
    Ocaml.Abs.QualifiedModLongident modlongident uident -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), prt 0 uident])

instance Print Ocaml.Abs.ModExtLongident where
  prt i = \case
    Ocaml.Abs.ModExtLongident uident -> prPrec i 0 (concatD [prt 0 uident])
    Ocaml.Abs.QualifiedModExtLongident modextlongident uident -> prPrec i 0 (concatD [prt 0 modextlongident, doc (showString "."), prt 0 uident])
    Ocaml.Abs.ParenModExtLongident modextlongident1 modextlongident2 -> prPrec i 0 (concatD [prt 0 modextlongident1, doc (showString "("), prt 0 modextlongident2, doc (showString ")")])

instance Print Ocaml.Abs.MtyLongident where
  prt i = \case
    Ocaml.Abs.MtyLongident ocamlident -> prPrec i 0 (concatD [prt 0 ocamlident])
    Ocaml.Abs.QualifiedMtyLongident modextlongident ocamlident -> prPrec i 0 (concatD [prt 0 modextlongident, doc (showString "."), prt 0 ocamlident])

instance Print Ocaml.Abs.CltyLongident where
  prt i = \case
    Ocaml.Abs.CltyLongident lident -> prPrec i 0 (concatD [prt 0 lident])
    Ocaml.Abs.QualifiedCltyLongident modextlongident lident -> prPrec i 0 (concatD [prt 0 modextlongident, doc (showString "."), prt 0 lident])

instance Print Ocaml.Abs.ClassLongident where
  prt i = \case
    Ocaml.Abs.ClassLongident lident -> prPrec i 0 (concatD [prt 0 lident])
    Ocaml.Abs.QualifiedClassLongident modlongident lident -> prPrec i 0 (concatD [prt 0 modlongident, doc (showString "."), prt 0 lident])

instance Print Ocaml.Abs.OptionalToplevelDirectiveArgument where
  prt i = \case
    Ocaml.Abs.NoToplevelDirectiveArgument -> prPrec i 0 (concatD [])
    Ocaml.Abs.AToplevelDirectiveArgument topleveldirectiveargument -> prPrec i 0 (concatD [prt 0 topleveldirectiveargument])

instance Print Ocaml.Abs.ToplevelDirective where
  prt i = \case
    Ocaml.Abs.ToplevelDirectiveApp ocamlident topleveldirectiveargument -> prPrec i 0 (concatD [doc (showString "#"), prt 0 ocamlident, prt 0 topleveldirectiveargument])

instance Print Ocaml.Abs.ToplevelDirectiveArgument where
  prt i = \case
    Ocaml.Abs.ToplevelString string -> prPrec i 0 (concatD [prt 0 string])
    Ocaml.Abs.ToplevelInt int -> prPrec i 0 (concatD [prt 0 int])
    Ocaml.Abs.ValueIdent vallongident -> prPrec i 0 (concatD [prt 0 vallongident])
    Ocaml.Abs.ToplevelModuleIdent modlongident -> prPrec i 0 (concatD [prt 0 modlongident])
    Ocaml.Abs.ToplevelFalse -> prPrec i 0 (concatD [doc (showString "false")])
    Ocaml.Abs.ToplevelTrue -> prPrec i 0 (concatD [doc (showString "true")])

instance Print Ocaml.Abs.NameTag where
  prt i = \case
    Ocaml.Abs.NameTag ocamlident -> prPrec i 0 (concatD [doc (showString "`"), prt 0 ocamlident])

instance Print Ocaml.Abs.RecFlag where
  prt i = \case
    Ocaml.Abs.Nonrecursive -> prPrec i 0 (concatD [])
    Ocaml.Abs.Recursive -> prPrec i 0 (concatD [doc (showString "rec")])

instance Print Ocaml.Abs.DirectionFlag where
  prt i = \case
    Ocaml.Abs.UpTo -> prPrec i 0 (concatD [doc (showString "to")])
    Ocaml.Abs.DownTo -> prPrec i 0 (concatD [doc (showString "downto")])

instance Print Ocaml.Abs.PrivateFlag where
  prt i = \case
    Ocaml.Abs.Public -> prPrec i 0 (concatD [])
    Ocaml.Abs.Private -> prPrec i 0 (concatD [doc (showString "private")])

instance Print Ocaml.Abs.MutableFlag where
  prt i = \case
    Ocaml.Abs.Immutable -> prPrec i 0 (concatD [])
    Ocaml.Abs.Mutable -> prPrec i 0 (concatD [doc (showString "mutable")])

instance Print Ocaml.Abs.VirtualFlag where
  prt i = \case
    Ocaml.Abs.Concrete -> prPrec i 0 (concatD [])
    Ocaml.Abs.Virtual -> prPrec i 0 (concatD [doc (showString "virtual")])

instance Print Ocaml.Abs.MutableVirtualFlags where
  prt i = \case
    Ocaml.Abs.ImmutableContrete -> prPrec i 0 (concatD [])
    Ocaml.Abs.MutableConcrete -> prPrec i 0 (concatD [doc (showString "mutable")])
    Ocaml.Abs.ImmutableVirtual -> prPrec i 0 (concatD [doc (showString "virtual")])
    Ocaml.Abs.MutableVirtual -> prPrec i 0 (concatD [doc (showString "mutable"), doc (showString "virtual")])
    Ocaml.Abs.VirtualMutable -> prPrec i 0 (concatD [doc (showString "virtual"), doc (showString "mutable")])

instance Print Ocaml.Abs.PrivateVirtualFlags where
  prt i = \case
    Ocaml.Abs.PublicConcrete -> prPrec i 0 (concatD [])
    Ocaml.Abs.PrivateConcrete -> prPrec i 0 (concatD [doc (showString "private")])
    Ocaml.Abs.PublicVirtual -> prPrec i 0 (concatD [doc (showString "virtual")])
    Ocaml.Abs.PrivateVirtual -> prPrec i 0 (concatD [doc (showString "private"), doc (showString "virtual")])
    Ocaml.Abs.VirtualPrivate -> prPrec i 0 (concatD [doc (showString "virtual"), doc (showString "private")])

instance Print Ocaml.Abs.VirtualWithMutableFlag where
  prt i = \case
    Ocaml.Abs.VirtualWithImmutable -> prPrec i 0 (concatD [doc (showString "virtual")])
    Ocaml.Abs.MutableWithVirtual -> prPrec i 0 (concatD [doc (showString "mutable"), doc (showString "virtual")])
    Ocaml.Abs.VirtualWithMutable -> prPrec i 0 (concatD [doc (showString "virtual"), doc (showString "mutable")])

instance Print Ocaml.Abs.VirtualWithPrivateFlag where
  prt i = \case
    Ocaml.Abs.VirtualWithPublic -> prPrec i 0 (concatD [doc (showString "virtual")])
    Ocaml.Abs.PrivateWithVirtual -> prPrec i 0 (concatD [doc (showString "private"), doc (showString "virtual")])
    Ocaml.Abs.VirtualWithPrivate -> prPrec i 0 (concatD [doc (showString "virtual"), doc (showString "private")])

instance Print Ocaml.Abs.NoOverrideFlag where
  prt i = \case
    Ocaml.Abs.NoFlag -> prPrec i 0 (concatD [])

instance Print Ocaml.Abs.OverrideFlag where
  prt i = \case
    Ocaml.Abs.Fresh -> prPrec i 0 (concatD [])
    Ocaml.Abs.Override -> prPrec i 0 (concatD [doc (showString "!")])

instance Print Ocaml.Abs.Subtractive where
  prt i = \case
    Ocaml.Abs.Minus -> prPrec i 0 (concatD [doc (showString "-")])
    Ocaml.Abs.MinusDot -> prPrec i 0 (concatD [doc (showString "-.")])

instance Print Ocaml.Abs.Additive where
  prt i = \case
    Ocaml.Abs.Plus -> prPrec i 0 (concatD [doc (showString "+")])
    Ocaml.Abs.PlusDot -> prPrec i 0 (concatD [doc (showString "+.")])

instance Print Ocaml.Abs.AttrId where
  prt i = \case
    Ocaml.Abs.LowercaseAttr lident -> prPrec i 0 (concatD [prt 0 lident])
    Ocaml.Abs.UppercaseAttr uident -> prPrec i 0 (concatD [prt 0 uident])
    Ocaml.Abs.AndAttr -> prPrec i 0 (concatD [doc (showString "and")])
    Ocaml.Abs.AsAttr -> prPrec i 0 (concatD [doc (showString "as")])
    Ocaml.Abs.AssertAttr -> prPrec i 0 (concatD [doc (showString "assert")])
    Ocaml.Abs.BeginAttr -> prPrec i 0 (concatD [doc (showString "begin")])
    Ocaml.Abs.ClassAttr -> prPrec i 0 (concatD [doc (showString "class")])
    Ocaml.Abs.ConstraintAttr -> prPrec i 0 (concatD [doc (showString "constraint")])
    Ocaml.Abs.DoAttr -> prPrec i 0 (concatD [doc (showString "do")])
    Ocaml.Abs.DoneAttr -> prPrec i 0 (concatD [doc (showString "done")])
    Ocaml.Abs.DowntoAttr -> prPrec i 0 (concatD [doc (showString "downto")])
    Ocaml.Abs.ElseAttr -> prPrec i 0 (concatD [doc (showString "else")])
    Ocaml.Abs.EndAttr -> prPrec i 0 (concatD [doc (showString "end")])
    Ocaml.Abs.ExceptionAttr -> prPrec i 0 (concatD [doc (showString "exception")])
    Ocaml.Abs.ExternalAttr -> prPrec i 0 (concatD [doc (showString "external")])
    Ocaml.Abs.FalseAttr -> prPrec i 0 (concatD [doc (showString "false")])
    Ocaml.Abs.ForAttr -> prPrec i 0 (concatD [doc (showString "for")])
    Ocaml.Abs.FunAttr -> prPrec i 0 (concatD [doc (showString "fun")])
    Ocaml.Abs.FunctionAttr -> prPrec i 0 (concatD [doc (showString "function")])
    Ocaml.Abs.FunctorAttr -> prPrec i 0 (concatD [doc (showString "functor")])
    Ocaml.Abs.IfAttr -> prPrec i 0 (concatD [doc (showString "if")])
    Ocaml.Abs.InAttr -> prPrec i 0 (concatD [doc (showString "in")])
    Ocaml.Abs.IncludeAttr -> prPrec i 0 (concatD [doc (showString "include")])
    Ocaml.Abs.InheritAttr -> prPrec i 0 (concatD [doc (showString "inherit")])
    Ocaml.Abs.InitializerAttr -> prPrec i 0 (concatD [doc (showString "initializer")])
    Ocaml.Abs.LazyAttr -> prPrec i 0 (concatD [doc (showString "lazy")])
    Ocaml.Abs.LetAttr -> prPrec i 0 (concatD [doc (showString "let")])
    Ocaml.Abs.MatchAttr -> prPrec i 0 (concatD [doc (showString "match")])
    Ocaml.Abs.MethodAttr -> prPrec i 0 (concatD [doc (showString "method")])
    Ocaml.Abs.ModuleAttr -> prPrec i 0 (concatD [doc (showString "module")])
    Ocaml.Abs.MutableAttr -> prPrec i 0 (concatD [doc (showString "mutable")])
    Ocaml.Abs.NewAttr -> prPrec i 0 (concatD [doc (showString "new")])
    Ocaml.Abs.NonrecAttr -> prPrec i 0 (concatD [doc (showString "nonrec")])
    Ocaml.Abs.ObjectAttr -> prPrec i 0 (concatD [doc (showString "object")])
    Ocaml.Abs.OfAttr -> prPrec i 0 (concatD [doc (showString "of")])
    Ocaml.Abs.OpenAttr -> prPrec i 0 (concatD [doc (showString "open")])
    Ocaml.Abs.OrAttr -> prPrec i 0 (concatD [doc (showString "or")])
    Ocaml.Abs.PrivateAttr -> prPrec i 0 (concatD [doc (showString "private")])
    Ocaml.Abs.RecAttr -> prPrec i 0 (concatD [doc (showString "rec")])
    Ocaml.Abs.SigAttr -> prPrec i 0 (concatD [doc (showString "sig")])
    Ocaml.Abs.StructAttr -> prPrec i 0 (concatD [doc (showString "struct")])
    Ocaml.Abs.ThenAttr -> prPrec i 0 (concatD [doc (showString "then")])
    Ocaml.Abs.ToAttr -> prPrec i 0 (concatD [doc (showString "to")])
    Ocaml.Abs.TrueAttr -> prPrec i 0 (concatD [doc (showString "true")])
    Ocaml.Abs.TryAttr -> prPrec i 0 (concatD [doc (showString "try")])
    Ocaml.Abs.TypeAttr -> prPrec i 0 (concatD [doc (showString "type")])
    Ocaml.Abs.ValAttr -> prPrec i 0 (concatD [doc (showString "val")])
    Ocaml.Abs.VirtualAttr -> prPrec i 0 (concatD [doc (showString "virtual")])
    Ocaml.Abs.WhenAttr -> prPrec i 0 (concatD [doc (showString "when")])
    Ocaml.Abs.WhileAttr -> prPrec i 0 (concatD [doc (showString "while")])
    Ocaml.Abs.WithAttr -> prPrec i 0 (concatD [doc (showString "with")])

instance Print [Ocaml.Abs.AttrId] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString "."), prt 0 xs]

instance Print Ocaml.Abs.Attribute where
  prt i = \case
    Ocaml.Abs.Attribute attrids attrpayload -> prPrec i 0 (concatD [doc (showString "[@"), prt 0 attrids, prt 0 attrpayload, doc (showString "]")])

instance Print Ocaml.Abs.PostItemAttribute where
  prt i = \case
    Ocaml.Abs.PostItemAttribute attrids attrpayload -> prPrec i 0 (concatD [doc (showString "[@@"), prt 0 attrids, prt 0 attrpayload, doc (showString "]")])

instance Print Ocaml.Abs.FloatingAttribute where
  prt i = \case
    Ocaml.Abs.FloatingAttribute attrids attrpayload -> prPrec i 0 (concatD [doc (showString "[@@@"), prt 0 attrids, prt 0 attrpayload, doc (showString "]")])

instance Print [Ocaml.Abs.PostItemAttribute] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print [Ocaml.Abs.Attribute] where
  prt _ [] = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print Ocaml.Abs.Ext where
  prt i = \case
    Ocaml.Abs.NoExt -> prPrec i 0 (concatD [])
    Ocaml.Abs.Ext attrids -> prPrec i 0 (concatD [doc (showString "%"), prt 0 attrids])

instance Print Ocaml.Abs.Extension where
  prt i = \case
    Ocaml.Abs.ExtensionPayload attrids payload -> prPrec i 0 (concatD [doc (showString "[%"), prt 0 attrids, prt 0 payload, doc (showString "]")])
    Ocaml.Abs.QuotedStringExpr quotedstringexpr -> prPrec i 0 (concatD [prt 0 quotedstringexpr])

instance Print Ocaml.Abs.ItemExtension where
  prt i = \case
    Ocaml.Abs.ItemExtensionPayload attrids payload -> prPrec i 0 (concatD [doc (showString "[%%"), prt 0 attrids, prt 0 payload, doc (showString "]")])
    Ocaml.Abs.QuotedStringItem quotedstringitem -> prPrec i 0 (concatD [prt 0 quotedstringitem])

instance Print Ocaml.Abs.Payload where
  prt i = \case
    Ocaml.Abs.PayloadStructure structure -> prPrec i 0 (concatD [prt 0 structure])
    Ocaml.Abs.PayloadSignature signature -> prPrec i 0 (concatD [doc (showString ":"), prt 0 signature])
    Ocaml.Abs.PayloadCoreType coretype -> prPrec i 0 (concatD [doc (showString ":"), prt 0 coretype])
    Ocaml.Abs.PayloadPattern pattern_ -> prPrec i 0 (concatD [doc (showString "?"), prt 0 pattern_])
    Ocaml.Abs.PayloadGuardedPattern pattern_ seqexpr -> prPrec i 0 (concatD [doc (showString "?"), prt 0 pattern_, doc (showString "when"), prt 0 seqexpr])

instance Print Ocaml.Abs.AttrPayload where
  prt i = \case
    Ocaml.Abs.AttrPayload payload -> prPrec i 0 (concatD [prt 0 payload])
