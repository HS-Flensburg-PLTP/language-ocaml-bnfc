-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Ocaml.Par where
import Ocaml.Abs
import Ocaml.Lex
import Ocaml.ErrM

}

%name pINT INT
%name pQUOTED_STRING_EXPR QUOTED_STRING_EXPR
%name pQUOTED_STRING_ITEM QUOTED_STRING_ITEM
%name pImplementation Implementation
%name pInterface Interface
%name pListStructureItem ListStructureItem
%name pToplevelPhrase ToplevelPhrase
%name pListFunctorArg ListFunctorArg
%name pFunctorArg FunctorArg
%name pModuleName ModuleName
%name pModuleExpr ModuleExpr
%name pParenModuleExpr ParenModuleExpr
%name pExprColonPackageType ExprColonPackageType
%name pListStructureElement ListStructureElement
%name pStructure Structure
%name pOptionalStructureStandaloneExpression OptionalStructureStandaloneExpression
%name pStrExpr StrExpr
%name pStructureElement StructureElement
%name pStructureItem StructureItem
%name pModuleExprIncludeStatement ModuleExprIncludeStatement
%name pModuleBindingBody ModuleBindingBody
%name pListAndModuleBinding ListAndModuleBinding
%name pRecModuleBinding RecModuleBinding
%name pAndModuleBinding AndModuleBinding
%name pOptionalModuleType OptionalModuleType
%name pModuleTypeDeclaration ModuleTypeDeclaration
%name pOpenDeclaration OpenDeclaration
%name pOpenDescription OpenDescription
%name pOpenDotDeclaration OpenDotDeclaration
%name pListWithConstraint ListWithConstraint
%name pModuleType ModuleType
%name pSignature Signature
%name pListSignatureElement ListSignatureElement
%name pSignatureElement SignatureElement
%name pSignatureItem SignatureItem
%name pModuleTypeIncludeStatement ModuleTypeIncludeStatement
%name pModuleDeclaration ModuleDeclaration
%name pModuleDeclarationBody ModuleDeclarationBody
%name pModuleAlias ModuleAlias
%name pModuleExprAlias ModuleExprAlias
%name pModuleSubst ModuleSubst
%name pRecModuleDeclaration RecModuleDeclaration
%name pAndModuleDeclaration AndModuleDeclaration
%name pListAndModuleDeclaration ListAndModuleDeclaration
%name pModuleTypeSubst ModuleTypeSubst
%name pClassDeclarations ClassDeclarations
%name pListClassDeclaration ListClassDeclaration
%name pClassDeclaration ClassDeclaration
%name pClassFunBinding ClassFunBinding
%name pFormalClassParameters FormalClassParameters
%name pClassExpr ClassExpr
%name pClassSimpleExpr ClassSimpleExpr
%name pClassFunDef ClassFunDef
%name pClassStructure ClassStructure
%name pClassSelfPattern ClassSelfPattern
%name pListClassField ListClassField
%name pOptionalAs OptionalAs
%name pClassField ClassField
%name pValue Value
%name pMethod_ Method_
%name pClassType ClassType
%name pClassSignature ClassSignature
%name pClassSelfType ClassSelfType
%name pActualClassParameters ActualClassParameters
%name pListCoreType ListCoreType
%name pClassSigField ClassSigField
%name pListClassSigField ListClassSigField
%name pConstrain Constrain
%name pClassTypeDeclarations ClassTypeDeclarations
%name pClassTypeDeclaration ClassTypeDeclaration
%name pAndClassTypeDeclaration AndClassTypeDeclaration
%name pListAndClassTypeDeclaration ListAndClassTypeDeclaration
%name pFunSeqExpr FunSeqExpr
%name pSeqExpr SeqExpr
%name pLabeledSimplePattern LabeledSimplePattern
%name pPatternVar PatternVar
%name pOptDefault OptDefault
%name pLabelLetPattern LabelLetPattern
%name pLabelVar LabelVar
%name pLetPattern LetPattern
%name pQualifiedDotop QualifiedDotop
%name pFunExpr FunExpr
%name pExpr Expr
%name pOptionalAtomicTypeAnnotation OptionalAtomicTypeAnnotation
%name pFunExprAttrs FunExprAttrs
%name pDoDoneExpr DoDoneExpr
%name pListLabeledSimpleExpr ListLabeledSimpleExpr
%name pExpr_ Expr_
%name pSimpleExpr SimpleExpr
%name pSimpleExprAttrs SimpleExprAttrs
%name pSimpleExpr_ SimpleExpr_
%name pLabeledSimpleExpr LabeledSimpleExpr
%name pLetBindingBodyNoPunning LetBindingBodyNoPunning
%name pLetBindingBody LetBindingBody
%name pLetBindingsNoExt LetBindingsNoExt
%name pLetBindingsExt LetBindingsExt
%name pLetBindingExt LetBindingExt
%name pLetBindingNoExt LetBindingNoExt
%name pAndLetBinding AndLetBinding
%name pLetopBindingBody LetopBindingBody
%name pLetopBindings LetopBindings
%name pStrictBinding StrictBinding
%name pFunBody FunBody
%name pMatchCases MatchCases
%name pListMatchCase ListMatchCase
%name pMatchCase MatchCase
%name pFunParamAsList FunParamAsList
%name pListFunParamAsList ListFunParamAsList
%name pExprComma ExprComma
%name pListExprComma ListExprComma
%name pOptionalWith OptionalWith
%name pRecordExprFields RecordExprFields
%name pRecordExprContent RecordExprContent
%name pOptionalTypeConstraint OptionalTypeConstraint
%name pRecordExprField RecordExprField
%name pListObjectExprField ListObjectExprField
%name pOptionalAssignExpr OptionalAssignExpr
%name pObjectExprField ObjectExprField
%name pListExpr ListExpr
%name pTypeConstraint TypeConstraint
%name pPattern Pattern
%name pPatternNoExn PatternNoExn
%name pPatternPattern PatternPattern
%name pPatternPatternNoExn PatternPatternNoExn
%name pListLIDENT ListLIDENT
%name pPatternGen PatternGen
%name pSimplePattern SimplePattern
%name pSimplePatternNotIdent SimplePatternNotIdent
%name pSimplePatternNotIdent_ SimplePatternNotIdent_
%name pSimpleDelimitedPattern SimpleDelimitedPattern
%name pPatternCommaListPattern PatternCommaListPattern
%name pPatternCommaListPatternNoExn PatternCommaListPatternNoExn
%name pPatternSemi PatternSemi
%name pListPatternSemi ListPatternSemi
%name pOptionalSemi OptionalSemi
%name pRecordPatContent RecordPatContent
%name pOptionalCoreType OptionalCoreType
%name pRecordPatField RecordPatField
%name pValueDescription ValueDescription
%name pListRawString ListRawString
%name pPrimitiveDeclaration PrimitiveDeclaration
%name pTypeDeclarations TypeDeclarations
%name pAndTypeDeclaration AndTypeDeclaration
%name pListAndTypeDeclaration ListAndTypeDeclaration
%name pTypeSubstDeclarations TypeSubstDeclarations
%name pAndTypeSubstDeclaration AndTypeSubstDeclaration
%name pListAndTypeSubstDeclaration ListAndTypeSubstDeclaration
%name pTypeSubstDeclaration TypeSubstDeclaration
%name pTypeDeclaration TypeDeclaration
%name pConstraint Constraint
%name pListConstraint ListConstraint
%name pNonemptyTypeKind NonemptyTypeKind
%name pTypeSynonym TypeSynonym
%name pTypeKind TypeKind
%name pTypeSubstKind TypeSubstKind
%name pTypeParameters TypeParameters
%name pListTypeParameter ListTypeParameter
%name pTypeParameter TypeParameter
%name pTypeVariable TypeVariable
%name pTypeVariance TypeVariance
%name pListConstructorDeclaration ListConstructorDeclaration
%name pConstructorDeclarations ConstructorDeclarations
%name pConstructorDeclaration ConstructorDeclaration
%name pStrExceptionDeclaration StrExceptionDeclaration
%name pSigExceptionDeclaration SigExceptionDeclaration
%name pLetExceptionDeclaration LetExceptionDeclaration
%name pGeneralizedConstructorArguments GeneralizedConstructorArguments
%name pConstructorArguments ConstructorArguments
%name pLabelDeclarations LabelDeclarations
%name pLabelDeclaration LabelDeclaration
%name pLabelDeclarationSemi LabelDeclarationSemi
%name pStrTypeExtension StrTypeExtension
%name pBarLlistExtensionConstructor BarLlistExtensionConstructor
%name pListExtensionConstructor ListExtensionConstructor
%name pSigTypeExtension SigTypeExtension
%name pBarLlistExtensionConstructorDeclaration BarLlistExtensionConstructorDeclaration
%name pListExtensionConstructorDeclaration ListExtensionConstructorDeclaration
%name pExtensionConstructor ExtensionConstructor
%name pExtensionConstructorDeclaration ExtensionConstructorDeclaration
%name pExtensionConstructorRebind ExtensionConstructorRebind
%name pWithConstraint WithConstraint
%name pWithTypeBinder WithTypeBinder
%name pTypeVar TypeVar
%name pListTypeVar ListTypeVar
%name pPolyType PolyType
%name pPolyTypeNoAttr PolyTypeNoAttr
%name pCoreType CoreType
%name pCoreTypeNoAttr CoreTypeNoAttr
%name pAliasType AliasType
%name pFunctionType FunctionType
%name pArgLabel ArgLabel
%name pTupleType TupleType
%name pListAtomicType ListAtomicType
%name pOptionalBar OptionalBar
%name pDelimitedTypeSupportingLocalOpen DelimitedTypeSupportingLocalOpen
%name pObjectType ObjectType
%name pDelimitedType DelimitedType
%name pAtomicType AtomicType
%name pActualTypeParameters ActualTypeParameters
%name pPackageType PackageType
%name pListRowField ListRowField
%name pRowField RowField
%name pTagField TagField
%name pOptAmpersand OptAmpersand
%name pListCoreTypeNoAttr ListCoreTypeNoAttr
%name pListNameTag ListNameTag
%name pMethList MethList
%name pLabel Label
%name pConstant Constant
%name pSignedConstant SignedConstant
%name pOCamlIdent OCamlIdent
%name pValExtraIdent ValExtraIdent
%name pValIdent ValIdent
%name pOperator Operator
%name pInfixOperator InfixOperator
%name pIndexMod IndexMod
%name pConstrExtraIdent ConstrExtraIdent
%name pConstrExtraNonprefixIdent ConstrExtraNonprefixIdent
%name pConstrIdent ConstrIdent
%name pConstrLongident ConstrLongident
%name pValLongident ValLongident
%name pLabelLongident LabelLongident
%name pTypeLongident TypeLongident
%name pModLongident ModLongident
%name pModExtLongident ModExtLongident
%name pMtyLongident MtyLongident
%name pCltyLongident CltyLongident
%name pClassLongident ClassLongident
%name pOptionalToplevelDirectiveArgument OptionalToplevelDirectiveArgument
%name pToplevelDirective ToplevelDirective
%name pToplevelDirectiveArgument ToplevelDirectiveArgument
%name pRawString RawString
%name pNameTag NameTag
%name pRecFlag RecFlag
%name pNonrecFlag NonrecFlag
%name pDirectionFlag DirectionFlag
%name pPrivateFlag PrivateFlag
%name pInlinePrivateFlag InlinePrivateFlag
%name pMutableFlag MutableFlag
%name pVirtualFlag VirtualFlag
%name pMutableVirtualFlags MutableVirtualFlags
%name pPrivateVirtualFlags PrivateVirtualFlags
%name pVirtualWithMutableFlag VirtualWithMutableFlag
%name pVirtualWithPrivateFlag VirtualWithPrivateFlag
%name pNoOverrideFlag NoOverrideFlag
%name pOverrideFlag OverrideFlag
%name pSubtractive Subtractive
%name pAdditive Additive
%name pAttrId AttrId
%name pListAttrId ListAttrId
%name pAttribute Attribute
%name pPostItemAttribute PostItemAttribute
%name pFloatingAttribute FloatingAttribute
%name pListPostItemAttribute ListPostItemAttribute
%name pListAttribute ListAttribute
%name pExt Ext
%name pExtension Extension
%name pItemExtension ItemExtension
%name pPayload Payload
%name pAttrPayload AttrPayload
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '!+' { PT _ (TS _ 2) }
  '!-' { PT _ (TS _ 3) }
  '#' { PT _ (TS _ 4) }
  '%' { PT _ (TS _ 5) }
  '&' { PT _ (TS _ 6) }
  '&&' { PT _ (TS _ 7) }
  '\'' { PT _ (TS _ 8) }
  '(' { PT _ (TS _ 9) }
  ')' { PT _ (TS _ 10) }
  '*' { PT _ (TS _ 11) }
  '+' { PT _ (TS _ 12) }
  '+!' { PT _ (TS _ 13) }
  '+.' { PT _ (TS _ 14) }
  '+=' { PT _ (TS _ 15) }
  ',' { PT _ (TS _ 16) }
  '-' { PT _ (TS _ 17) }
  '-!' { PT _ (TS _ 18) }
  '-.' { PT _ (TS _ 19) }
  '->' { PT _ (TS _ 20) }
  '.' { PT _ (TS _ 21) }
  '..' { PT _ (TS _ 22) }
  ':' { PT _ (TS _ 23) }
  '::' { PT _ (TS _ 24) }
  ':=' { PT _ (TS _ 25) }
  ':>' { PT _ (TS _ 26) }
  ';' { PT _ (TS _ 27) }
  ';;' { PT _ (TS _ 28) }
  '<' { PT _ (TS _ 29) }
  '<-' { PT _ (TS _ 30) }
  '=' { PT _ (TS _ 31) }
  '>' { PT _ (TS _ 32) }
  '>}' { PT _ (TS _ 33) }
  '?' { PT _ (TS _ 34) }
  '[' { PT _ (TS _ 35) }
  '[%' { PT _ (TS _ 36) }
  '[%%' { PT _ (TS _ 37) }
  '[<' { PT _ (TS _ 38) }
  '[>' { PT _ (TS _ 39) }
  '[@' { PT _ (TS _ 40) }
  '[@@' { PT _ (TS _ 41) }
  '[@@@' { PT _ (TS _ 42) }
  '[|' { PT _ (TS _ 43) }
  ']' { PT _ (TS _ 44) }
  '_' { PT _ (TS _ 45) }
  '`' { PT _ (TS _ 46) }
  'and' { PT _ (TS _ 47) }
  'as' { PT _ (TS _ 48) }
  'assert' { PT _ (TS _ 49) }
  'begin' { PT _ (TS _ 50) }
  'class' { PT _ (TS _ 51) }
  'constraint' { PT _ (TS _ 52) }
  'do' { PT _ (TS _ 53) }
  'done' { PT _ (TS _ 54) }
  'downto' { PT _ (TS _ 55) }
  'else' { PT _ (TS _ 56) }
  'end' { PT _ (TS _ 57) }
  'exception' { PT _ (TS _ 58) }
  'external' { PT _ (TS _ 59) }
  'false' { PT _ (TS _ 60) }
  'for' { PT _ (TS _ 61) }
  'fun' { PT _ (TS _ 62) }
  'function' { PT _ (TS _ 63) }
  'functor' { PT _ (TS _ 64) }
  'if' { PT _ (TS _ 65) }
  'in' { PT _ (TS _ 66) }
  'include' { PT _ (TS _ 67) }
  'inherit' { PT _ (TS _ 68) }
  'initializer' { PT _ (TS _ 69) }
  'lazy' { PT _ (TS _ 70) }
  'let' { PT _ (TS _ 71) }
  'match' { PT _ (TS _ 72) }
  'method' { PT _ (TS _ 73) }
  'module' { PT _ (TS _ 74) }
  'mutable' { PT _ (TS _ 75) }
  'new' { PT _ (TS _ 76) }
  'nonrec' { PT _ (TS _ 77) }
  'object' { PT _ (TS _ 78) }
  'of' { PT _ (TS _ 79) }
  'open' { PT _ (TS _ 80) }
  'or' { PT _ (TS _ 81) }
  'private' { PT _ (TS _ 82) }
  'rec' { PT _ (TS _ 83) }
  'sig' { PT _ (TS _ 84) }
  'struct' { PT _ (TS _ 85) }
  'then' { PT _ (TS _ 86) }
  'to' { PT _ (TS _ 87) }
  'true' { PT _ (TS _ 88) }
  'try' { PT _ (TS _ 89) }
  'type' { PT _ (TS _ 90) }
  'val' { PT _ (TS _ 91) }
  'virtual' { PT _ (TS _ 92) }
  'when' { PT _ (TS _ 93) }
  'while' { PT _ (TS _ 94) }
  'with' { PT _ (TS _ 95) }
  '{' { PT _ (TS _ 96) }
  '{%' { PT _ (TS _ 97) }
  '{%%' { PT _ (TS _ 98) }
  '{<' { PT _ (TS _ 99) }
  '|' { PT _ (TS _ 100) }
  '|]' { PT _ (TS _ 101) }
  '||' { PT _ (TS _ 102) }
  '}' { PT _ (TS _ 103) }
  '~' { PT _ (TS _ 104) }
  L_ident  { PT _ (TV $$) }
  L_quoted { PT _ (TL $$) }
  L_integ  { PT _ (TI $$) }
  L_CHAR { PT _ (T_CHAR $$) }
  L_FLOAT { PT _ (T_FLOAT $$) }
  L_RELOP { PT _ (T_RELOP $$) }
  L_CONCATOP { PT _ (T_CONCATOP $$) }
  L_PLUSMINUSOP { PT _ (T_PLUSMINUSOP $$) }
  L_MULTDIVOP { PT _ (T_MULTDIVOP $$) }
  L_POWOP { PT _ (T_POWOP $$) }
  L_DOTOP { PT _ (T_DOTOP $$) }
  L_LETOP { PT _ (T_LETOP $$) }
  L_ANDOP { PT _ (T_ANDOP $$) }
  L_DecimalLiteral { PT _ (T_DecimalLiteral $$) }
  L_DecimalLiteralModifier { PT _ (T_DecimalLiteralModifier $$) }
  L_HexLiteral { PT _ (T_HexLiteral $$) }
  L_HexLiteralModifier { PT _ (T_HexLiteralModifier $$) }
  L_OctLiteral { PT _ (T_OctLiteral $$) }
  L_OctLiteralModifier { PT _ (T_OctLiteralModifier $$) }
  L_BinLiteral { PT _ (T_BinLiteral $$) }
  L_BinLiteralModifier { PT _ (T_BinLiteralModifier $$) }
  L_LABEL { PT _ (T_LABEL $$) }
  L_LIDENT { PT _ (T_LIDENT $$) }
  L_OPTLABEL { PT _ (T_OPTLABEL $$) }
  L_PREFIXOP { PT _ (T_PREFIXOP $$) }
  L_HASHOP { PT _ (T_HASHOP $$) }
  L_STRING { PT _ (T_STRING $$) }
  L_ExtAttrIdent { PT _ (T_ExtAttrIdent $$) }
  L_UIDENT { PT _ (T_UIDENT $$) }

%%

Ident   :: { Ident }
Ident    : L_ident  { Ident $1 }

String  :: { String }
String   : L_quoted {  $1 }

Integer :: { Integer }
Integer  : L_integ  { (read ( $1)) :: Integer }

CHAR :: { CHAR}
CHAR  : L_CHAR { CHAR ($1)}

FLOAT :: { FLOAT}
FLOAT  : L_FLOAT { FLOAT ($1)}

RELOP :: { RELOP}
RELOP  : L_RELOP { RELOP ($1)}

CONCATOP :: { CONCATOP}
CONCATOP  : L_CONCATOP { CONCATOP ($1)}

PLUSMINUSOP :: { PLUSMINUSOP}
PLUSMINUSOP  : L_PLUSMINUSOP { PLUSMINUSOP ($1)}

MULTDIVOP :: { MULTDIVOP}
MULTDIVOP  : L_MULTDIVOP { MULTDIVOP ($1)}

POWOP :: { POWOP}
POWOP  : L_POWOP { POWOP ($1)}

DOTOP :: { DOTOP}
DOTOP  : L_DOTOP { DOTOP ($1)}

LETOP :: { LETOP}
LETOP  : L_LETOP { LETOP ($1)}

ANDOP :: { ANDOP}
ANDOP  : L_ANDOP { ANDOP ($1)}

DecimalLiteral :: { DecimalLiteral}
DecimalLiteral  : L_DecimalLiteral { DecimalLiteral ($1)}

DecimalLiteralModifier :: { DecimalLiteralModifier}
DecimalLiteralModifier  : L_DecimalLiteralModifier { DecimalLiteralModifier ($1)}

HexLiteral :: { HexLiteral}
HexLiteral  : L_HexLiteral { HexLiteral ($1)}

HexLiteralModifier :: { HexLiteralModifier}
HexLiteralModifier  : L_HexLiteralModifier { HexLiteralModifier ($1)}

OctLiteral :: { OctLiteral}
OctLiteral  : L_OctLiteral { OctLiteral ($1)}

OctLiteralModifier :: { OctLiteralModifier}
OctLiteralModifier  : L_OctLiteralModifier { OctLiteralModifier ($1)}

BinLiteral :: { BinLiteral}
BinLiteral  : L_BinLiteral { BinLiteral ($1)}

BinLiteralModifier :: { BinLiteralModifier}
BinLiteralModifier  : L_BinLiteralModifier { BinLiteralModifier ($1)}

LABEL :: { LABEL}
LABEL  : L_LABEL { LABEL ($1)}

LIDENT :: { LIDENT}
LIDENT  : L_LIDENT { LIDENT ($1)}

OPTLABEL :: { OPTLABEL}
OPTLABEL  : L_OPTLABEL { OPTLABEL ($1)}

PREFIXOP :: { PREFIXOP}
PREFIXOP  : L_PREFIXOP { PREFIXOP ($1)}

HASHOP :: { HASHOP}
HASHOP  : L_HASHOP { HASHOP ($1)}

STRING :: { STRING}
STRING  : L_STRING { STRING ($1)}

ExtAttrIdent :: { ExtAttrIdent}
ExtAttrIdent  : L_ExtAttrIdent { ExtAttrIdent ($1)}

UIDENT :: { UIDENT}
UIDENT  : L_UIDENT { UIDENT ($1)}

INT :: { INT }
INT : DecimalLiteralModifier { Ocaml.Abs.ModifiedDecimal $1 }
    | DecimalLiteral { Ocaml.Abs.Decimal $1 }
    | HexLiteralModifier { Ocaml.Abs.ModifiedHex $1 }
    | HexLiteral { Ocaml.Abs.Hex $1 }
    | OctLiteralModifier { Ocaml.Abs.ModifiedOct $1 }
    | OctLiteral { Ocaml.Abs.Oct $1 }
    | BinLiteralModifier { Ocaml.Abs.ModifiedBin $1 }
    | BinLiteral { Ocaml.Abs.Bin $1 }
QUOTED_STRING_EXPR :: { QUOTED_STRING_EXPR }
QUOTED_STRING_EXPR : '{%' ExtAttrIdent '|' { Ocaml.Abs.Quoted_String_Expr1 $2 }
QUOTED_STRING_ITEM :: { QUOTED_STRING_ITEM }
QUOTED_STRING_ITEM : '{%%' ExtAttrIdent '|' { Ocaml.Abs.Quoted_String_Item1 $2 }
Implementation :: { Implementation }
Implementation : Structure { Ocaml.Abs.Implementation $1 }
Interface :: { Interface }
Interface : Signature { Ocaml.Abs.Interface $1 }
ListStructureItem :: { [StructureItem] }
ListStructureItem : {- empty -} { [] }
                  | ListStructureItem StructureItem { flip (:) $1 $2 }
ToplevelPhrase :: { ToplevelPhrase }
ToplevelPhrase : StrExpr ';;' { Ocaml.Abs.StrExpr $1 }
               | ListStructureItem ';;' { Ocaml.Abs.StructureItems (reverse $1) }
               | ToplevelDirective ';;' { Ocaml.Abs.ToplevelDirective $1 }
ListFunctorArg :: { [FunctorArg] }
ListFunctorArg : FunctorArg { (:[]) $1 }
               | FunctorArg ListFunctorArg { (:) $1 $2 }
FunctorArg :: { FunctorArg }
FunctorArg : '(' ')' { Ocaml.Abs.NoFunctorArg }
           | '(' ModuleName ':' ModuleType ')' { Ocaml.Abs.FunctorArg $2 $4 }
ModuleName :: { ModuleName }
ModuleName : UIDENT { Ocaml.Abs.ModuleNameIdent $1 }
           | '_' { Ocaml.Abs.ModuleNameUnderscore }
ModuleExpr :: { ModuleExpr }
ModuleExpr : 'struct' ListAttribute Structure 'end' { Ocaml.Abs.ModuleExprStruct (reverse $2) $3 }
           | 'functor' ListAttribute ListFunctorArg '->' ModuleExpr { Ocaml.Abs.ModuleExprFunctor (reverse $2) $3 $5 }
           | ParenModuleExpr { Ocaml.Abs.ModuleExprParen $1 }
           | ModuleExpr Attribute { Ocaml.Abs.ModuleExpr $1 $2 }
           | ModLongident { Ocaml.Abs.ModuleExprIdent $1 }
           | ModuleExpr ParenModuleExpr { Ocaml.Abs.ModuleExprFunctorApp $1 $2 }
           | ModuleExpr '(' ')' { Ocaml.Abs.FunctorAppUnit $1 }
           | Extension { Ocaml.Abs.ModuleExprExtension $1 }
ParenModuleExpr :: { ParenModuleExpr }
ParenModuleExpr : '(' ModuleExpr ':' ModuleType ')' { Ocaml.Abs.TypedParenModuleExpr $2 $4 }
                | '(' ModuleExpr ')' { Ocaml.Abs.ParenModuleExpr $2 }
                | '(' 'val' ListAttribute ExprColonPackageType ')' { Ocaml.Abs.ValParenModuleExpr (reverse $3) $4 }
ExprColonPackageType :: { ExprColonPackageType }
ExprColonPackageType : Expr { Ocaml.Abs.Expr $1 }
                     | Expr ':' ModuleType { Ocaml.Abs.TypedExpr $1 $3 }
                     | Expr ':' ModuleType ':>' ModuleType { Ocaml.Abs.TypedCoercionExpr $1 $3 $5 }
                     | Expr ':>' ModuleType { Ocaml.Abs.CoercionExpr $1 $3 }
ListStructureElement :: { [StructureElement] }
ListStructureElement : {- empty -} { [] }
                     | ListStructureElement StructureElement { flip (:) $1 $2 }
Structure :: { Structure }
Structure : OptionalStructureStandaloneExpression ListStructureElement { Ocaml.Abs.Structure $1 (reverse $2) }
OptionalStructureStandaloneExpression :: { OptionalStructureStandaloneExpression }
OptionalStructureStandaloneExpression : {- empty -} { Ocaml.Abs.NoStructureStandaloneExpression }
                                      | StrExpr { Ocaml.Abs.AStructureStandaloneExpression $1 }
StrExpr :: { StrExpr }
StrExpr : SeqExpr { Ocaml.Abs.SeqExpr $1 }
StructureElement :: { StructureElement }
StructureElement : ';;' OptionalStructureStandaloneExpression { Ocaml.Abs.StructureElement $2 }
                 | StructureItem { Ocaml.Abs.StructureItem $1 }
StructureItem :: { StructureItem }
StructureItem : LetBindingsExt { Ocaml.Abs.StructureLetBindings $1 }
              | ItemExtension ListPostItemAttribute { Ocaml.Abs.StructureItemExtension $1 (reverse $2) }
              | FloatingAttribute { Ocaml.Abs.StructureFloatingAttribute $1 }
              | PrimitiveDeclaration { Ocaml.Abs.StructurePrimitiveDeclaration $1 }
              | ValueDescription { Ocaml.Abs.StructureValueDescription $1 }
              | TypeDeclarations { Ocaml.Abs.StructureTypeDeclarations $1 }
              | StrTypeExtension { Ocaml.Abs.StructureStrTypeExtension $1 }
              | StrExceptionDeclaration { Ocaml.Abs.StrExceptionDeclaration $1 }
              | 'module' Ext ListAttribute ModuleName ModuleBindingBody ListPostItemAttribute { Ocaml.Abs.StructureModuleBinding $2 (reverse $3) $4 $5 (reverse $6) }
              | RecModuleBinding ListAndModuleBinding { Ocaml.Abs.StructureRecModuleBindings $1 $2 }
              | ModuleTypeDeclaration { Ocaml.Abs.StructureModuleTypeDeclaration $1 }
              | OpenDeclaration { Ocaml.Abs.StructureOpenDeclaration $1 }
              | ClassDeclarations { Ocaml.Abs.StructureClassDeclarations $1 }
              | ClassTypeDeclarations { Ocaml.Abs.StructureClassTypeDeclarations $1 }
              | ModuleExprIncludeStatement { Ocaml.Abs.StructureIncludeStatement $1 }
ModuleExprIncludeStatement :: { ModuleExprIncludeStatement }
ModuleExprIncludeStatement : 'include' Ext ListAttribute ModuleExpr ListPostItemAttribute { Ocaml.Abs.ModuleExprIncludeStatement $2 (reverse $3) $4 (reverse $5) }
ModuleBindingBody :: { ModuleBindingBody }
ModuleBindingBody : '=' ModuleExpr { Ocaml.Abs.ModuleBinding $2 }
                  | ':' ModuleType '=' ModuleExpr { Ocaml.Abs.TypedModuleBinding $2 $4 }
                  | FunctorArg ModuleBindingBody { Ocaml.Abs.FunctorBinding $1 $2 }
ListAndModuleBinding :: { [AndModuleBinding] }
ListAndModuleBinding : {- empty -} { [] }
                     | 'and' AndModuleBinding ListAndModuleBinding { (:) $2 $3 }
RecModuleBinding :: { RecModuleBinding }
RecModuleBinding : 'module' Ext ListAttribute 'rec' ModuleName ModuleBindingBody ListPostItemAttribute { Ocaml.Abs.RecModuleBinding $2 (reverse $3) $5 $6 (reverse $7) }
AndModuleBinding :: { AndModuleBinding }
AndModuleBinding : ListAttribute ModuleName ModuleBindingBody ListPostItemAttribute { Ocaml.Abs.AndModuleBinding (reverse $1) $2 $3 (reverse $4) }
OptionalModuleType :: { OptionalModuleType }
OptionalModuleType : {- empty -} { Ocaml.Abs.NoModuleType }
                   | '=' ModuleType { Ocaml.Abs.AModuleType $2 }
ModuleTypeDeclaration :: { ModuleTypeDeclaration }
ModuleTypeDeclaration : 'module' 'type' ListAttribute OCamlIdent OptionalModuleType ListPostItemAttribute { Ocaml.Abs.ModuleTypeDeclaration (reverse $3) $4 $5 (reverse $6) }
OpenDeclaration :: { OpenDeclaration }
OpenDeclaration : 'open' OverrideFlag Ext ListAttribute ModuleExpr ListPostItemAttribute { Ocaml.Abs.OpenDeclaration $2 $3 (reverse $4) $5 (reverse $6) }
OpenDescription :: { OpenDescription }
OpenDescription : 'open' OverrideFlag Ext ListAttribute ModExtLongident ListPostItemAttribute { Ocaml.Abs.OpenDescription $2 $3 (reverse $4) $5 (reverse $6) }
OpenDotDeclaration :: { OpenDotDeclaration }
OpenDotDeclaration : ModLongident { Ocaml.Abs.OpenDotDeclaration $1 }
ListWithConstraint :: { [WithConstraint] }
ListWithConstraint : WithConstraint { (:[]) $1 }
                   | WithConstraint 'and' ListWithConstraint { (:) $1 $3 }
ModuleType :: { ModuleType }
ModuleType : 'sig' ListAttribute Signature 'end' { Ocaml.Abs.ModuleTypeSignature (reverse $2) $3 }
           | 'functor' ListAttribute ListFunctorArg '->' ModuleType { Ocaml.Abs.ModuleTypeFunctor (reverse $2) $3 $5 }
           | 'module' 'type' 'of' ListAttribute ModuleExpr { Ocaml.Abs.ModuleTypeOf (reverse $4) $5 }
           | '(' ModuleType ')' { Ocaml.Abs.ParenModuleType $2 }
           | ModuleType Attribute { Ocaml.Abs.ModuleTypeWithAttribute $1 $2 }
           | ModLongident { Ocaml.Abs.ModuleTypeModuleIdent $1 }
           | '(' ')' '->' ModuleType { Ocaml.Abs.ModuleTypeNoArgFunctorApp $4 }
           | ModuleType '->' ModuleType { Ocaml.Abs.ModuleTypeFunctorApp $1 $3 }
           | ModuleType 'with' ListWithConstraint { Ocaml.Abs.ModuleTypeWith $1 $3 }
           | Extension { Ocaml.Abs.ModuleTypeExtension $1 }
Signature :: { Signature }
Signature : ListSignatureElement { Ocaml.Abs.Signature (reverse $1) }
ListSignatureElement :: { [SignatureElement] }
ListSignatureElement : {- empty -} { [] }
                     | ListSignatureElement SignatureElement { flip (:) $1 $2 }
SignatureElement :: { SignatureElement }
SignatureElement : ';;' { Ocaml.Abs.SemiSemi }
                 | SignatureItem { Ocaml.Abs.SignatureItem $1 }
SignatureItem :: { SignatureItem }
SignatureItem : ItemExtension ListPostItemAttribute { Ocaml.Abs.SigItemExtension $1 (reverse $2) }
              | FloatingAttribute { Ocaml.Abs.SigFloatingAttribute $1 }
              | ValueDescription { Ocaml.Abs.SigValueDescription $1 }
              | PrimitiveDeclaration { Ocaml.Abs.SigPrimitiveDeclaration $1 }
              | TypeDeclarations { Ocaml.Abs.SigTypeDeclarations $1 }
              | TypeSubstDeclarations { Ocaml.Abs.SigTypeSubstDeclarations $1 }
              | SigTypeExtension { Ocaml.Abs.SigSigTypeExtension $1 }
              | SigExceptionDeclaration { Ocaml.Abs.SigSigExceptionDeclaration $1 }
              | ModuleDeclaration { Ocaml.Abs.SigModuleDeclaration $1 }
              | ModuleAlias { Ocaml.Abs.SigModuleAlias $1 }
              | ModuleSubst { Ocaml.Abs.SigModuleSubst $1 }
              | RecModuleDeclaration ListAndModuleDeclaration { Ocaml.Abs.SigRecModuleDeclarations $1 $2 }
              | ModuleTypeDeclaration { Ocaml.Abs.SigModuleTypeDeclaration $1 }
              | ModuleTypeSubst { Ocaml.Abs.SigModuleTypeSubst $1 }
              | OpenDescription { Ocaml.Abs.SigOpenDescription $1 }
              | ModuleTypeIncludeStatement { Ocaml.Abs.SigIncludeStatement $1 }
              | ClassDeclarations { Ocaml.Abs.SigClassDeclarations $1 }
              | ClassTypeDeclarations { Ocaml.Abs.SigClassTypeDeclarations $1 }
ModuleTypeIncludeStatement :: { ModuleTypeIncludeStatement }
ModuleTypeIncludeStatement : 'include' Ext ListAttribute ModuleType ListPostItemAttribute { Ocaml.Abs.ModuleTypeIncludeStatement $2 (reverse $3) $4 (reverse $5) }
ModuleDeclaration :: { ModuleDeclaration }
ModuleDeclaration : 'module' Ext ListAttribute ModuleName ModuleDeclarationBody ListPostItemAttribute { Ocaml.Abs.ModuleDeclaration $2 (reverse $3) $4 $5 (reverse $6) }
ModuleDeclarationBody :: { ModuleDeclarationBody }
ModuleDeclarationBody : ':' ModuleType { Ocaml.Abs.ModuleBody $2 }
                      | FunctorArg ModuleDeclarationBody { Ocaml.Abs.FunctorBody $1 $2 }
ModuleAlias :: { ModuleAlias }
ModuleAlias : 'module' Ext ListAttribute ModuleName '=' ModuleExprAlias ListPostItemAttribute { Ocaml.Abs.ModuleAlias $2 (reverse $3) $4 $6 (reverse $7) }
ModuleExprAlias :: { ModuleExprAlias }
ModuleExprAlias : ModLongident { Ocaml.Abs.ModuleExprAlias $1 }
ModuleSubst :: { ModuleSubst }
ModuleSubst : 'module' Ext ListAttribute UIDENT ':=' ModExtLongident ListPostItemAttribute { Ocaml.Abs.ModuleSubst $2 (reverse $3) $4 $6 (reverse $7) }
RecModuleDeclaration :: { RecModuleDeclaration }
RecModuleDeclaration : 'module' Ext ListAttribute 'rec' ModuleName ':' ModuleType ListPostItemAttribute { Ocaml.Abs.RecModuleDeclaration $2 (reverse $3) $5 $7 (reverse $8) }
AndModuleDeclaration :: { AndModuleDeclaration }
AndModuleDeclaration : ListAttribute ModuleName ':' ModuleType ListPostItemAttribute { Ocaml.Abs.AndModuleDeclaration (reverse $1) $2 $4 (reverse $5) }
ListAndModuleDeclaration :: { [AndModuleDeclaration] }
ListAndModuleDeclaration : {- empty -} { [] }
                         | AndModuleDeclaration { (:[]) $1 }
                         | AndModuleDeclaration 'and' ListAndModuleDeclaration { (:) $1 $3 }
ModuleTypeSubst :: { ModuleTypeSubst }
ModuleTypeSubst : 'module' 'type' Ext ListAttribute OCamlIdent ':=' ModuleType ListPostItemAttribute { Ocaml.Abs.ModuleTypeSubst $3 (reverse $4) $5 $7 (reverse $8) }
ClassDeclarations :: { ClassDeclarations }
ClassDeclarations : 'class' Ext ListClassDeclaration { Ocaml.Abs.ClassDeclarations $2 $3 }
ListClassDeclaration :: { [ClassDeclaration] }
ListClassDeclaration : ClassDeclaration { (:[]) $1 }
                     | ClassDeclaration 'and' ListClassDeclaration { (:) $1 $3 }
ClassDeclaration :: { ClassDeclaration }
ClassDeclaration : ListAttribute VirtualFlag FormalClassParameters LIDENT ClassFunBinding ListPostItemAttribute { Ocaml.Abs.ClassDeclaration (reverse $1) $2 $3 $4 $5 (reverse $6) }
ClassFunBinding :: { ClassFunBinding }
ClassFunBinding : '=' ClassExpr { Ocaml.Abs.ClassFunBinding $2 }
                | ':' ClassType '=' ClassExpr { Ocaml.Abs.TypedClassFunBinding $2 $4 }
                | LabeledSimplePattern ClassFunBinding { Ocaml.Abs.LabeledClassFunBinding $1 $2 }
FormalClassParameters :: { FormalClassParameters }
FormalClassParameters : {- empty -} { Ocaml.Abs.NoFormalClassParamters }
                      | '[' ListTypeParameter ']' { Ocaml.Abs.FormalClassParameters $2 }
ClassExpr :: { ClassExpr }
ClassExpr : ClassSimpleExpr { Ocaml.Abs.ClassSimpleExpr $1 }
          | 'fun' ListAttribute ClassFunDef { Ocaml.Abs.ClassExprFunctor (reverse $2) $3 }
          | LetBindingsNoExt 'in' ClassExpr { Ocaml.Abs.ClassExprLetBindings $1 $3 }
          | 'let' 'open' OverrideFlag ListAttribute ModLongident 'in' ClassExpr { Ocaml.Abs.ClassExprLetOpen $3 (reverse $4) $5 $7 }
          | ClassExpr Attribute { Ocaml.Abs.ClassExpr $1 $2 }
          | ClassSimpleExpr ListLabeledSimpleExpr { Ocaml.Abs.LabeledClassSimpleExpr $1 $2 }
          | Extension { Ocaml.Abs.ClassExprExtension $1 }
ClassSimpleExpr :: { ClassSimpleExpr }
ClassSimpleExpr : '(' ClassExpr ')' { Ocaml.Abs.ParenClassExpr $2 }
                | ActualClassParameters ClassLongident { Ocaml.Abs.ClassName $1 $2 }
                | '(' ClassExpr ':' ClassType ')' { Ocaml.Abs.TypedClassExpr $2 $4 }
                | 'object' ListAttribute ClassStructure 'end' { Ocaml.Abs.ClassSimplExprObject (reverse $2) $3 }
ClassFunDef :: { ClassFunDef }
ClassFunDef : LabeledSimplePattern '->' ClassExpr { Ocaml.Abs.ClassFun $1 $3 }
            | LabeledSimplePattern ClassFunDef { Ocaml.Abs.LabeledClassFunDef $1 $2 }
ClassStructure :: { ClassStructure }
ClassStructure : ClassSelfPattern ListClassField { Ocaml.Abs.ClassSelfPattern $1 (reverse $2) }
ClassSelfPattern :: { ClassSelfPattern }
ClassSelfPattern : '(' Pattern ')' { Ocaml.Abs.ParenClassPattern $2 }
                 | '(' Pattern ':' CoreType ')' { Ocaml.Abs.TypedClassPattern $2 $4 }
                 | {- empty -} { Ocaml.Abs.NoClassSelfPattern }
ListClassField :: { [ClassField] }
ListClassField : {- empty -} { [] }
               | ListClassField ClassField { flip (:) $1 $2 }
OptionalAs :: { OptionalAs }
OptionalAs : {- empty -} { Ocaml.Abs.NoAs }
           | 'as' LIDENT { Ocaml.Abs.AAs $2 }
ClassField :: { ClassField }
ClassField : 'inherit' OverrideFlag ListAttribute ClassExpr OptionalAs ListPostItemAttribute { Ocaml.Abs.ClassFieldInherit $2 (reverse $3) $4 $5 (reverse $6) }
           | 'val' Value ListPostItemAttribute { Ocaml.Abs.ClassFieldVal $2 (reverse $3) }
           | 'method' Method_ ListPostItemAttribute { Ocaml.Abs.ClassFieldMethod $2 (reverse $3) }
           | 'constraint' ListAttribute CoreType '=' CoreType ListPostItemAttribute { Ocaml.Abs.ClassFieldConstraint (reverse $2) $3 $5 (reverse $6) }
           | 'initializer' ListAttribute SeqExpr ListPostItemAttribute { Ocaml.Abs.ClassFieldInitializer (reverse $2) $3 (reverse $4) }
           | ItemExtension ListPostItemAttribute { Ocaml.Abs.ClassFieldItemExtension $1 (reverse $2) }
           | FloatingAttribute { Ocaml.Abs.ClassFieldFloatingAttribute $1 }
Value :: { Value }
Value : NoOverrideFlag ListAttribute VirtualWithMutableFlag Label ':' CoreType { Ocaml.Abs.Value1 $1 (reverse $2) $3 $4 $6 }
      | OverrideFlag ListAttribute MutableFlag Label '=' SeqExpr { Ocaml.Abs.Value2 $1 (reverse $2) $3 $4 $6 }
      | OverrideFlag ListAttribute MutableFlag Label TypeConstraint '=' SeqExpr { Ocaml.Abs.Value3 $1 (reverse $2) $3 $4 $5 $7 }
Method_ :: { Method_ }
Method_ : NoOverrideFlag ListAttribute VirtualWithPrivateFlag Label ':' PolyType { Ocaml.Abs.Method1 $1 (reverse $2) $3 $4 $6 }
        | OverrideFlag ListAttribute PrivateFlag Label StrictBinding { Ocaml.Abs.Method2 $1 (reverse $2) $3 $4 $5 }
        | OverrideFlag ListAttribute PrivateFlag Label ':' PolyType '=' SeqExpr { Ocaml.Abs.Method3 $1 (reverse $2) $3 $4 $6 $8 }
        | OverrideFlag ListAttribute PrivateFlag Label ':' 'type' ListLIDENT '.' CoreType '=' SeqExpr { Ocaml.Abs.Method4 $1 (reverse $2) $3 $4 $7 $9 $11 }
ClassType :: { ClassType }
ClassType : ClassSignature { Ocaml.Abs.ClassSignature $1 }
          | ArgLabel TupleType '->' ClassType { Ocaml.Abs.ClassType $1 $2 $4 }
ClassSignature :: { ClassSignature }
ClassSignature : ActualClassParameters CltyLongident { Ocaml.Abs.ClassSignatureName $1 $2 }
               | Extension { Ocaml.Abs.ClassSignatureExtension $1 }
               | 'object' ListAttribute ClassSelfType ListClassSigField 'end' { Ocaml.Abs.ClassSignatureObject (reverse $2) $3 (reverse $4) }
               | ClassSignature Attribute { Ocaml.Abs.WithAttribute $1 $2 }
               | 'let' 'open' OverrideFlag ListAttribute ModLongident 'in' ClassSignature { Ocaml.Abs.ClassSignatureLetOpen $3 (reverse $4) $5 $7 }
ClassSelfType :: { ClassSelfType }
ClassSelfType : '(' CoreType ')' { Ocaml.Abs.ClassSelfType $2 }
              | {- empty -} { Ocaml.Abs.NoClassSelfType }
ActualClassParameters :: { ActualClassParameters }
ActualClassParameters : {- empty -} { Ocaml.Abs.NoActualClassParameters }
                      | '[' ListCoreType ']' { Ocaml.Abs.ActualClassParameters $2 }
ListCoreType :: { [CoreType] }
ListCoreType : CoreType { (:[]) $1 }
             | CoreType ',' ListCoreType { (:) $1 $3 }
             | CoreType { (:[]) $1 }
             | CoreType ',' ListCoreType { (:) $1 $3 }
ClassSigField :: { ClassSigField }
ClassSigField : 'inherit' ListAttribute ClassSignature ListPostItemAttribute { Ocaml.Abs.ClassSigFieldInherit (reverse $2) $3 (reverse $4) }
              | 'val' ListAttribute MutableVirtualFlags Label ':' CoreType ListPostItemAttribute { Ocaml.Abs.ClassSigFieldVal (reverse $2) $3 $4 $6 (reverse $7) }
              | 'method' ListAttribute PrivateVirtualFlags Label ':' PolyType ListPostItemAttribute { Ocaml.Abs.ClassSigFieldMethod (reverse $2) $3 $4 $6 (reverse $7) }
              | 'constraint' ListAttribute CoreType '=' CoreType ListPostItemAttribute { Ocaml.Abs.ClassSigFieldConstraint (reverse $2) $3 $5 (reverse $6) }
              | ItemExtension ListPostItemAttribute { Ocaml.Abs.ClassSigFieldItemExtension $1 (reverse $2) }
              | FloatingAttribute { Ocaml.Abs.ClassSigFieldFloatingAttribute $1 }
ListClassSigField :: { [ClassSigField] }
ListClassSigField : {- empty -} { [] }
                  | ListClassSigField ClassSigField { flip (:) $1 $2 }
Constrain :: { Constrain }
Constrain : CoreType '=' CoreType { Ocaml.Abs.Constrain $1 $3 }
ClassTypeDeclarations :: { ClassTypeDeclarations }
ClassTypeDeclarations : ClassTypeDeclaration ListAndClassTypeDeclaration { Ocaml.Abs.ClassTypeDeclarations $1 $2 }
ClassTypeDeclaration :: { ClassTypeDeclaration }
ClassTypeDeclaration : 'class' 'type' Ext ListAttribute VirtualFlag FormalClassParameters LIDENT '=' ClassSignature ListPostItemAttribute { Ocaml.Abs.ClassTypeDeclaration $3 (reverse $4) $5 $6 $7 $9 (reverse $10) }
AndClassTypeDeclaration :: { AndClassTypeDeclaration }
AndClassTypeDeclaration : ListAttribute VirtualFlag FormalClassParameters LIDENT '=' ClassSignature ListPostItemAttribute { Ocaml.Abs.AndClassTypeDeclaration (reverse $1) $2 $3 $4 $6 (reverse $7) }
ListAndClassTypeDeclaration :: { [AndClassTypeDeclaration] }
ListAndClassTypeDeclaration : {- empty -} { [] }
                            | AndClassTypeDeclaration { (:[]) $1 }
                            | AndClassTypeDeclaration 'and' ListAndClassTypeDeclaration { (:) $1 $3 }
FunSeqExpr :: { FunSeqExpr }
FunSeqExpr : FunExpr { Ocaml.Abs.FunExpr1 $1 }
           | FunExpr ';' { Ocaml.Abs.FunExpr2 $1 }
           | FunExpr ';' SeqExpr { Ocaml.Abs.FunExpr3 $1 $3 }
           | FunExpr ';' '%' ListAttrId SeqExpr { Ocaml.Abs.FunExpr4 $1 $4 $5 }
SeqExpr :: { SeqExpr }
SeqExpr : FunSeqExpr { Ocaml.Abs.SeqExprFunSeqExpr $1 }
        | 'function' Ext ListAttribute MatchCases { Ocaml.Abs.SeqExprFunction $2 (reverse $3) $4 }
LabeledSimplePattern :: { LabeledSimplePattern }
LabeledSimplePattern : '?' '(' LabelLetPattern OptDefault ')' { Ocaml.Abs.OptPattern $3 $4 }
                     | '?' LabelVar { Ocaml.Abs.OptLabelVar $2 }
                     | OPTLABEL '(' LetPattern OptDefault ')' { Ocaml.Abs.OptLabeledPattern $1 $3 $4 }
                     | OPTLABEL PatternVar { Ocaml.Abs.OptLabeledVar $1 $2 }
                     | '~' '(' LabelLetPattern ')' { Ocaml.Abs.LabeledPattern $3 }
                     | '~' LabelVar { Ocaml.Abs.LabeledVar $2 }
                     | LABEL SimplePattern { Ocaml.Abs.LabeledSimplePattern $1 $2 }
                     | SimplePattern { Ocaml.Abs.SimplePattern $1 }
PatternVar :: { PatternVar }
PatternVar : LIDENT { Ocaml.Abs.PatternVar $1 }
           | '_' { Ocaml.Abs.UnderscorePatternVar }
OptDefault :: { OptDefault }
OptDefault : {- empty -} { Ocaml.Abs.NoDefault }
           | '=' SeqExpr { Ocaml.Abs.Default $2 }
LabelLetPattern :: { LabelLetPattern }
LabelLetPattern : LabelVar { Ocaml.Abs.LabelLetPattern $1 }
                | LabelVar ':' CoreType { Ocaml.Abs.TypedLabelLetPattern $1 $3 }
LabelVar :: { LabelVar }
LabelVar : LIDENT { Ocaml.Abs.LabelVar $1 }
LetPattern :: { LetPattern }
LetPattern : Pattern { Ocaml.Abs.LetPattern $1 }
           | Pattern ':' CoreType { Ocaml.Abs.TypedLetPattern $1 $3 }
QualifiedDotop :: { QualifiedDotop }
QualifiedDotop : DOTOP { Ocaml.Abs.Unqualified $1 }
               | '.' ModLongident DOTOP { Ocaml.Abs.Qualified $2 $3 }
FunExpr :: { FunExpr }
FunExpr : SimpleExpr { Ocaml.Abs.SimpleExpr $1 }
        | FunExprAttrs { Ocaml.Abs.FunExprAttrs $1 }
        | Expr_ { Ocaml.Abs.Expr_ $1 }
        | LetBindingsExt { Ocaml.Abs.Let $1 }
        | LETOP LetopBindings 'in' SeqExpr { Ocaml.Abs.LetOpBinding $1 $2 $4 }
        | FunExpr '::' Expr { Ocaml.Abs.Cons $1 $3 }
        | Label '<-' Expr { Ocaml.Abs.UpdateExpr $1 $3 }
        | SimpleExpr '.' LabelLongident '<-' Expr { Ocaml.Abs.QualifiedDot $1 $3 $5 }
        | SimpleExpr '.' '(' SeqExpr ')' '<-' Expr { Ocaml.Abs.ArrayUpdateExpr $1 $4 $7 }
        | SimpleExpr '.' '{' SeqExpr '}' '<-' Expr { Ocaml.Abs.RecordUpdateExpr $1 $4 $7 }
        | SimpleExpr '.' '[' SeqExpr ']' '<-' Expr { Ocaml.Abs.StringUpdateExpr $1 $4 $7 }
        | SimpleExpr QualifiedDotop '(' ListExpr ')' '<-' Expr { Ocaml.Abs.ArrayUpdateDotopExpr $1 $2 $4 $7 }
        | SimpleExpr QualifiedDotop '{' ListExpr '}' '<-' Expr { Ocaml.Abs.RecordUpdateDotopExpr $1 $2 $4 $7 }
        | SimpleExpr QualifiedDotop '[' ListExpr ']' '<-' Expr { Ocaml.Abs.StringUpdateDotopExpr $1 $2 $4 $7 }
        | FunExpr Attribute { Ocaml.Abs.FunExprWithAttribute $1 $2 }
Expr :: { Expr }
Expr : FunExpr { Ocaml.Abs.FunExpr $1 }
     | 'function' Ext ListAttribute MatchCases { Ocaml.Abs.Function $2 (reverse $3) $4 }
OptionalAtomicTypeAnnotation :: { OptionalAtomicTypeAnnotation }
OptionalAtomicTypeAnnotation : {- empty -} { Ocaml.Abs.NoAtomicTypeAnnotation }
                             | ':' AtomicType { Ocaml.Abs.AnAtomicTypeAnnotation $2 }
FunExprAttrs :: { FunExprAttrs }
FunExprAttrs : 'let' 'module' Ext ListAttribute ModuleName ModuleBindingBody 'in' SeqExpr { Ocaml.Abs.LetModule $3 (reverse $4) $5 $6 $8 }
             | 'let' 'exception' Ext ListAttribute LetExceptionDeclaration 'in' SeqExpr { Ocaml.Abs.LetException $3 (reverse $4) $5 $7 }
             | 'let' 'open' OverrideFlag Ext ListAttribute ModuleExpr 'in' SeqExpr { Ocaml.Abs.LetOpen $3 $4 (reverse $5) $6 $8 }
             | 'fun' Ext ListAttribute ListFunParamAsList OptionalAtomicTypeAnnotation '->' FunBody { Ocaml.Abs.Fun $2 (reverse $3) $4 $5 $7 }
             | 'match' Ext ListAttribute SeqExpr 'with' MatchCases { Ocaml.Abs.Match $2 (reverse $3) $4 $6 }
             | 'try' Ext ListAttribute SeqExpr 'with' MatchCases { Ocaml.Abs.Try $2 (reverse $3) $4 $6 }
             | 'if' Ext ListAttribute SeqExpr 'then' Expr 'else' Expr { Ocaml.Abs.IfElse $2 (reverse $3) $4 $6 $8 }
             | 'if' Ext ListAttribute SeqExpr 'then' Expr { Ocaml.Abs.If $2 (reverse $3) $4 $6 }
             | 'while' Ext ListAttribute SeqExpr DoDoneExpr { Ocaml.Abs.While $2 (reverse $3) $4 $5 }
             | 'for' Ext ListAttribute Pattern '=' SeqExpr DirectionFlag SeqExpr DoDoneExpr { Ocaml.Abs.For $2 (reverse $3) $4 $6 $7 $8 $9 }
             | 'assert' Ext ListAttribute SimpleExpr { Ocaml.Abs.Assert $2 (reverse $3) $4 }
             | 'lazy' Ext ListAttribute SimpleExpr { Ocaml.Abs.Lazy $2 (reverse $3) $4 }
DoDoneExpr :: { DoDoneExpr }
DoDoneExpr : 'do' SeqExpr 'done' { Ocaml.Abs.DoDone $2 }
ListLabeledSimpleExpr :: { [LabeledSimpleExpr] }
ListLabeledSimpleExpr : LabeledSimpleExpr { (:[]) $1 }
                      | LabeledSimpleExpr ListLabeledSimpleExpr { (:) $1 $2 }
                      | LabeledSimpleExpr { (:[]) $1 }
                      | LabeledSimpleExpr ListLabeledSimpleExpr { (:) $1 $2 }
Expr_ :: { Expr_ }
Expr_ : SimpleExpr ListLabeledSimpleExpr { Ocaml.Abs.SimpleExprApp $1 $2 }
      | Expr ',' ListExprComma { Ocaml.Abs.Comma $1 $3 }
      | ConstrLongident { Ocaml.Abs.ConstrName_ $1 }
      | NameTag SimpleExpr { Ocaml.Abs.NameTagApp $1 $2 }
      | FunExpr InfixOperator Expr { Ocaml.Abs.Infix $1 $2 $3 }
      | Subtractive Expr { Ocaml.Abs.Subtractive $1 $2 }
      | Additive Expr { Ocaml.Abs.Additive $1 $2 }
SimpleExpr :: { SimpleExpr }
SimpleExpr : '(' SeqExpr ')' { Ocaml.Abs.ParenSeqExpr $2 }
           | '(' SeqExpr TypeConstraint ')' { Ocaml.Abs.TypedSeqExpr $2 $3 }
           | SimpleExpr '.' '(' SeqExpr ')' { Ocaml.Abs.ArrayExpr $1 $4 }
           | SimpleExpr '.' '{' SeqExpr '}' { Ocaml.Abs.RecordExpr $1 $4 }
           | SimpleExpr '.' '[' SeqExpr ']' { Ocaml.Abs.StringExpr $1 $4 }
           | SimpleExpr QualifiedDotop '(' ListExpr ')' { Ocaml.Abs.QualifiedArrayExpr $1 $2 $4 }
           | SimpleExpr QualifiedDotop '{' ListExpr '}' { Ocaml.Abs.QualifiedRecordExpr $1 $2 $4 }
           | SimpleExpr QualifiedDotop '[' ListExpr ']' { Ocaml.Abs.QualifiedStringExpr $1 $2 $4 }
           | SimpleExprAttrs { Ocaml.Abs.SimpleExprAttrs $1 }
           | SimpleExpr_ { Ocaml.Abs.SimpleExpr_ $1 }
SimpleExprAttrs :: { SimpleExprAttrs }
SimpleExprAttrs : 'begin' Ext ListAttribute SeqExpr 'end' { Ocaml.Abs.BeginEnd $2 (reverse $3) $4 }
                | 'begin' Ext ListAttribute 'end' { Ocaml.Abs.EmptyBeginEnd $2 (reverse $3) }
                | 'new' Ext ListAttribute ClassLongident { Ocaml.Abs.New $2 (reverse $3) $4 }
                | '(' 'module' Ext ListAttribute ModuleExpr ')' { Ocaml.Abs.Module $3 (reverse $4) $5 }
                | '(' 'module' Ext ListAttribute ModuleExpr ':' ModuleType ')' { Ocaml.Abs.TypedModule $3 (reverse $4) $5 $7 }
                | 'object' Ext ListAttribute ClassStructure 'end' { Ocaml.Abs.Object $2 (reverse $3) $4 }
SimpleExpr_ :: { SimpleExpr_ }
SimpleExpr_ : ValLongident { Ocaml.Abs.ValLongident_ $1 }
            | Constant { Ocaml.Abs.Constant_ $1 }
            | ConstrLongident { Ocaml.Abs.ConstrName $1 }
            | NameTag { Ocaml.Abs.NameTag_ $1 }
            | PREFIXOP SimpleExpr { Ocaml.Abs.PrefixApp $1 $2 }
            | '!' SimpleExpr { Ocaml.Abs.BangApp $2 }
            | '{<' ListObjectExprField '>}' { Ocaml.Abs.ObjectExpr $2 }
            | '{<' '>}' { Ocaml.Abs.EmptyObjectExpr }
            | SimpleExpr '.' LabelLongident { Ocaml.Abs.RecordAccessTodo $1 $3 }
            | OpenDotDeclaration '.' '(' SeqExpr ')' { Ocaml.Abs.QualifiedArrayExpr_ $1 $4 }
            | OpenDotDeclaration '.' '{' ListObjectExprField '}' { Ocaml.Abs.QualifiedObjectExpr $1 $4 }
            | SimpleExpr '#' Label { Ocaml.Abs.MethodInvocation $1 $3 }
            | SimpleExpr HASHOP SimpleExpr { Ocaml.Abs.HashOp $1 $2 $3 }
            | Extension { Ocaml.Abs.Extension $1 }
            | OpenDotDeclaration '.' '(' ')' { Ocaml.Abs.EmptyQualifiedArrayAccess $1 }
            | '{' RecordExprContent '}' { Ocaml.Abs.RecordExpr_ $2 }
            | OpenDotDeclaration '.' '{' RecordExprContent '}' { Ocaml.Abs.RecordAccess $1 $4 }
            | '[|' ListExpr '|]' { Ocaml.Abs.ArrayExpr_ $2 }
            | '[|' '|]' { Ocaml.Abs.EmptyArrayExpr }
            | OpenDotDeclaration '.' '[|' ListExpr '|]' { Ocaml.Abs.ArrayAccesss $1 $4 }
            | OpenDotDeclaration '.' '[|' '|]' { Ocaml.Abs.ArrayAccesssTodo $1 }
            | ModLongident '.' { Ocaml.Abs.QualifiedDot_ $1 }
            | '[' ListExpr ']' { Ocaml.Abs.StringExpr_ $2 }
            | OpenDotDeclaration '.' '[' ListExpr ']' { Ocaml.Abs.StringAccess $1 $4 }
            | OpenDotDeclaration '.' '[' ']' { Ocaml.Abs.StringAccessTodo $1 }
            | OpenDotDeclaration '.' '(' 'module' Ext ListAttribute ModuleExpr ':' ModuleType ')' { Ocaml.Abs.QualifiedModule $1 $5 (reverse $6) $7 $9 }
LabeledSimpleExpr :: { LabeledSimpleExpr }
LabeledSimpleExpr : SimpleExpr { Ocaml.Abs.LabeldSimpleExpr $1 }
                  | LABEL SimpleExpr { Ocaml.Abs.LabeledExpr $1 $2 }
                  | '~' LIDENT { Ocaml.Abs.Label $2 }
                  | '~' '(' LIDENT TypeConstraint ')' { Ocaml.Abs.TypedLabel $3 $4 }
                  | '?' LIDENT { Ocaml.Abs.OptLabel $2 }
                  | OPTLABEL SimpleExpr { Ocaml.Abs.OptLabeledExpr $1 $2 }
LetBindingBodyNoPunning :: { LetBindingBodyNoPunning }
LetBindingBodyNoPunning : ValIdent StrictBinding { Ocaml.Abs.StrictBinding $1 $2 }
                        | ValIdent TypeConstraint '=' SeqExpr { Ocaml.Abs.MonoTypedBinding $1 $2 $4 }
                        | ValIdent ':' ListTypeVar '.' CoreType '=' SeqExpr { Ocaml.Abs.PolyTypedBinding $1 $3 $5 $7 }
                        | ValIdent ':' 'type' ListLIDENT '.' CoreType '=' SeqExpr { Ocaml.Abs.TypedBindingTodo $1 $4 $6 $8 }
                        | PatternNoExn '=' SeqExpr { Ocaml.Abs.PatternNoExnBindingNoPunning $1 $3 }
                        | SimplePatternNotIdent ':' CoreType '=' SeqExpr { Ocaml.Abs.TypedBinding $1 $3 $5 }
LetBindingBody :: { LetBindingBody }
LetBindingBody : LetBindingBodyNoPunning { Ocaml.Abs.LetBindingBodyNoPunning $1 }
LetBindingsNoExt :: { LetBindingsNoExt }
LetBindingsNoExt : LetBindingNoExt { Ocaml.Abs.SingleLetBindingNoExt $1 }
                 | LetBindingsNoExt AndLetBinding { Ocaml.Abs.MultipleLetBindingNoExt $1 $2 }
LetBindingsExt :: { LetBindingsExt }
LetBindingsExt : LetBindingExt { Ocaml.Abs.SingleLetBindingExt $1 }
               | LetBindingsExt AndLetBinding { Ocaml.Abs.MultipleLetBindingExt $1 $2 }
LetBindingExt :: { LetBindingExt }
LetBindingExt : 'let' Ext ListAttribute RecFlag LetBindingBody ListPostItemAttribute { Ocaml.Abs.LetBindingExt $2 (reverse $3) $4 $5 (reverse $6) }
LetBindingNoExt :: { LetBindingNoExt }
LetBindingNoExt : 'let' ListAttribute RecFlag LetBindingBody ListPostItemAttribute { Ocaml.Abs.LetBindingNoExt (reverse $2) $3 $4 (reverse $5) }
AndLetBinding :: { AndLetBinding }
AndLetBinding : 'and' ListAttribute LetBindingBody ListPostItemAttribute { Ocaml.Abs.AndLetBinding (reverse $2) $3 (reverse $4) }
LetopBindingBody :: { LetopBindingBody }
LetopBindingBody : ValIdent StrictBinding { Ocaml.Abs.LetIdent $1 $2 }
                 | ValIdent { Ocaml.Abs.LetopValIdent $1 }
                 | SimplePattern TypeConstraint '=' SeqExpr { Ocaml.Abs.SimplePatternBinding $1 $2 $4 }
                 | PatternNoExn '=' SeqExpr { Ocaml.Abs.PatternNoExnBinding $1 $3 }
LetopBindings :: { LetopBindings }
LetopBindings : LetopBindingBody { Ocaml.Abs.BindingBody $1 }
              | LetopBindings ANDOP LetopBindingBody { Ocaml.Abs.AndOpBinding $1 $2 $3 }
StrictBinding :: { StrictBinding }
StrictBinding : '=' SeqExpr { Ocaml.Abs.Binding $2 }
              | ListFunParamAsList OptionalTypeConstraint '=' FunBody { Ocaml.Abs.FunParams $1 $2 $4 }
FunBody :: { FunBody }
FunBody : 'function' Ext ListAttribute MatchCases { Ocaml.Abs.FunBodyFunction $2 (reverse $3) $4 }
        | FunSeqExpr { Ocaml.Abs.FunBodyFunSeqExpr $1 }
MatchCases :: { MatchCases }
MatchCases : ListMatchCase { Ocaml.Abs.MatchCases1 $1 }
           | '|' ListMatchCase { Ocaml.Abs.MatchCases2 $2 }
ListMatchCase :: { [MatchCase] }
ListMatchCase : MatchCase { (:[]) $1 }
              | MatchCase '|' ListMatchCase { (:) $1 $3 }
MatchCase :: { MatchCase }
MatchCase : Pattern '->' SeqExpr { Ocaml.Abs.MatchCase $1 $3 }
          | Pattern 'when' SeqExpr '->' SeqExpr { Ocaml.Abs.GuardedMatchCase $1 $3 $5 }
          | Pattern '->' '.' { Ocaml.Abs.UnreachableMatchCase $1 }
FunParamAsList :: { FunParamAsList }
FunParamAsList : '(' 'type' ListLIDENT ')' { Ocaml.Abs.FunParam1 $3 }
               | LabeledSimplePattern { Ocaml.Abs.FunParam2 $1 }
ListFunParamAsList :: { [FunParamAsList] }
ListFunParamAsList : FunParamAsList { (:[]) $1 }
                   | FunParamAsList ListFunParamAsList { (:) $1 $2 }
ExprComma :: { ExprComma }
ExprComma : Expr { Ocaml.Abs.ExprComma $1 }
ListExprComma :: { [ExprComma] }
ListExprComma : ExprComma { (:[]) $1 }
              | ExprComma ',' ListExprComma { (:) $1 $3 }
OptionalWith :: { OptionalWith }
OptionalWith : {- empty -} { Ocaml.Abs.NoWith }
             | SimpleExpr 'with' { Ocaml.Abs.AWith $1 }
RecordExprFields :: { RecordExprFields }
RecordExprFields : RecordExprField { Ocaml.Abs.FinalRecordExprField1 $1 }
                 | RecordExprField ';' { Ocaml.Abs.FinalRecordExprField2 $1 }
                 | RecordExprFields ';' RecordExprField { Ocaml.Abs.MoreRecordExprFields $1 $3 }
RecordExprContent :: { RecordExprContent }
RecordExprContent : OptionalWith RecordExprFields { Ocaml.Abs.RecordExprContent $1 $2 }
OptionalTypeConstraint :: { OptionalTypeConstraint }
OptionalTypeConstraint : {- empty -} { Ocaml.Abs.NoTypeConstraint }
                       | TypeConstraint { Ocaml.Abs.ATypeConstraint $1 }
RecordExprField :: { RecordExprField }
RecordExprField : LabelLongident OptionalTypeConstraint OptionalAssignExpr { Ocaml.Abs.RecordExprField $1 $2 $3 }
ListObjectExprField :: { [ObjectExprField] }
ListObjectExprField : ObjectExprField { (:[]) $1 }
                    | ObjectExprField ';' { (:[]) $1 }
                    | ObjectExprField ';' ListObjectExprField { (:) $1 $3 }
OptionalAssignExpr :: { OptionalAssignExpr }
OptionalAssignExpr : {- empty -} { Ocaml.Abs.NoAssign }
                   | '=' Expr { Ocaml.Abs.AnAssign $2 }
ObjectExprField :: { ObjectExprField }
ObjectExprField : Label OptionalAssignExpr { Ocaml.Abs.ObjectExprField $1 $2 }
ListExpr :: { [Expr] }
ListExpr : Expr { (:[]) $1 } | Expr ';' ListExpr { (:) $1 $3 }
TypeConstraint :: { TypeConstraint }
TypeConstraint : ':' CoreType { Ocaml.Abs.TypeConstraint $2 }
               | ':' CoreType ':>' CoreType { Ocaml.Abs.TypeConstraintCoercion $2 $4 }
               | ':>' CoreType { Ocaml.Abs.TypeCoercion $2 }
Pattern :: { Pattern }
Pattern : PatternPattern { Ocaml.Abs.Pattern $1 }
        | 'exception' Ext ListAttribute Pattern { Ocaml.Abs.ExceptionPattern $2 (reverse $3) $4 }
PatternNoExn :: { PatternNoExn }
PatternNoExn : PatternPatternNoExn { Ocaml.Abs.PatternNoExn $1 }
PatternPattern :: { PatternPattern }
PatternPattern : Pattern '::' Pattern { Ocaml.Abs.ConsPattern $1 $3 }
               | Pattern Attribute { Ocaml.Abs.PatternWithAttribute $1 $2 }
               | PatternGen { Ocaml.Abs.PatternGen $1 }
               | Pattern 'as' ValIdent { Ocaml.Abs.AsPattern $1 $3 }
               | PatternCommaListPattern { Ocaml.Abs.TuplePattern $1 }
               | Pattern '|' Pattern { Ocaml.Abs.OrPattern $1 $3 }
PatternPatternNoExn :: { PatternPatternNoExn }
PatternPatternNoExn : PatternNoExn '::' Pattern { Ocaml.Abs.ConsPatternNoExn $1 $3 }
                    | PatternNoExn Attribute { Ocaml.Abs.PatternWithAttributeNoExn $1 $2 }
                    | PatternGen { Ocaml.Abs.PatternGenNoExn $1 }
                    | PatternNoExn 'as' ValIdent { Ocaml.Abs.AsPatternNoExn $1 $3 }
                    | PatternCommaListPatternNoExn { Ocaml.Abs.TuplePatternNoExn $1 }
                    | PatternNoExn '|' Pattern { Ocaml.Abs.OrPatternNoExn $1 $3 }
ListLIDENT :: { [LIDENT] }
ListLIDENT : LIDENT { (:[]) $1 } | LIDENT ListLIDENT { (:) $1 $2 }
PatternGen :: { PatternGen }
PatternGen : SimplePattern { Ocaml.Abs.SimplePatternGen $1 }
           | ConstrLongident Pattern { Ocaml.Abs.ConstrPattern $1 $2 }
           | ConstrLongident '(' 'type' ListLIDENT ')' SimplePattern { Ocaml.Abs.ConstrTypePattern $1 $4 $6 }
           | NameTag Pattern { Ocaml.Abs.TagPatternGen $1 $2 }
           | 'lazy' Ext ListAttribute SimplePattern { Ocaml.Abs.LazyPattern $2 (reverse $3) $4 }
SimplePattern :: { SimplePattern }
SimplePattern : ValIdent { Ocaml.Abs.ValIdent $1 }
              | SimplePatternNotIdent { Ocaml.Abs.SimplePatternNotIdent $1 }
SimplePatternNotIdent :: { SimplePatternNotIdent }
SimplePatternNotIdent : '(' Pattern ')' { Ocaml.Abs.ParenPattern $2 }
                      | SimpleDelimitedPattern { Ocaml.Abs.SimpleDelimitedPattern $1 }
                      | '(' 'module' Ext ListAttribute ModuleName ')' { Ocaml.Abs.ParenModule $3 (reverse $4) $5 }
                      | '(' 'module' Ext ListAttribute ModuleName ':' PackageType ')' { Ocaml.Abs.TypedParenModule $3 (reverse $4) $5 $7 }
                      | SimplePatternNotIdent_ { Ocaml.Abs.SimplePatternNotIdent_ $1 }
SimplePatternNotIdent_ :: { SimplePatternNotIdent_ }
SimplePatternNotIdent_ : '_' { Ocaml.Abs.UnderscorePattern }
                       | SignedConstant { Ocaml.Abs.ConstantPattern $1 }
                       | SignedConstant '..' SignedConstant { Ocaml.Abs.RangePattern $1 $3 }
                       | ConstrLongident { Ocaml.Abs.ConstrNamePattern $1 }
                       | NameTag { Ocaml.Abs.TagPattern $1 }
                       | '#' TypeLongident { Ocaml.Abs.TypeConstrPattern $2 }
                       | ModLongident '.' SimpleDelimitedPattern { Ocaml.Abs.DotPattern $1 $3 }
                       | ModLongident '.' '[' ']' { Ocaml.Abs.EmptyStringPattern $1 }
                       | ModLongident '.' '(' ')' { Ocaml.Abs.EmptyArrayPattern_ $1 }
                       | ModLongident '.' '(' Pattern ')' { Ocaml.Abs.ArrayPattern_ $1 $4 }
                       | '(' Pattern ':' CoreType ')' { Ocaml.Abs.TypedPattern $2 $4 }
                       | '(' 'module' Ext ListAttribute ModuleName ':' PackageType ')' { Ocaml.Abs.ModulePattern $3 (reverse $4) $5 $7 }
                       | Extension { Ocaml.Abs.ExtensionPattern $1 }
SimpleDelimitedPattern :: { SimpleDelimitedPattern }
SimpleDelimitedPattern : '{' RecordPatContent '}' { Ocaml.Abs.RecordPattern $2 }
                       | '[' ListPatternSemi ']' { Ocaml.Abs.ListPattern $2 }
                       | '[|' ListPatternSemi '|]' { Ocaml.Abs.ArrayPattern $2 }
                       | '[|' '|]' { Ocaml.Abs.EmptyArrayPattern }
PatternCommaListPattern :: { PatternCommaListPattern }
PatternCommaListPattern : PatternCommaListPattern ',' Pattern { Ocaml.Abs.MorePattern $1 $3 }
                        | Pattern ',' Pattern { Ocaml.Abs.TwoPattern $1 $3 }
PatternCommaListPatternNoExn :: { PatternCommaListPatternNoExn }
PatternCommaListPatternNoExn : PatternCommaListPatternNoExn ',' Pattern { Ocaml.Abs.MorePatternNoExn $1 $3 }
                             | PatternNoExn ',' Pattern { Ocaml.Abs.TwoPatternNoExn $1 $3 }
PatternSemi :: { PatternSemi }
PatternSemi : Pattern { Ocaml.Abs.PatternSemi $1 }
ListPatternSemi :: { [PatternSemi] }
ListPatternSemi : PatternSemi { (:[]) $1 }
                | PatternSemi ';' { (:[]) $1 }
                | PatternSemi ';' ListPatternSemi { (:) $1 $3 }
OptionalSemi :: { OptionalSemi }
OptionalSemi : {- empty -} { Ocaml.Abs.NoSemi }
             | ';' { Ocaml.Abs.ASemi }
RecordPatContent :: { RecordPatContent }
RecordPatContent : RecordPatField OptionalSemi { Ocaml.Abs.FinalRecordPattern $1 $2 }
                 | RecordPatField ';' '_' { Ocaml.Abs.UnderscoreRecordPattern $1 }
                 | RecordPatField ';' RecordPatContent { Ocaml.Abs.MoreRecordPatterns $1 $3 }
OptionalCoreType :: { OptionalCoreType }
OptionalCoreType : {- empty -} { Ocaml.Abs.NoCoreType }
                 | ':' CoreType { Ocaml.Abs.ACoreType $2 }
RecordPatField :: { RecordPatField }
RecordPatField : LabelLongident OptionalCoreType '=' Pattern { Ocaml.Abs.RecordPatField $1 $2 $4 }
ValueDescription :: { ValueDescription }
ValueDescription : 'val' Ext ListAttribute ValIdent ':' PolyType CoreType ListPostItemAttribute { Ocaml.Abs.ValueDescription $2 (reverse $3) $4 $6 $7 (reverse $8) }
ListRawString :: { [RawString] }
ListRawString : RawString { (:[]) $1 }
              | RawString ListRawString { (:) $1 $2 }
PrimitiveDeclaration :: { PrimitiveDeclaration }
PrimitiveDeclaration : 'external' Ext ListAttribute ValIdent ':' PolyType CoreType '=' ListRawString ListPostItemAttribute { Ocaml.Abs.PrmitiveDeclaration $2 (reverse $3) $4 $6 $7 $9 (reverse $10) }
TypeDeclarations :: { TypeDeclarations }
TypeDeclarations : TypeDeclaration ListAndTypeDeclaration { Ocaml.Abs.TypeDeclarations $1 $2 }
AndTypeDeclaration :: { AndTypeDeclaration }
AndTypeDeclaration : ListAttribute ListTypeParameter LIDENT TypeKind ListConstraint ListPostItemAttribute { Ocaml.Abs.AndTypeDeclaration (reverse $1) $2 $3 $4 (reverse $5) (reverse $6) }
ListAndTypeDeclaration :: { [AndTypeDeclaration] }
ListAndTypeDeclaration : {- empty -} { [] }
                       | AndTypeDeclaration { (:[]) $1 }
                       | AndTypeDeclaration 'and' ListAndTypeDeclaration { (:) $1 $3 }
TypeSubstDeclarations :: { TypeSubstDeclarations }
TypeSubstDeclarations : TypeSubstDeclaration ListAndTypeSubstDeclaration { Ocaml.Abs.TypeSubstDeclarations $1 $2 }
AndTypeSubstDeclaration :: { AndTypeSubstDeclaration }
AndTypeSubstDeclaration : 'and' ListAttribute ListTypeParameter LIDENT TypeSubstKind ListConstraint ListPostItemAttribute { Ocaml.Abs.AndTypeSubstDeclaration (reverse $2) $3 $4 $5 (reverse $6) (reverse $7) }
ListAndTypeSubstDeclaration :: { [AndTypeSubstDeclaration] }
ListAndTypeSubstDeclaration : {- empty -} { [] }
                            | AndTypeSubstDeclaration { (:[]) $1 }
                            | AndTypeSubstDeclaration 'and' ListAndTypeSubstDeclaration { (:) $1 $3 }
TypeSubstDeclaration :: { TypeSubstDeclaration }
TypeSubstDeclaration : 'type' Ext ListAttribute TypeParameters LIDENT TypeSubstKind ListConstraint ListPostItemAttribute { Ocaml.Abs.TypeSubstDeclaration $2 (reverse $3) $4 $5 $6 (reverse $7) (reverse $8) }
TypeDeclaration :: { TypeDeclaration }
TypeDeclaration : 'type' Ext ListAttribute TypeParameters LIDENT TypeKind ListConstraint ListPostItemAttribute { Ocaml.Abs.TypeDeclaration $2 (reverse $3) $4 $5 $6 (reverse $7) (reverse $8) }
Constraint :: { Constraint }
Constraint : 'constraint' Constrain { Ocaml.Abs.Constraint $2 }
ListConstraint :: { [Constraint] }
ListConstraint : {- empty -} { [] }
               | ListConstraint Constraint { flip (:) $1 $2 }
NonemptyTypeKind :: { NonemptyTypeKind }
NonemptyTypeKind : InlinePrivateFlag CoreType { Ocaml.Abs.NonemptyTypeKind1 $1 $2 }
                 | TypeSynonym InlinePrivateFlag ConstructorDeclarations { Ocaml.Abs.NonemptyTypeKind2 $1 $2 $3 }
                 | TypeSynonym InlinePrivateFlag '..' { Ocaml.Abs.NonemptyTypeKind3 $1 $2 }
                 | TypeSynonym InlinePrivateFlag '{' LabelDeclarations '}' { Ocaml.Abs.NonemptyTypeKind4 $1 $2 $4 }
TypeSynonym :: { TypeSynonym }
TypeSynonym : {- empty -} { Ocaml.Abs.NoTypeSynonym }
            | '=' CoreType { Ocaml.Abs.TypeSynonym $2 }
TypeKind :: { TypeKind }
TypeKind : {- empty -} { Ocaml.Abs.NoTypeKind }
         | '=' NonemptyTypeKind { Ocaml.Abs.TypeKind $2 }
TypeSubstKind :: { TypeSubstKind }
TypeSubstKind : ':=' NonemptyTypeKind { Ocaml.Abs.TypeSubstKind $2 }
TypeParameters :: { TypeParameters }
TypeParameters : {- empty -} { Ocaml.Abs.NoTypeParameters }
               | TypeParameter { Ocaml.Abs.SingleTypeParameter $1 }
               | '(' ListTypeParameter ')' { Ocaml.Abs.TypeParameters $2 }
ListTypeParameter :: { [TypeParameter] }
ListTypeParameter : TypeParameter { (:[]) $1 }
                  | TypeParameter ',' ListTypeParameter { (:) $1 $3 }
TypeParameter :: { TypeParameter }
TypeParameter : TypeVariance TypeVariable { Ocaml.Abs.TypeParameter $1 $2 }
TypeVariable :: { TypeVariable }
TypeVariable : '\'' Ident { Ocaml.Abs.TypeVariable $2 }
             | '_' { Ocaml.Abs.Underscore }
TypeVariance :: { TypeVariance }
TypeVariance : {- empty -} { Ocaml.Abs.NoVarianceNoInjectivity }
             | '+' { Ocaml.Abs.CovariantNoInjectivity }
             | '-' { Ocaml.Abs.ContravariantNoInjectivity }
             | '!' { Ocaml.Abs.NoVarianceInjective }
             | '+!' { Ocaml.Abs.CovariantInjective }
             | '!+' { Ocaml.Abs.InjectiveCovariant }
             | '-!' { Ocaml.Abs.ContravariantInjective }
             | '!-' { Ocaml.Abs.InjectiveContravariant }
             | PLUSMINUSOP { Ocaml.Abs.InfixOpVariance $1 }
             | PREFIXOP { Ocaml.Abs.PrefixOpVariance $1 }
ListConstructorDeclaration :: { [ConstructorDeclaration] }
ListConstructorDeclaration : ConstructorDeclaration { (:[]) $1 }
                           | ConstructorDeclaration '|' ListConstructorDeclaration { (:) $1 $3 }
                           | ConstructorDeclaration { (:[]) $1 }
                           | ConstructorDeclaration '|' ListConstructorDeclaration { (:) $1 $3 }
ConstructorDeclarations :: { ConstructorDeclarations }
ConstructorDeclarations : '|' { Ocaml.Abs.EmptyConstructorDeclarations }
                        | '|' ListConstructorDeclaration { Ocaml.Abs.BarConstructorDeclarations $2 }
                        | ListConstructorDeclaration { Ocaml.Abs.ConstructorDeclarations $1 }
ConstructorDeclaration :: { ConstructorDeclaration }
ConstructorDeclaration : ConstrIdent GeneralizedConstructorArguments ListAttribute { Ocaml.Abs.ConstructorDeclaration $1 $2 (reverse $3) }
StrExceptionDeclaration :: { StrExceptionDeclaration }
StrExceptionDeclaration : SigExceptionDeclaration { Ocaml.Abs.SigStrExceptionDeclaration $1 }
                        | 'exception' Ext ListAttribute ConstrIdent '=' ConstrLongident ListAttribute ListPostItemAttribute { Ocaml.Abs.Exception $2 (reverse $3) $4 $6 (reverse $7) (reverse $8) }
SigExceptionDeclaration :: { SigExceptionDeclaration }
SigExceptionDeclaration : 'exception' Ext ListAttribute ConstrIdent GeneralizedConstructorArguments ListAttribute ListPostItemAttribute { Ocaml.Abs.SigExceptionDeclaration $2 (reverse $3) $4 $5 (reverse $6) (reverse $7) }
LetExceptionDeclaration :: { LetExceptionDeclaration }
LetExceptionDeclaration : ConstrIdent GeneralizedConstructorArguments ListAttribute { Ocaml.Abs.LetExceptionDeclaration $1 $2 (reverse $3) }
GeneralizedConstructorArguments :: { GeneralizedConstructorArguments }
GeneralizedConstructorArguments : {- empty -} { Ocaml.Abs.NoGeneralizedConstructorArguments }
                                | 'of' ConstructorArguments { Ocaml.Abs.GeneralizedConstructorArguments1 $2 }
                                | ':' ConstructorArguments '->' AtomicType { Ocaml.Abs.GeneralizedConstructorArguments2 $2 $4 }
                                | ':' ListTypeVar '.' ConstructorArguments '->' AtomicType { Ocaml.Abs.GeneralizedConstructorArguments3 $2 $4 $6 }
                                | ':' AtomicType { Ocaml.Abs.GeneralizedConstructorArguments4 $2 }
                                | ':' ListTypeVar '.' AtomicType { Ocaml.Abs.GeneralizedConstructorArguments5 $2 $4 }
ConstructorArguments :: { ConstructorArguments }
ConstructorArguments : ListAtomicType { Ocaml.Abs.Arg1 $1 }
                     | '{' LabelDeclarations '}' { Ocaml.Abs.Arg2 $2 }
LabelDeclarations :: { LabelDeclarations }
LabelDeclarations : LabelDeclaration { Ocaml.Abs.FinalLabelDeclaration $1 }
                  | LabelDeclarationSemi { Ocaml.Abs.FinalLabelDeclarationSemi $1 }
                  | LabelDeclarationSemi LabelDeclarations { Ocaml.Abs.MoreLabelDeclarations $1 $2 }
LabelDeclaration :: { LabelDeclaration }
LabelDeclaration : MutableFlag Label ':' PolyTypeNoAttr ListAttribute { Ocaml.Abs.LabelDeclaration $1 $2 $4 (reverse $5) }
LabelDeclarationSemi :: { LabelDeclarationSemi }
LabelDeclarationSemi : MutableFlag Label ':' PolyTypeNoAttr ListAttribute ';' ListAttribute { Ocaml.Abs.LabelDeclarationSemi $1 $2 $4 (reverse $5) (reverse $7) }
StrTypeExtension :: { StrTypeExtension }
StrTypeExtension : 'type' Ext ListAttribute TypeParameters TypeLongident '+=' PrivateFlag BarLlistExtensionConstructor ListPostItemAttribute { Ocaml.Abs.StrTypeExtension $2 (reverse $3) $4 $5 $7 $8 (reverse $9) }
BarLlistExtensionConstructor :: { BarLlistExtensionConstructor }
BarLlistExtensionConstructor : '|' { Ocaml.Abs.NoExtensionConstructors }
                             | '|' ListExtensionConstructor { Ocaml.Abs.BarExtensionConstructors $2 }
                             | ListExtensionConstructor { Ocaml.Abs.ExtensionConstructors $1 }
ListExtensionConstructor :: { [ExtensionConstructor] }
ListExtensionConstructor : {- empty -} { [] }
                         | ExtensionConstructor { (:[]) $1 }
                         | ExtensionConstructor '|' ListExtensionConstructor { (:) $1 $3 }
SigTypeExtension :: { SigTypeExtension }
SigTypeExtension : 'type' Ext ListAttribute TypeParameters TypeLongident '+=' PrivateFlag BarLlistExtensionConstructorDeclaration ListPostItemAttribute { Ocaml.Abs.SigTypeExtension $2 (reverse $3) $4 $5 $7 $8 (reverse $9) }
BarLlistExtensionConstructorDeclaration :: { BarLlistExtensionConstructorDeclaration }
BarLlistExtensionConstructorDeclaration : '|' { Ocaml.Abs.NoConstructor }
                                        | '|' ListExtensionConstructorDeclaration { Ocaml.Abs.Constructor $2 }
                                        | ListExtensionConstructorDeclaration { Ocaml.Abs.Constructor $1 }
ListExtensionConstructorDeclaration :: { [ExtensionConstructorDeclaration] }
ListExtensionConstructorDeclaration : {- empty -} { [] }
                                    | ExtensionConstructorDeclaration { (:[]) $1 }
                                    | ExtensionConstructorDeclaration '|' ListExtensionConstructorDeclaration { (:) $1 $3 }
ExtensionConstructor :: { ExtensionConstructor }
ExtensionConstructor : ExtensionConstructorDeclaration { Ocaml.Abs.Declaration $1 }
                     | ExtensionConstructorRebind { Ocaml.Abs.Rebind $1 }
ExtensionConstructorDeclaration :: { ExtensionConstructorDeclaration }
ExtensionConstructorDeclaration : ConstrIdent GeneralizedConstructorArguments ListAttribute { Ocaml.Abs.ExtensionConstructorDeclaration $1 $2 (reverse $3) }
ExtensionConstructorRebind :: { ExtensionConstructorRebind }
ExtensionConstructorRebind : ConstrIdent '=' ConstrLongident ListAttribute { Ocaml.Abs.ExtensionConstructorRebind $1 $3 (reverse $4) }
WithConstraint :: { WithConstraint }
WithConstraint : 'type' TypeParameters LabelLongident WithTypeBinder CoreTypeNoAttr ListConstraint { Ocaml.Abs.WithConstraint1 $2 $3 $4 $5 (reverse $6) }
               | 'type' TypeParameters LabelLongident ':=' CoreTypeNoAttr { Ocaml.Abs.WithConstraint2 $2 $3 $5 }
               | 'module' ModLongident '=' ModExtLongident { Ocaml.Abs.WithConstraint3 $2 $4 }
               | 'module' ModLongident ':=' ModExtLongident { Ocaml.Abs.WithConstraint4 $2 $4 }
               | 'module' 'type' MtyLongident '=' ModuleType { Ocaml.Abs.WithConstraint5 $3 $5 }
               | 'module' 'type' MtyLongident ':=' ModuleType { Ocaml.Abs.WithConstraint6 $3 $5 }
WithTypeBinder :: { WithTypeBinder }
WithTypeBinder : '=' { Ocaml.Abs.WithTypeBinderEqual }
               | '=' 'private' { Ocaml.Abs.WithTypeBinderEqualPrivate }
TypeVar :: { TypeVar }
TypeVar : '\'' Ident { Ocaml.Abs.TypeVarIdent $2 }
ListTypeVar :: { [TypeVar] }
ListTypeVar : TypeVar { (:[]) $1 }
            | TypeVar ListTypeVar { (:) $1 $2 }
PolyType :: { PolyType }
PolyType : CoreType { Ocaml.Abs.MonoCoreType $1 }
         | ListTypeVar '.' CoreType { Ocaml.Abs.PolyCoreType $1 $3 }
PolyTypeNoAttr :: { PolyTypeNoAttr }
PolyTypeNoAttr : CoreTypeNoAttr { Ocaml.Abs.MonoCoreTypeNoAttr $1 }
               | ListTypeVar '.' CoreTypeNoAttr { Ocaml.Abs.PolyCoreTypeNoAttr $1 $3 }
CoreType :: { CoreType }
CoreType : AliasType { Ocaml.Abs.CoreTypeWithoutAttribute $1 }
         | CoreType Attribute { Ocaml.Abs.CoreTypeWithAttribute $1 $2 }
CoreTypeNoAttr :: { CoreTypeNoAttr }
CoreTypeNoAttr : AliasType { Ocaml.Abs.CoreTypeNoAttr $1 }
AliasType :: { AliasType }
AliasType : FunctionType { Ocaml.Abs.FunctionType $1 }
          | AliasType 'as' TypeVar { Ocaml.Abs.AliasType $1 $3 }
FunctionType :: { FunctionType }
FunctionType : TupleType { Ocaml.Abs.TupleType $1 }
             | ArgLabel TupleType '->' FunctionType { Ocaml.Abs.FunType $1 $2 $4 }
ArgLabel :: { ArgLabel }
ArgLabel : OPTLABEL { Ocaml.Abs.OptArgLabelTodo $1 }
         | '?' LIDENT ':' { Ocaml.Abs.OptArgLabel $2 }
         | LIDENT ':' { Ocaml.Abs.ArgLabel $1 }
         | {- empty -} { Ocaml.Abs.NoArgLabel }
TupleType :: { TupleType }
TupleType : AtomicType { Ocaml.Abs.AtomicType $1 }
          | AtomicType '*' ListAtomicType { Ocaml.Abs.AtomicTypes $1 $3 }
ListAtomicType :: { [AtomicType] }
ListAtomicType : AtomicType { (:[]) $1 }
               | AtomicType '*' ListAtomicType { (:) $1 $3 }
OptionalBar :: { OptionalBar }
OptionalBar : {- empty -} { Ocaml.Abs.NoBar }
            | '|' { Ocaml.Abs.ABar }
DelimitedTypeSupportingLocalOpen :: { DelimitedTypeSupportingLocalOpen }
DelimitedTypeSupportingLocalOpen : '(' CoreType ')' { Ocaml.Abs.LocalOpen1 $2 }
                                 | '(' 'module' Ext ListAttribute PackageType ')' { Ocaml.Abs.LocalOpen2 $3 (reverse $4) $5 }
                                 | '[' TagField ']' { Ocaml.Abs.LocalOpen3 $2 }
                                 | '[' '|' ListRowField ']' { Ocaml.Abs.LocalOpen4 $3 }
                                 | '[' RowField '|' ListRowField ']' { Ocaml.Abs.LocalOpen5 $2 $4 }
                                 | '[>' OptionalBar ListRowField ']' { Ocaml.Abs.LocalOpen6 $2 $3 }
                                 | '[>' ']' { Ocaml.Abs.LocalOpen7 }
                                 | '[<' OptionalBar ListRowField ']' { Ocaml.Abs.LocalOpen8 $2 $3 }
                                 | '[<' OptionalBar ListRowField '>' ListNameTag ']' { Ocaml.Abs.LocalOpen9 $2 $3 $5 }
ObjectType :: { ObjectType }
ObjectType : '<' MethList '>' { Ocaml.Abs.MethList $2 }
           | '<' '>' { Ocaml.Abs.Empty }
DelimitedType :: { DelimitedType }
DelimitedType : ObjectType { Ocaml.Abs.ObjectType $1 }
              | Extension { Ocaml.Abs.DelimitedTypeExtension $1 }
              | DelimitedTypeSupportingLocalOpen { Ocaml.Abs.DelimitedTypeSupportingLocalOpen $1 }
AtomicType :: { AtomicType }
AtomicType : DelimitedType { Ocaml.Abs.DelimitedType $1 }
           | ActualTypeParameters TypeLongident { Ocaml.Abs.TypeApp $1 $2 }
           | ActualTypeParameters '#' CltyLongident { Ocaml.Abs.SubTypeApp $1 $3 }
           | ModExtLongident '.' DelimitedTypeSupportingLocalOpen { Ocaml.Abs.QualifiedDelimitedType $1 $3 }
           | '\'' Ident { Ocaml.Abs.TypeVar $2 }
           | '_' { Ocaml.Abs.UnderscoreType }
ActualTypeParameters :: { ActualTypeParameters }
ActualTypeParameters : {- empty -} { Ocaml.Abs.NoActualTypeParamters }
                     | AtomicType { Ocaml.Abs.SingleActualTypeParameter $1 }
                     | '(' CoreType ',' ListCoreType ')' { Ocaml.Abs.ActualTypeParameters $2 $4 }
PackageType :: { PackageType }
PackageType : ModuleType { Ocaml.Abs.PackageType $1 }
ListRowField :: { [RowField] }
ListRowField : RowField { (:[]) $1 }
             | RowField '|' ListRowField { (:) $1 $3 }
RowField :: { RowField }
RowField : TagField { Ocaml.Abs.TagField $1 }
         | CoreType { Ocaml.Abs.CoreType $1 }
TagField :: { TagField }
TagField : NameTag 'of' OptAmpersand ListCoreTypeNoAttr ListAttribute { Ocaml.Abs.Of $1 $3 $4 (reverse $5) }
         | NameTag ListAttribute { Ocaml.Abs.Tag $1 (reverse $2) }
OptAmpersand :: { OptAmpersand }
OptAmpersand : '&' { Ocaml.Abs.Ampersand }
             | {- empty -} { Ocaml.Abs.NoAmpersand }
ListCoreTypeNoAttr :: { [CoreTypeNoAttr] }
ListCoreTypeNoAttr : CoreTypeNoAttr { (:[]) $1 }
                   | CoreTypeNoAttr '&' ListCoreTypeNoAttr { (:) $1 $3 }
ListNameTag :: { [NameTag] }
ListNameTag : NameTag { (:[]) $1 }
            | NameTag ListNameTag { (:) $1 $2 }
MethList :: { MethList }
MethList : Label ':' PolyTypeNoAttr ListAttribute ';' ListAttribute MethList { Ocaml.Abs.FieldSemiMethList $1 $3 (reverse $4) (reverse $6) $7 }
         | AtomicType ';' MethList { Ocaml.Abs.InheritSemiMethList $1 $3 }
         | Label ':' PolyTypeNoAttr ListAttribute ';' { Ocaml.Abs.FieldSemi $1 $3 (reverse $4) }
         | AtomicType ';' { Ocaml.Abs.InheritSemi $1 }
         | Label ':' PolyTypeNoAttr ListAttribute { Ocaml.Abs.Field $1 $3 (reverse $4) }
         | AtomicType { Ocaml.Abs.Inherit $1 }
         | '..' { Ocaml.Abs.DotDot }
Label :: { Label }
Label : LIDENT { Ocaml.Abs.LabelIdent $1 }
Constant :: { Constant }
Constant : INT { Ocaml.Abs.Int $1 }
         | CHAR { Ocaml.Abs.Char $1 }
         | STRING { Ocaml.Abs.String $1 }
         | FLOAT { Ocaml.Abs.Float $1 }
SignedConstant :: { SignedConstant }
SignedConstant : Constant { Ocaml.Abs.Constant $1 }
               | '-' INT { Ocaml.Abs.NegInt $2 }
               | '-' FLOAT { Ocaml.Abs.NegFloat $2 }
               | '+' INT { Ocaml.Abs.PosInt $2 }
               | '+' FLOAT { Ocaml.Abs.PosFloat $2 }
OCamlIdent :: { OCamlIdent }
OCamlIdent : UIDENT { Ocaml.Abs.Uppercase $1 }
           | LIDENT { Ocaml.Abs.Lowercase $1 }
ValExtraIdent :: { ValExtraIdent }
ValExtraIdent : '(' Operator ')' { Ocaml.Abs.Operator $2 }
ValIdent :: { ValIdent }
ValIdent : LIDENT { Ocaml.Abs.LowercaseValIdent $1 }
         | ValExtraIdent { Ocaml.Abs.ValExtraIdent $1 }
Operator :: { Operator }
Operator : PREFIXOP { Ocaml.Abs.PrefixOp $1 }
         | LETOP { Ocaml.Abs.LetOp $1 }
         | ANDOP { Ocaml.Abs.AndOp $1 }
         | DOTOP '(' IndexMod ')' { Ocaml.Abs.ArrayAccessOp $1 $3 }
         | DOTOP '(' IndexMod ')' '<-' { Ocaml.Abs.ArrayUpdateOp $1 $3 }
         | DOTOP '[' IndexMod ']' { Ocaml.Abs.StringAccessOp $1 $3 }
         | DOTOP '[' IndexMod ']' '<-' { Ocaml.Abs.StringUpdateOp $1 $3 }
         | DOTOP '{' IndexMod '}' { Ocaml.Abs.RecordAccessOp $1 $3 }
         | DOTOP '{' IndexMod '}' '<-' { Ocaml.Abs.RecordUpdateOp $1 $3 }
         | HASHOP { Ocaml.Abs.HashSymbolOp $1 }
         | '!' { Ocaml.Abs.BangOp }
         | InfixOperator { Ocaml.Abs.InfixOp $1 }
InfixOperator :: { InfixOperator }
InfixOperator : RELOP { Ocaml.Abs.RelOp $1 }
              | CONCATOP { Ocaml.Abs.ConcatOp $1 }
              | PLUSMINUSOP { Ocaml.Abs.PlusMinusOp $1 }
              | MULTDIVOP { Ocaml.Abs.MultDivOp $1 }
              | POWOP { Ocaml.Abs.PowOp $1 }
              | '+' { Ocaml.Abs.InfixPlus }
              | '+.' { Ocaml.Abs.InfixPlusDot }
              | '+=' { Ocaml.Abs.InfixPlusEq }
              | '-' { Ocaml.Abs.InfixMinus }
              | '-.' { Ocaml.Abs.InfixMinusDot }
              | '*' { Ocaml.Abs.InfixStar }
              | '%' { Ocaml.Abs.InfixPercent }
              | '=' { Ocaml.Abs.InfixEqual }
              | '<' { Ocaml.Abs.InfixLess }
              | '>' { Ocaml.Abs.InfixGreater }
              | 'or' { Ocaml.Abs.InfixOr }
              | '||' { Ocaml.Abs.InfixBarBar }
              | '&' { Ocaml.Abs.InfixAmpersand }
              | '&&' { Ocaml.Abs.InfixAmpersandAmpersand }
              | ':=' { Ocaml.Abs.InfixColonEqual }
IndexMod :: { IndexMod }
IndexMod : {- empty -} { Ocaml.Abs.NoIndexMod }
         | ';' '..' { Ocaml.Abs.SemiDotDot }
ConstrExtraIdent :: { ConstrExtraIdent }
ConstrExtraIdent : '(' '::' ')' { Ocaml.Abs.ConstrIdent }
ConstrExtraNonprefixIdent :: { ConstrExtraNonprefixIdent }
ConstrExtraNonprefixIdent : '[' ']' { Ocaml.Abs.Brackets }
                          | '(' ')' { Ocaml.Abs.Parens }
                          | 'false' { Ocaml.Abs.FalseLiteral }
                          | 'true' { Ocaml.Abs.TrueLiteral }
ConstrIdent :: { ConstrIdent }
ConstrIdent : UIDENT { Ocaml.Abs.ConstrUppercaseIdent $1 }
            | ConstrExtraIdent { Ocaml.Abs.ConstrExtraIdent $1 }
            | ConstrExtraNonprefixIdent { Ocaml.Abs.ConstrExpraNonprefixIdent $1 }
ConstrLongident :: { ConstrLongident }
ConstrLongident : ModLongident { Ocaml.Abs.ModLongidentTodo $1 }
                | ModLongident '.' ConstrExtraIdent { Ocaml.Abs.QualifiedConstrExtraLongident $1 $3 }
                | ConstrExtraIdent { Ocaml.Abs.ConstrExtraLongdent $1 }
                | ConstrExtraNonprefixIdent { Ocaml.Abs.ConstrExtraNonprefixLonident $1 }
ValLongident :: { ValLongident }
ValLongident : ValIdent { Ocaml.Abs.ValLongident $1 }
             | ModLongident '.' ValIdent { Ocaml.Abs.QualifiedValLongident $1 $3 }
LabelLongident :: { LabelLongident }
LabelLongident : LIDENT { Ocaml.Abs.LabelLongident $1 }
               | ModLongident '.' LIDENT { Ocaml.Abs.QualifiedLabelLongident $1 $3 }
TypeLongident :: { TypeLongident }
TypeLongident : LIDENT { Ocaml.Abs.TypeLongident $1 }
              | ModExtLongident '.' LIDENT { Ocaml.Abs.QualifiedTypelLongident $1 $3 }
ModLongident :: { ModLongident }
ModLongident : UIDENT { Ocaml.Abs.ModLongident $1 }
             | ModLongident '.' UIDENT { Ocaml.Abs.QualifiedModLongident $1 $3 }
ModExtLongident :: { ModExtLongident }
ModExtLongident : UIDENT { Ocaml.Abs.ModExtLongident $1 }
                | ModExtLongident '.' UIDENT { Ocaml.Abs.QualifiedModExtLongident $1 $3 }
                | ModExtLongident '(' ModExtLongident ')' { Ocaml.Abs.ParenModExtLongident $1 $3 }
MtyLongident :: { MtyLongident }
MtyLongident : OCamlIdent { Ocaml.Abs.MtyLongident $1 }
             | ModExtLongident '.' OCamlIdent { Ocaml.Abs.QualifiedMtyLongident $1 $3 }
CltyLongident :: { CltyLongident }
CltyLongident : LIDENT { Ocaml.Abs.CltyLongident $1 }
              | ModExtLongident '.' LIDENT { Ocaml.Abs.QualifiedCltyLongident $1 $3 }
ClassLongident :: { ClassLongident }
ClassLongident : LIDENT { Ocaml.Abs.ClassLongident $1 }
               | ModLongident '.' LIDENT { Ocaml.Abs.QualifiedClassLongident $1 $3 }
OptionalToplevelDirectiveArgument :: { OptionalToplevelDirectiveArgument }
OptionalToplevelDirectiveArgument : {- empty -} { Ocaml.Abs.NoToplevelDirectiveArgument }
                                  | ToplevelDirectiveArgument { Ocaml.Abs.AToplevelDirectiveArgument $1 }
ToplevelDirective :: { ToplevelDirective }
ToplevelDirective : '#' Ident ToplevelDirectiveArgument { Ocaml.Abs.ToplevelDirectiveApp $2 $3 }
ToplevelDirectiveArgument :: { ToplevelDirectiveArgument }
ToplevelDirectiveArgument : String { Ocaml.Abs.ToplevelString $1 }
                          | Integer { Ocaml.Abs.ToplevelInt $1 }
                          | ValLongident { Ocaml.Abs.ValueIdent $1 }
                          | ModLongident { Ocaml.Abs.ToplevelModuleIdent $1 }
                          | 'false' { Ocaml.Abs.ToplevelFalse }
                          | 'true' { Ocaml.Abs.ToplevelTrue }
RawString :: { RawString }
RawString : String { Ocaml.Abs.RawString $1 }
NameTag :: { NameTag }
NameTag : '`' Ident { Ocaml.Abs.NameTag $2 }
RecFlag :: { RecFlag }
RecFlag : {- empty -} { Ocaml.Abs.Nonrecursive }
        | 'rec' { Ocaml.Abs.Recursive }
NonrecFlag :: { NonrecFlag }
NonrecFlag : {- empty -} { Ocaml.Abs.NoNonrecFlag }
           | 'nonrec' { Ocaml.Abs.ANonrecFlag }
DirectionFlag :: { DirectionFlag }
DirectionFlag : 'to' { Ocaml.Abs.UpTo }
              | 'downto' { Ocaml.Abs.DownTo }
PrivateFlag :: { PrivateFlag }
PrivateFlag : {- empty -} { Ocaml.Abs.Public }
            | 'private' { Ocaml.Abs.Private }
InlinePrivateFlag :: { InlinePrivateFlag }
InlinePrivateFlag : {- empty -} { Ocaml.Abs.InlinePublic }
                  | 'private' { Ocaml.Abs.InlinePrivate }
MutableFlag :: { MutableFlag }
MutableFlag : {- empty -} { Ocaml.Abs.Immutable }
            | 'mutable' { Ocaml.Abs.Mutable }
VirtualFlag :: { VirtualFlag }
VirtualFlag : {- empty -} { Ocaml.Abs.Concrete }
            | 'virtual' { Ocaml.Abs.Virtual }
MutableVirtualFlags :: { MutableVirtualFlags }
MutableVirtualFlags : {- empty -} { Ocaml.Abs.ImmutableContrete }
                    | 'mutable' { Ocaml.Abs.MutableConcrete }
                    | 'virtual' { Ocaml.Abs.ImmutableVirtual }
                    | 'mutable' 'virtual' { Ocaml.Abs.MutableVirtual }
                    | 'virtual' 'mutable' { Ocaml.Abs.VirtualMutable }
PrivateVirtualFlags :: { PrivateVirtualFlags }
PrivateVirtualFlags : {- empty -} { Ocaml.Abs.PublicConcrete }
                    | 'private' { Ocaml.Abs.PrivateConcrete }
                    | 'virtual' { Ocaml.Abs.PublicVirtual }
                    | 'private' 'virtual' { Ocaml.Abs.PrivateVirtual }
                    | 'virtual' 'private' { Ocaml.Abs.VirtualPrivate }
VirtualWithMutableFlag :: { VirtualWithMutableFlag }
VirtualWithMutableFlag : 'virtual' { Ocaml.Abs.VirtualWithImmutable }
                       | 'mutable' 'virtual' { Ocaml.Abs.MutableWithVirtual }
                       | 'virtual' 'mutable' { Ocaml.Abs.VirtualWithMutable }
                       | 'private' 'virtual' { Ocaml.Abs.PrivateWithVirtual }
                       | 'virtual' 'private' { Ocaml.Abs.VirtualWithPrivate }
VirtualWithPrivateFlag :: { VirtualWithPrivateFlag }
VirtualWithPrivateFlag : 'virtual' { Ocaml.Abs.VirtualWithPublic }
NoOverrideFlag :: { NoOverrideFlag }
NoOverrideFlag : {- empty -} { Ocaml.Abs.NoFlag }
OverrideFlag :: { OverrideFlag }
OverrideFlag : {- empty -} { Ocaml.Abs.Fresh }
             | '!' { Ocaml.Abs.Override }
Subtractive :: { Subtractive }
Subtractive : '-' { Ocaml.Abs.Minus } | '-.' { Ocaml.Abs.MinusDot }
Additive :: { Additive }
Additive : '+' { Ocaml.Abs.Plus } | '+.' { Ocaml.Abs.PlusDot }
AttrId :: { AttrId }
AttrId : LIDENT { Ocaml.Abs.LowercaseAttr $1 }
       | UIDENT { Ocaml.Abs.UppercaseAttr $1 }
       | 'and' { Ocaml.Abs.AndAttr }
       | 'as' { Ocaml.Abs.AsAttr }
       | 'assert' { Ocaml.Abs.AssertAttr }
       | 'begin' { Ocaml.Abs.BeginAttr }
       | 'class' { Ocaml.Abs.ClassAttr }
       | 'constraint' { Ocaml.Abs.ConstraintAttr }
       | 'do' { Ocaml.Abs.DoAttr }
       | 'done' { Ocaml.Abs.DoneAttr }
       | 'downto' { Ocaml.Abs.DowntoAttr }
       | 'else' { Ocaml.Abs.ElseAttr }
       | 'end' { Ocaml.Abs.EndAttr }
       | 'exception' { Ocaml.Abs.ExceptionAttr }
       | 'external' { Ocaml.Abs.ExternalAttr }
       | 'false' { Ocaml.Abs.FalseAttr }
       | 'for' { Ocaml.Abs.ForAttr }
       | 'fun' { Ocaml.Abs.FunAttr }
       | 'function' { Ocaml.Abs.FunctionAttr }
       | 'functor' { Ocaml.Abs.FunctorAttr }
       | 'if' { Ocaml.Abs.IfAttr }
       | 'in' { Ocaml.Abs.InAttr }
       | 'include' { Ocaml.Abs.IncludeAttr }
       | 'inherit' { Ocaml.Abs.InheritAttr }
       | 'initializer' { Ocaml.Abs.InitializerAttr }
       | 'lazy' { Ocaml.Abs.LazyAttr }
       | 'let' { Ocaml.Abs.LetAttr }
       | 'match' { Ocaml.Abs.MatchAttr }
       | 'method' { Ocaml.Abs.MethodAttr }
       | 'module' { Ocaml.Abs.ModuleAttr }
       | 'mutable' { Ocaml.Abs.MutableAttr }
       | 'new' { Ocaml.Abs.NewAttr }
       | 'nonrec' { Ocaml.Abs.NonrecAttr }
       | 'object' { Ocaml.Abs.ObjectAttr }
       | 'of' { Ocaml.Abs.OfAttr }
       | 'open' { Ocaml.Abs.OpenAttr }
       | 'or' { Ocaml.Abs.OrAttr }
       | 'private' { Ocaml.Abs.PrivateAttr }
       | 'rec' { Ocaml.Abs.RecAttr }
       | 'sig' { Ocaml.Abs.SigAttr }
       | 'struct' { Ocaml.Abs.StructAttr }
       | 'then' { Ocaml.Abs.ThenAttr }
       | 'to' { Ocaml.Abs.ToAttr }
       | 'true' { Ocaml.Abs.TrueAttr }
       | 'try' { Ocaml.Abs.TryAttr }
       | 'type' { Ocaml.Abs.TypeAttr }
       | 'val' { Ocaml.Abs.ValAttr }
       | 'virtual' { Ocaml.Abs.VirtualAttr }
       | 'when' { Ocaml.Abs.WhenAttr }
       | 'while' { Ocaml.Abs.WhileAttr }
       | 'with' { Ocaml.Abs.WithAttr }
ListAttrId :: { [AttrId] }
ListAttrId : AttrId { (:[]) $1 }
           | AttrId '.' ListAttrId { (:) $1 $3 }
Attribute :: { Attribute }
Attribute : '[@' ListAttrId AttrPayload ']' { Ocaml.Abs.Attribute $2 $3 }
PostItemAttribute :: { PostItemAttribute }
PostItemAttribute : '[@@' ListAttrId AttrPayload ']' { Ocaml.Abs.PostItemAttribute $2 $3 }
FloatingAttribute :: { FloatingAttribute }
FloatingAttribute : '[@@@' ListAttrId AttrPayload ']' { Ocaml.Abs.FloatingAttribute $2 $3 }
ListPostItemAttribute :: { [PostItemAttribute] }
ListPostItemAttribute : {- empty -} { [] }
                      | ListPostItemAttribute PostItemAttribute { flip (:) $1 $2 }
ListAttribute :: { [Attribute] }
ListAttribute : {- empty -} { [] }
              | ListAttribute Attribute { flip (:) $1 $2 }
Ext :: { Ext }
Ext : {- empty -} { Ocaml.Abs.NoExt }
    | '%' ListAttrId { Ocaml.Abs.Ext $2 }
Extension :: { Extension }
Extension : '[%' ListAttrId Payload ']' { Ocaml.Abs.ExtensionPayload $2 $3 }
          | QUOTED_STRING_EXPR { Ocaml.Abs.QuotedStringExpr $1 }
ItemExtension :: { ItemExtension }
ItemExtension : '[%%' ListAttrId Payload ']' { Ocaml.Abs.ItemExtensionPayload $2 $3 }
              | QUOTED_STRING_ITEM { Ocaml.Abs.QuotedStringItem $1 }
Payload :: { Payload }
Payload : Structure { Ocaml.Abs.PayloadStructure $1 }
        | ':' Signature { Ocaml.Abs.PayloadSignature $2 }
        | ':' CoreType { Ocaml.Abs.PayloadCoreType $2 }
        | '?' Pattern { Ocaml.Abs.PayloadPattern $2 }
        | '?' Pattern 'when' SeqExpr { Ocaml.Abs.PayloadGuardedPattern $2 $4 }
AttrPayload :: { AttrPayload }
AttrPayload : Payload { Ocaml.Abs.AttrPayload $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

